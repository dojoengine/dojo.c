# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
from dataclasses import dataclass
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform


# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_dojo_c_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_dojo_c_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_dojo_c_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(f"junk data left in buffer at end of consume_with_stream {s.remaining()}")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError(f"junk data left in buffer at end of read_with_stream {s.remaining()}")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiFfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))
# Initial value and increment amount for handles. 
# These ensure that Python-generated handles always have the lowest bit set
_UNIFFI_HANDLEMAP_INITIAL = 1
_UNIFFI_HANDLEMAP_DELTA = 2

class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = _UNIFFI_HANDLEMAP_INITIAL

    def insert(self, obj):
        with self._lock:
            return self._insert(obj)

    """Low-level insert, this assumes `self._lock` is held."""
    def _insert(self, obj):
        handle = self._counter
        self._counter += _UNIFFI_HANDLEMAP_DELTA
        self._map[handle] = obj
        return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.get: Invalid handle {handle}")

    def clone(self, handle):
        try:
            with self._lock:
                obj = self._map[handle]
                return self._insert(obj)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.clone: Invalid handle {handle}")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.remove: Invalid handle: {handle}")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("dojo_c")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 30
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_dojo_c_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    pass

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_dojo_c_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_dojo_c_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_dojo_c_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rustbuffer_free.restype = None
_UniffiLib.ffi_dojo_c_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rustbuffer_reserve.restype = _UniffiRustBuffer
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFutureDroppedCallbackStruct(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK),
    ]
_UniffiLib.ffi_dojo_c_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_u8.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_dojo_c_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_u8.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_i8.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_dojo_c_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_i8.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_u16.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_dojo_c_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_u16.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_i16.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_dojo_c_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_i16.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_u32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_dojo_c_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_u32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_i32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_dojo_c_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_i32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_u64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_dojo_c_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_u64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_i64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_dojo_c_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_i64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_f32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_dojo_c_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_f32.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_f64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_dojo_c_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_f64.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_dojo_c_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_dojo_c_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_poll_void.restype = None
_UniffiLib.ffi_dojo_c_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_cancel_void.restype = None
_UniffiLib.ffi_dojo_c_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_dojo_c_rust_future_complete_void.restype = None
_UniffiLib.ffi_dojo_c_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_dojo_c_rust_future_free_void.restype = None
_UniffiLib.ffi_dojo_c_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_dojo_c_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)



# Public interface members begin here.


class _UniffiFfiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()


class _UniffiFfiConverterTypeFieldElement:
    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiFfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiFfiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiFfiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiFfiConverterString.lower(value)


FieldElement = str

class _UniffiFfiConverterBoolean:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiFfiConverterFloat64(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiFfiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

@dataclass
class AchievementTask:
    def __init__(self, *, task_id:str, description:str, total:int, total_completions:int, completion_rate:float, created_at:int):
        self.task_id = task_id
        self.description = description
        self.total = total
        self.total_completions = total_completions
        self.completion_rate = completion_rate
        self.created_at = created_at
        
        

    
    def __str__(self):
        return "AchievementTask(task_id={}, description={}, total={}, total_completions={}, completion_rate={}, created_at={})".format(self.task_id, self.description, self.total, self.total_completions, self.completion_rate, self.created_at)
    def __eq__(self, other):
        if self.task_id != other.task_id:
            return False
        if self.description != other.description:
            return False
        if self.total != other.total:
            return False
        if self.total_completions != other.total_completions:
            return False
        if self.completion_rate != other.completion_rate:
            return False
        if self.created_at != other.created_at:
            return False
        return True

class _UniffiFfiConverterTypeAchievementTask(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AchievementTask(
            task_id=_UniffiFfiConverterString.read(buf),
            description=_UniffiFfiConverterString.read(buf),
            total=_UniffiFfiConverterUInt32.read(buf),
            total_completions=_UniffiFfiConverterUInt32.read(buf),
            completion_rate=_UniffiFfiConverterFloat64.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.task_id)
        _UniffiFfiConverterString.check_lower(value.description)
        _UniffiFfiConverterUInt32.check_lower(value.total)
        _UniffiFfiConverterUInt32.check_lower(value.total_completions)
        _UniffiFfiConverterFloat64.check_lower(value.completion_rate)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.task_id, buf)
        _UniffiFfiConverterString.write(value.description, buf)
        _UniffiFfiConverterUInt32.write(value.total, buf)
        _UniffiFfiConverterUInt32.write(value.total_completions, buf)
        _UniffiFfiConverterFloat64.write(value.completion_rate, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)

class _UniffiFfiConverterSequenceTypeAchievementTask(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeAchievementTask.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeAchievementTask.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeAchievementTask.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Achievement:
    def __init__(self, *, id:str, world_address:FieldElement, namespace:str, entity_id:str, hidden:bool, index:int, points:int, start:str, end:str, group:str, icon:str, title:str, description:str, tasks:typing.List[AchievementTask], data:typing.Optional[str], total_completions:int, completion_rate:float, created_at:int, updated_at:int):
        self.id = id
        self.world_address = world_address
        self.namespace = namespace
        self.entity_id = entity_id
        self.hidden = hidden
        self.index = index
        self.points = points
        self.start = start
        self.end = end
        self.group = group
        self.icon = icon
        self.title = title
        self.description = description
        self.tasks = tasks
        self.data = data
        self.total_completions = total_completions
        self.completion_rate = completion_rate
        self.created_at = created_at
        self.updated_at = updated_at
        
        

    
    def __str__(self):
        return "Achievement(id={}, world_address={}, namespace={}, entity_id={}, hidden={}, index={}, points={}, start={}, end={}, group={}, icon={}, title={}, description={}, tasks={}, data={}, total_completions={}, completion_rate={}, created_at={}, updated_at={})".format(self.id, self.world_address, self.namespace, self.entity_id, self.hidden, self.index, self.points, self.start, self.end, self.group, self.icon, self.title, self.description, self.tasks, self.data, self.total_completions, self.completion_rate, self.created_at, self.updated_at)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.world_address != other.world_address:
            return False
        if self.namespace != other.namespace:
            return False
        if self.entity_id != other.entity_id:
            return False
        if self.hidden != other.hidden:
            return False
        if self.index != other.index:
            return False
        if self.points != other.points:
            return False
        if self.start != other.start:
            return False
        if self.end != other.end:
            return False
        if self.group != other.group:
            return False
        if self.icon != other.icon:
            return False
        if self.title != other.title:
            return False
        if self.description != other.description:
            return False
        if self.tasks != other.tasks:
            return False
        if self.data != other.data:
            return False
        if self.total_completions != other.total_completions:
            return False
        if self.completion_rate != other.completion_rate:
            return False
        if self.created_at != other.created_at:
            return False
        if self.updated_at != other.updated_at:
            return False
        return True

class _UniffiFfiConverterTypeAchievement(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Achievement(
            id=_UniffiFfiConverterString.read(buf),
            world_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            namespace=_UniffiFfiConverterString.read(buf),
            entity_id=_UniffiFfiConverterString.read(buf),
            hidden=_UniffiFfiConverterBoolean.read(buf),
            index=_UniffiFfiConverterUInt32.read(buf),
            points=_UniffiFfiConverterUInt32.read(buf),
            start=_UniffiFfiConverterString.read(buf),
            end=_UniffiFfiConverterString.read(buf),
            group=_UniffiFfiConverterString.read(buf),
            icon=_UniffiFfiConverterString.read(buf),
            title=_UniffiFfiConverterString.read(buf),
            description=_UniffiFfiConverterString.read(buf),
            tasks=_UniffiFfiConverterSequenceTypeAchievementTask.read(buf),
            data=_UniffiFfiConverterOptionalString.read(buf),
            total_completions=_UniffiFfiConverterUInt32.read(buf),
            completion_rate=_UniffiFfiConverterFloat64.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
            updated_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.world_address)
        _UniffiFfiConverterString.check_lower(value.namespace)
        _UniffiFfiConverterString.check_lower(value.entity_id)
        _UniffiFfiConverterBoolean.check_lower(value.hidden)
        _UniffiFfiConverterUInt32.check_lower(value.index)
        _UniffiFfiConverterUInt32.check_lower(value.points)
        _UniffiFfiConverterString.check_lower(value.start)
        _UniffiFfiConverterString.check_lower(value.end)
        _UniffiFfiConverterString.check_lower(value.group)
        _UniffiFfiConverterString.check_lower(value.icon)
        _UniffiFfiConverterString.check_lower(value.title)
        _UniffiFfiConverterString.check_lower(value.description)
        _UniffiFfiConverterSequenceTypeAchievementTask.check_lower(value.tasks)
        _UniffiFfiConverterOptionalString.check_lower(value.data)
        _UniffiFfiConverterUInt32.check_lower(value.total_completions)
        _UniffiFfiConverterFloat64.check_lower(value.completion_rate)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)
        _UniffiFfiConverterUInt64.check_lower(value.updated_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.world_address, buf)
        _UniffiFfiConverterString.write(value.namespace, buf)
        _UniffiFfiConverterString.write(value.entity_id, buf)
        _UniffiFfiConverterBoolean.write(value.hidden, buf)
        _UniffiFfiConverterUInt32.write(value.index, buf)
        _UniffiFfiConverterUInt32.write(value.points, buf)
        _UniffiFfiConverterString.write(value.start, buf)
        _UniffiFfiConverterString.write(value.end, buf)
        _UniffiFfiConverterString.write(value.group, buf)
        _UniffiFfiConverterString.write(value.icon, buf)
        _UniffiFfiConverterString.write(value.title, buf)
        _UniffiFfiConverterString.write(value.description, buf)
        _UniffiFfiConverterSequenceTypeAchievementTask.write(value.tasks, buf)
        _UniffiFfiConverterOptionalString.write(value.data, buf)
        _UniffiFfiConverterUInt32.write(value.total_completions, buf)
        _UniffiFfiConverterFloat64.write(value.completion_rate, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)
        _UniffiFfiConverterUInt64.write(value.updated_at, buf)

class _UniffiFfiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class AchievementProgression:
    def __init__(self, *, id:str, achievement_id:str, task_id:str, world_address:FieldElement, namespace:str, player_id:FieldElement, count:int, completed:bool, completed_at:typing.Optional[int], created_at:int, updated_at:int):
        self.id = id
        self.achievement_id = achievement_id
        self.task_id = task_id
        self.world_address = world_address
        self.namespace = namespace
        self.player_id = player_id
        self.count = count
        self.completed = completed
        self.completed_at = completed_at
        self.created_at = created_at
        self.updated_at = updated_at
        
        

    
    def __str__(self):
        return "AchievementProgression(id={}, achievement_id={}, task_id={}, world_address={}, namespace={}, player_id={}, count={}, completed={}, completed_at={}, created_at={}, updated_at={})".format(self.id, self.achievement_id, self.task_id, self.world_address, self.namespace, self.player_id, self.count, self.completed, self.completed_at, self.created_at, self.updated_at)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.achievement_id != other.achievement_id:
            return False
        if self.task_id != other.task_id:
            return False
        if self.world_address != other.world_address:
            return False
        if self.namespace != other.namespace:
            return False
        if self.player_id != other.player_id:
            return False
        if self.count != other.count:
            return False
        if self.completed != other.completed:
            return False
        if self.completed_at != other.completed_at:
            return False
        if self.created_at != other.created_at:
            return False
        if self.updated_at != other.updated_at:
            return False
        return True

class _UniffiFfiConverterTypeAchievementProgression(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AchievementProgression(
            id=_UniffiFfiConverterString.read(buf),
            achievement_id=_UniffiFfiConverterString.read(buf),
            task_id=_UniffiFfiConverterString.read(buf),
            world_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            namespace=_UniffiFfiConverterString.read(buf),
            player_id=_UniffiFfiConverterTypeFieldElement.read(buf),
            count=_UniffiFfiConverterUInt32.read(buf),
            completed=_UniffiFfiConverterBoolean.read(buf),
            completed_at=_UniffiFfiConverterOptionalUInt64.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
            updated_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterString.check_lower(value.achievement_id)
        _UniffiFfiConverterString.check_lower(value.task_id)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.world_address)
        _UniffiFfiConverterString.check_lower(value.namespace)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.player_id)
        _UniffiFfiConverterUInt32.check_lower(value.count)
        _UniffiFfiConverterBoolean.check_lower(value.completed)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.completed_at)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)
        _UniffiFfiConverterUInt64.check_lower(value.updated_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterString.write(value.achievement_id, buf)
        _UniffiFfiConverterString.write(value.task_id, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.world_address, buf)
        _UniffiFfiConverterString.write(value.namespace, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.player_id, buf)
        _UniffiFfiConverterUInt32.write(value.count, buf)
        _UniffiFfiConverterBoolean.write(value.completed, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.completed_at, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)
        _UniffiFfiConverterUInt64.write(value.updated_at, buf)

class _UniffiFfiConverterSequenceTypeFieldElement(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeFieldElement.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeFieldElement.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeFieldElement.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterString.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBoolean.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBoolean.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")






class PaginationDirection(enum.Enum):
    
    FORWARD = 0
    
    BACKWARD = 1
    


class _UniffiFfiConverterTypePaginationDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaginationDirection.FORWARD
        if variant == 2:
            return PaginationDirection.BACKWARD
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaginationDirection.FORWARD:
            return
        if value == PaginationDirection.BACKWARD:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaginationDirection.FORWARD:
            buf.write_i32(1)
        if value == PaginationDirection.BACKWARD:
            buf.write_i32(2)








class OrderDirection(enum.Enum):
    
    ASC = 0
    
    DESC = 1
    


class _UniffiFfiConverterTypeOrderDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OrderDirection.ASC
        if variant == 2:
            return OrderDirection.DESC
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == OrderDirection.ASC:
            return
        if value == OrderDirection.DESC:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == OrderDirection.ASC:
            buf.write_i32(1)
        if value == OrderDirection.DESC:
            buf.write_i32(2)



@dataclass
class OrderBy:
    def __init__(self, *, field:str, direction:OrderDirection):
        self.field = field
        self.direction = direction
        
        

    
    def __str__(self):
        return "OrderBy(field={}, direction={})".format(self.field, self.direction)
    def __eq__(self, other):
        if self.field != other.field:
            return False
        if self.direction != other.direction:
            return False
        return True

class _UniffiFfiConverterTypeOrderBy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OrderBy(
            field=_UniffiFfiConverterString.read(buf),
            direction=_UniffiFfiConverterTypeOrderDirection.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.field)
        _UniffiFfiConverterTypeOrderDirection.check_lower(value.direction)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.field, buf)
        _UniffiFfiConverterTypeOrderDirection.write(value.direction, buf)

class _UniffiFfiConverterSequenceTypeOrderBy(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeOrderBy.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeOrderBy.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeOrderBy.read(buf) for i in range(count)
        ]

@dataclass
class Pagination:
    def __init__(self, *, cursor:typing.Optional[str], limit:typing.Optional[int], direction:PaginationDirection, order_by:typing.List[OrderBy]):
        self.cursor = cursor
        self.limit = limit
        self.direction = direction
        self.order_by = order_by
        
        

    
    def __str__(self):
        return "Pagination(cursor={}, limit={}, direction={}, order_by={})".format(self.cursor, self.limit, self.direction, self.order_by)
    def __eq__(self, other):
        if self.cursor != other.cursor:
            return False
        if self.limit != other.limit:
            return False
        if self.direction != other.direction:
            return False
        if self.order_by != other.order_by:
            return False
        return True

class _UniffiFfiConverterTypePagination(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Pagination(
            cursor=_UniffiFfiConverterOptionalString.read(buf),
            limit=_UniffiFfiConverterOptionalUInt32.read(buf),
            direction=_UniffiFfiConverterTypePaginationDirection.read(buf),
            order_by=_UniffiFfiConverterSequenceTypeOrderBy.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalString.check_lower(value.cursor)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.limit)
        _UniffiFfiConverterTypePaginationDirection.check_lower(value.direction)
        _UniffiFfiConverterSequenceTypeOrderBy.check_lower(value.order_by)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalString.write(value.cursor, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.limit, buf)
        _UniffiFfiConverterTypePaginationDirection.write(value.direction, buf)
        _UniffiFfiConverterSequenceTypeOrderBy.write(value.order_by, buf)

@dataclass
class AchievementQuery:
    def __init__(self, *, world_addresses:typing.List[FieldElement], namespaces:typing.List[str], hidden:typing.Optional[bool], pagination:Pagination):
        self.world_addresses = world_addresses
        self.namespaces = namespaces
        self.hidden = hidden
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "AchievementQuery(world_addresses={}, namespaces={}, hidden={}, pagination={})".format(self.world_addresses, self.namespaces, self.hidden, self.pagination)
    def __eq__(self, other):
        if self.world_addresses != other.world_addresses:
            return False
        if self.namespaces != other.namespaces:
            return False
        if self.hidden != other.hidden:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeAchievementQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AchievementQuery(
            world_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            namespaces=_UniffiFfiConverterSequenceString.read(buf),
            hidden=_UniffiFfiConverterOptionalBoolean.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.world_addresses)
        _UniffiFfiConverterSequenceString.check_lower(value.namespaces)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.hidden)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.world_addresses, buf)
        _UniffiFfiConverterSequenceString.write(value.namespaces, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.hidden, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)

@dataclass
class ActionCount:
    def __init__(self, *, action_name:str, count:int):
        self.action_name = action_name
        self.count = count
        
        

    
    def __str__(self):
        return "ActionCount(action_name={}, count={})".format(self.action_name, self.count)
    def __eq__(self, other):
        if self.action_name != other.action_name:
            return False
        if self.count != other.count:
            return False
        return True

class _UniffiFfiConverterTypeActionCount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ActionCount(
            action_name=_UniffiFfiConverterString.read(buf),
            count=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.action_name)
        _UniffiFfiConverterUInt32.check_lower(value.count)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.action_name, buf)
        _UniffiFfiConverterUInt32.write(value.count, buf)

class _UniffiFfiConverterSequenceTypeActionCount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeActionCount.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeActionCount.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeActionCount.read(buf) for i in range(count)
        ]

@dataclass
class Activity:
    def __init__(self, *, id:str, world_address:FieldElement, namespace:str, caller_address:FieldElement, session_start:int, session_end:int, action_count:int, actions:typing.List[ActionCount], updated_at:int):
        self.id = id
        self.world_address = world_address
        self.namespace = namespace
        self.caller_address = caller_address
        self.session_start = session_start
        self.session_end = session_end
        self.action_count = action_count
        self.actions = actions
        self.updated_at = updated_at
        
        

    
    def __str__(self):
        return "Activity(id={}, world_address={}, namespace={}, caller_address={}, session_start={}, session_end={}, action_count={}, actions={}, updated_at={})".format(self.id, self.world_address, self.namespace, self.caller_address, self.session_start, self.session_end, self.action_count, self.actions, self.updated_at)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.world_address != other.world_address:
            return False
        if self.namespace != other.namespace:
            return False
        if self.caller_address != other.caller_address:
            return False
        if self.session_start != other.session_start:
            return False
        if self.session_end != other.session_end:
            return False
        if self.action_count != other.action_count:
            return False
        if self.actions != other.actions:
            return False
        if self.updated_at != other.updated_at:
            return False
        return True

class _UniffiFfiConverterTypeActivity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Activity(
            id=_UniffiFfiConverterString.read(buf),
            world_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            namespace=_UniffiFfiConverterString.read(buf),
            caller_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            session_start=_UniffiFfiConverterUInt64.read(buf),
            session_end=_UniffiFfiConverterUInt64.read(buf),
            action_count=_UniffiFfiConverterUInt32.read(buf),
            actions=_UniffiFfiConverterSequenceTypeActionCount.read(buf),
            updated_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.world_address)
        _UniffiFfiConverterString.check_lower(value.namespace)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.caller_address)
        _UniffiFfiConverterUInt64.check_lower(value.session_start)
        _UniffiFfiConverterUInt64.check_lower(value.session_end)
        _UniffiFfiConverterUInt32.check_lower(value.action_count)
        _UniffiFfiConverterSequenceTypeActionCount.check_lower(value.actions)
        _UniffiFfiConverterUInt64.check_lower(value.updated_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.world_address, buf)
        _UniffiFfiConverterString.write(value.namespace, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.caller_address, buf)
        _UniffiFfiConverterUInt64.write(value.session_start, buf)
        _UniffiFfiConverterUInt64.write(value.session_end, buf)
        _UniffiFfiConverterUInt32.write(value.action_count, buf)
        _UniffiFfiConverterSequenceTypeActionCount.write(value.actions, buf)
        _UniffiFfiConverterUInt64.write(value.updated_at, buf)

@dataclass
class ActivityQuery:
    def __init__(self, *, world_addresses:typing.List[FieldElement], namespaces:typing.List[str], caller_addresses:typing.List[FieldElement], from_time:typing.Optional[int], to_time:typing.Optional[int], pagination:Pagination):
        self.world_addresses = world_addresses
        self.namespaces = namespaces
        self.caller_addresses = caller_addresses
        self.from_time = from_time
        self.to_time = to_time
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "ActivityQuery(world_addresses={}, namespaces={}, caller_addresses={}, from_time={}, to_time={}, pagination={})".format(self.world_addresses, self.namespaces, self.caller_addresses, self.from_time, self.to_time, self.pagination)
    def __eq__(self, other):
        if self.world_addresses != other.world_addresses:
            return False
        if self.namespaces != other.namespaces:
            return False
        if self.caller_addresses != other.caller_addresses:
            return False
        if self.from_time != other.from_time:
            return False
        if self.to_time != other.to_time:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeActivityQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ActivityQuery(
            world_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            namespaces=_UniffiFfiConverterSequenceString.read(buf),
            caller_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            from_time=_UniffiFfiConverterOptionalUInt64.read(buf),
            to_time=_UniffiFfiConverterOptionalUInt64.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.world_addresses)
        _UniffiFfiConverterSequenceString.check_lower(value.namespaces)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.caller_addresses)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.from_time)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.to_time)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.world_addresses, buf)
        _UniffiFfiConverterSequenceString.write(value.namespaces, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.caller_addresses, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.from_time, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.to_time, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)


class _UniffiFfiConverterTypeU256:
    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiFfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiFfiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiFfiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiFfiConverterString.lower(value)


U256 = str

@dataclass
class AggregationEntry:
    def __init__(self, *, id:str, aggregator_id:str, entity_id:str, value:U256, display_value:str, position:int, model_id:str, created_at:int, updated_at:int):
        self.id = id
        self.aggregator_id = aggregator_id
        self.entity_id = entity_id
        self.value = value
        self.display_value = display_value
        self.position = position
        self.model_id = model_id
        self.created_at = created_at
        self.updated_at = updated_at
        
        

    
    def __str__(self):
        return "AggregationEntry(id={}, aggregator_id={}, entity_id={}, value={}, display_value={}, position={}, model_id={}, created_at={}, updated_at={})".format(self.id, self.aggregator_id, self.entity_id, self.value, self.display_value, self.position, self.model_id, self.created_at, self.updated_at)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.aggregator_id != other.aggregator_id:
            return False
        if self.entity_id != other.entity_id:
            return False
        if self.value != other.value:
            return False
        if self.display_value != other.display_value:
            return False
        if self.position != other.position:
            return False
        if self.model_id != other.model_id:
            return False
        if self.created_at != other.created_at:
            return False
        if self.updated_at != other.updated_at:
            return False
        return True

class _UniffiFfiConverterTypeAggregationEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AggregationEntry(
            id=_UniffiFfiConverterString.read(buf),
            aggregator_id=_UniffiFfiConverterString.read(buf),
            entity_id=_UniffiFfiConverterString.read(buf),
            value=_UniffiFfiConverterTypeU256.read(buf),
            display_value=_UniffiFfiConverterString.read(buf),
            position=_UniffiFfiConverterUInt64.read(buf),
            model_id=_UniffiFfiConverterString.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
            updated_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterString.check_lower(value.aggregator_id)
        _UniffiFfiConverterString.check_lower(value.entity_id)
        _UniffiFfiConverterTypeU256.check_lower(value.value)
        _UniffiFfiConverterString.check_lower(value.display_value)
        _UniffiFfiConverterUInt64.check_lower(value.position)
        _UniffiFfiConverterString.check_lower(value.model_id)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)
        _UniffiFfiConverterUInt64.check_lower(value.updated_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterString.write(value.aggregator_id, buf)
        _UniffiFfiConverterString.write(value.entity_id, buf)
        _UniffiFfiConverterTypeU256.write(value.value, buf)
        _UniffiFfiConverterString.write(value.display_value, buf)
        _UniffiFfiConverterUInt64.write(value.position, buf)
        _UniffiFfiConverterString.write(value.model_id, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)
        _UniffiFfiConverterUInt64.write(value.updated_at, buf)

@dataclass
class AggregationQuery:
    def __init__(self, *, aggregator_ids:typing.List[str], entity_ids:typing.List[str], pagination:Pagination):
        self.aggregator_ids = aggregator_ids
        self.entity_ids = entity_ids
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "AggregationQuery(aggregator_ids={}, entity_ids={}, pagination={})".format(self.aggregator_ids, self.entity_ids, self.pagination)
    def __eq__(self, other):
        if self.aggregator_ids != other.aggregator_ids:
            return False
        if self.entity_ids != other.entity_ids:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeAggregationQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AggregationQuery(
            aggregator_ids=_UniffiFfiConverterSequenceString.read(buf),
            entity_ids=_UniffiFfiConverterSequenceString.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceString.check_lower(value.aggregator_ids)
        _UniffiFfiConverterSequenceString.check_lower(value.entity_ids)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceString.write(value.aggregator_ids, buf)
        _UniffiFfiConverterSequenceString.write(value.entity_ids, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)

@dataclass
class AttributeFilter:
    def __init__(self, *, trait_name:str, trait_value:str):
        self.trait_name = trait_name
        self.trait_value = trait_value
        
        

    
    def __str__(self):
        return "AttributeFilter(trait_name={}, trait_value={})".format(self.trait_name, self.trait_value)
    def __eq__(self, other):
        if self.trait_name != other.trait_name:
            return False
        if self.trait_value != other.trait_value:
            return False
        return True

class _UniffiFfiConverterTypeAttributeFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AttributeFilter(
            trait_name=_UniffiFfiConverterString.read(buf),
            trait_value=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.trait_name)
        _UniffiFfiConverterString.check_lower(value.trait_value)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.trait_name, buf)
        _UniffiFfiConverterString.write(value.trait_value, buf)






class LogicalOperator(enum.Enum):
    
    AND = 0
    
    OR = 1
    


class _UniffiFfiConverterTypeLogicalOperator(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LogicalOperator.AND
        if variant == 2:
            return LogicalOperator.OR
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LogicalOperator.AND:
            return
        if value == LogicalOperator.OR:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LogicalOperator.AND:
            buf.write_i32(1)
        if value == LogicalOperator.OR:
            buf.write_i32(2)



class _UniffiFfiConverterOptionalTypeFieldElement(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeFieldElement.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeFieldElement.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeFieldElement.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceOptionalTypeFieldElement(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterOptionalTypeFieldElement.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterOptionalTypeFieldElement.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterOptionalTypeFieldElement.read(buf) for i in range(count)
        ]






class PatternMatching(enum.Enum):
    
    FIXED_LEN = 0
    
    VARIABLE_LEN = 1
    


class _UniffiFfiConverterTypePatternMatching(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PatternMatching.FIXED_LEN
        if variant == 2:
            return PatternMatching.VARIABLE_LEN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PatternMatching.FIXED_LEN:
            return
        if value == PatternMatching.VARIABLE_LEN:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PatternMatching.FIXED_LEN:
            buf.write_i32(1)
        if value == PatternMatching.VARIABLE_LEN:
            buf.write_i32(2)



@dataclass
class KeysClause:
    def __init__(self, *, keys:typing.List[typing.Optional[FieldElement]], pattern_matching:PatternMatching, models:typing.List[str]):
        self.keys = keys
        self.pattern_matching = pattern_matching
        self.models = models
        
        

    
    def __str__(self):
        return "KeysClause(keys={}, pattern_matching={}, models={})".format(self.keys, self.pattern_matching, self.models)
    def __eq__(self, other):
        if self.keys != other.keys:
            return False
        if self.pattern_matching != other.pattern_matching:
            return False
        if self.models != other.models:
            return False
        return True

class _UniffiFfiConverterTypeKeysClause(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeysClause(
            keys=_UniffiFfiConverterSequenceOptionalTypeFieldElement.read(buf),
            pattern_matching=_UniffiFfiConverterTypePatternMatching.read(buf),
            models=_UniffiFfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceOptionalTypeFieldElement.check_lower(value.keys)
        _UniffiFfiConverterTypePatternMatching.check_lower(value.pattern_matching)
        _UniffiFfiConverterSequenceString.check_lower(value.models)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceOptionalTypeFieldElement.write(value.keys, buf)
        _UniffiFfiConverterTypePatternMatching.write(value.pattern_matching, buf)
        _UniffiFfiConverterSequenceString.write(value.models, buf)






class ComparisonOperator(enum.Enum):
    
    EQ = 0
    
    NEQ = 1
    
    GT = 2
    
    GTE = 3
    
    LT = 4
    
    LTE = 5
    
    IN = 6
    
    NOT_IN = 7
    
    CONTAINS = 8
    
    CONTAINS_ALL = 9
    
    CONTAINS_ANY = 10
    
    ARRAY_LENGTH_EQ = 11
    
    ARRAY_LENGTH_GT = 12
    
    ARRAY_LENGTH_LT = 13
    


class _UniffiFfiConverterTypeComparisonOperator(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ComparisonOperator.EQ
        if variant == 2:
            return ComparisonOperator.NEQ
        if variant == 3:
            return ComparisonOperator.GT
        if variant == 4:
            return ComparisonOperator.GTE
        if variant == 5:
            return ComparisonOperator.LT
        if variant == 6:
            return ComparisonOperator.LTE
        if variant == 7:
            return ComparisonOperator.IN
        if variant == 8:
            return ComparisonOperator.NOT_IN
        if variant == 9:
            return ComparisonOperator.CONTAINS
        if variant == 10:
            return ComparisonOperator.CONTAINS_ALL
        if variant == 11:
            return ComparisonOperator.CONTAINS_ANY
        if variant == 12:
            return ComparisonOperator.ARRAY_LENGTH_EQ
        if variant == 13:
            return ComparisonOperator.ARRAY_LENGTH_GT
        if variant == 14:
            return ComparisonOperator.ARRAY_LENGTH_LT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ComparisonOperator.EQ:
            return
        if value == ComparisonOperator.NEQ:
            return
        if value == ComparisonOperator.GT:
            return
        if value == ComparisonOperator.GTE:
            return
        if value == ComparisonOperator.LT:
            return
        if value == ComparisonOperator.LTE:
            return
        if value == ComparisonOperator.IN:
            return
        if value == ComparisonOperator.NOT_IN:
            return
        if value == ComparisonOperator.CONTAINS:
            return
        if value == ComparisonOperator.CONTAINS_ALL:
            return
        if value == ComparisonOperator.CONTAINS_ANY:
            return
        if value == ComparisonOperator.ARRAY_LENGTH_EQ:
            return
        if value == ComparisonOperator.ARRAY_LENGTH_GT:
            return
        if value == ComparisonOperator.ARRAY_LENGTH_LT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ComparisonOperator.EQ:
            buf.write_i32(1)
        if value == ComparisonOperator.NEQ:
            buf.write_i32(2)
        if value == ComparisonOperator.GT:
            buf.write_i32(3)
        if value == ComparisonOperator.GTE:
            buf.write_i32(4)
        if value == ComparisonOperator.LT:
            buf.write_i32(5)
        if value == ComparisonOperator.LTE:
            buf.write_i32(6)
        if value == ComparisonOperator.IN:
            buf.write_i32(7)
        if value == ComparisonOperator.NOT_IN:
            buf.write_i32(8)
        if value == ComparisonOperator.CONTAINS:
            buf.write_i32(9)
        if value == ComparisonOperator.CONTAINS_ALL:
            buf.write_i32(10)
        if value == ComparisonOperator.CONTAINS_ANY:
            buf.write_i32(11)
        if value == ComparisonOperator.ARRAY_LENGTH_EQ:
            buf.write_i32(12)
        if value == ComparisonOperator.ARRAY_LENGTH_GT:
            buf.write_i32(13)
        if value == ComparisonOperator.ARRAY_LENGTH_LT:
            buf.write_i32(14)



class _UniffiFfiConverterInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i8"
    VALUE_MIN = -2**7
    VALUE_MAX = 2**7

    @staticmethod
    def read(buf):
        return buf.read_i8()

    @staticmethod
    def write(value, buf):
        buf.write_i8(value)

class _UniffiFfiConverterInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i16"
    VALUE_MIN = -2**15
    VALUE_MAX = 2**15

    @staticmethod
    def read(buf):
        return buf.read_i16()

    @staticmethod
    def write(value, buf):
        buf.write_i16(value)

class _UniffiFfiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiFfiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiFfiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterUInt8.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)






class Primitive:
    def __init__(self):
        raise RuntimeError("Primitive cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class I8:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.I8(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_I8():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class I16:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.I16(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_I16():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class I32:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.I32(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_I32():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class I64:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.I64(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_I64():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class I128:
        
        def __init__(self, value:typing.List[int]):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.I128(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_I128():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U8:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.U8(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U8():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U16:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.U16(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U16():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U32:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.U32(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U32():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U64:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.U64(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U64():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U128:
        
        def __init__(self, value:typing.List[int]):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.U128(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U128():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U256:
        
        def __init__(self, value:U256):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.U256(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U256():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class BOOL:
        
        def __init__(self, value:bool):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.BOOL(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_BOOL():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class FELT252:
        
        def __init__(self, value:FieldElement):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.FELT252(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_FELT252():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class CLASS_HASH:
        
        def __init__(self, value:FieldElement):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.CLASS_HASH(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_CLASS_HASH():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class CONTRACT_ADDRESS:
        
        def __init__(self, value:FieldElement):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.CONTRACT_ADDRESS(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_CONTRACT_ADDRESS():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class ETH_ADDRESS:
        
        def __init__(self, value:FieldElement):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Primitive.ETH_ADDRESS(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_ETH_ADDRESS():
                return False
            if self.value != other.value:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_I8(self) -> bool:
        return isinstance(self, Primitive.I8)
    def is_i8(self) -> bool:
        return isinstance(self, Primitive.I8)
    def is_I16(self) -> bool:
        return isinstance(self, Primitive.I16)
    def is_i16(self) -> bool:
        return isinstance(self, Primitive.I16)
    def is_I32(self) -> bool:
        return isinstance(self, Primitive.I32)
    def is_i32(self) -> bool:
        return isinstance(self, Primitive.I32)
    def is_I64(self) -> bool:
        return isinstance(self, Primitive.I64)
    def is_i64(self) -> bool:
        return isinstance(self, Primitive.I64)
    def is_I128(self) -> bool:
        return isinstance(self, Primitive.I128)
    def is_i128(self) -> bool:
        return isinstance(self, Primitive.I128)
    def is_U8(self) -> bool:
        return isinstance(self, Primitive.U8)
    def is_u8(self) -> bool:
        return isinstance(self, Primitive.U8)
    def is_U16(self) -> bool:
        return isinstance(self, Primitive.U16)
    def is_u16(self) -> bool:
        return isinstance(self, Primitive.U16)
    def is_U32(self) -> bool:
        return isinstance(self, Primitive.U32)
    def is_u32(self) -> bool:
        return isinstance(self, Primitive.U32)
    def is_U64(self) -> bool:
        return isinstance(self, Primitive.U64)
    def is_u64(self) -> bool:
        return isinstance(self, Primitive.U64)
    def is_U128(self) -> bool:
        return isinstance(self, Primitive.U128)
    def is_u128(self) -> bool:
        return isinstance(self, Primitive.U128)
    def is_U256(self) -> bool:
        return isinstance(self, Primitive.U256)
    def is_u256(self) -> bool:
        return isinstance(self, Primitive.U256)
    def is_BOOL(self) -> bool:
        return isinstance(self, Primitive.BOOL)
    def is_bool(self) -> bool:
        return isinstance(self, Primitive.BOOL)
    def is_FELT252(self) -> bool:
        return isinstance(self, Primitive.FELT252)
    def is_felt252(self) -> bool:
        return isinstance(self, Primitive.FELT252)
    def is_CLASS_HASH(self) -> bool:
        return isinstance(self, Primitive.CLASS_HASH)
    def is_class_hash(self) -> bool:
        return isinstance(self, Primitive.CLASS_HASH)
    def is_CONTRACT_ADDRESS(self) -> bool:
        return isinstance(self, Primitive.CONTRACT_ADDRESS)
    def is_contract_address(self) -> bool:
        return isinstance(self, Primitive.CONTRACT_ADDRESS)
    def is_ETH_ADDRESS(self) -> bool:
        return isinstance(self, Primitive.ETH_ADDRESS)
    def is_eth_address(self) -> bool:
        return isinstance(self, Primitive.ETH_ADDRESS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Primitive.I8 = type("Primitive.I8", (Primitive.I8, Primitive,), {})  # type: ignore
Primitive.I16 = type("Primitive.I16", (Primitive.I16, Primitive,), {})  # type: ignore
Primitive.I32 = type("Primitive.I32", (Primitive.I32, Primitive,), {})  # type: ignore
Primitive.I64 = type("Primitive.I64", (Primitive.I64, Primitive,), {})  # type: ignore
Primitive.I128 = type("Primitive.I128", (Primitive.I128, Primitive,), {})  # type: ignore
Primitive.U8 = type("Primitive.U8", (Primitive.U8, Primitive,), {})  # type: ignore
Primitive.U16 = type("Primitive.U16", (Primitive.U16, Primitive,), {})  # type: ignore
Primitive.U32 = type("Primitive.U32", (Primitive.U32, Primitive,), {})  # type: ignore
Primitive.U64 = type("Primitive.U64", (Primitive.U64, Primitive,), {})  # type: ignore
Primitive.U128 = type("Primitive.U128", (Primitive.U128, Primitive,), {})  # type: ignore
Primitive.U256 = type("Primitive.U256", (Primitive.U256, Primitive,), {})  # type: ignore
Primitive.BOOL = type("Primitive.BOOL", (Primitive.BOOL, Primitive,), {})  # type: ignore
Primitive.FELT252 = type("Primitive.FELT252", (Primitive.FELT252, Primitive,), {})  # type: ignore
Primitive.CLASS_HASH = type("Primitive.CLASS_HASH", (Primitive.CLASS_HASH, Primitive,), {})  # type: ignore
Primitive.CONTRACT_ADDRESS = type("Primitive.CONTRACT_ADDRESS", (Primitive.CONTRACT_ADDRESS, Primitive,), {})  # type: ignore
Primitive.ETH_ADDRESS = type("Primitive.ETH_ADDRESS", (Primitive.ETH_ADDRESS, Primitive,), {})  # type: ignore




class _UniffiFfiConverterTypePrimitive(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Primitive.I8(
                _UniffiFfiConverterInt8.read(buf),
            )
        if variant == 2:
            return Primitive.I16(
                _UniffiFfiConverterInt16.read(buf),
            )
        if variant == 3:
            return Primitive.I32(
                _UniffiFfiConverterInt32.read(buf),
            )
        if variant == 4:
            return Primitive.I64(
                _UniffiFfiConverterInt64.read(buf),
            )
        if variant == 5:
            return Primitive.I128(
                _UniffiFfiConverterSequenceUInt8.read(buf),
            )
        if variant == 6:
            return Primitive.U8(
                _UniffiFfiConverterUInt8.read(buf),
            )
        if variant == 7:
            return Primitive.U16(
                _UniffiFfiConverterUInt16.read(buf),
            )
        if variant == 8:
            return Primitive.U32(
                _UniffiFfiConverterUInt32.read(buf),
            )
        if variant == 9:
            return Primitive.U64(
                _UniffiFfiConverterUInt64.read(buf),
            )
        if variant == 10:
            return Primitive.U128(
                _UniffiFfiConverterSequenceUInt8.read(buf),
            )
        if variant == 11:
            return Primitive.U256(
                _UniffiFfiConverterTypeU256.read(buf),
            )
        if variant == 12:
            return Primitive.BOOL(
                _UniffiFfiConverterBoolean.read(buf),
            )
        if variant == 13:
            return Primitive.FELT252(
                _UniffiFfiConverterTypeFieldElement.read(buf),
            )
        if variant == 14:
            return Primitive.CLASS_HASH(
                _UniffiFfiConverterTypeFieldElement.read(buf),
            )
        if variant == 15:
            return Primitive.CONTRACT_ADDRESS(
                _UniffiFfiConverterTypeFieldElement.read(buf),
            )
        if variant == 16:
            return Primitive.ETH_ADDRESS(
                _UniffiFfiConverterTypeFieldElement.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_I8():
            _UniffiFfiConverterInt8.check_lower(value.value)
            return
        if value.is_I16():
            _UniffiFfiConverterInt16.check_lower(value.value)
            return
        if value.is_I32():
            _UniffiFfiConverterInt32.check_lower(value.value)
            return
        if value.is_I64():
            _UniffiFfiConverterInt64.check_lower(value.value)
            return
        if value.is_I128():
            _UniffiFfiConverterSequenceUInt8.check_lower(value.value)
            return
        if value.is_U8():
            _UniffiFfiConverterUInt8.check_lower(value.value)
            return
        if value.is_U16():
            _UniffiFfiConverterUInt16.check_lower(value.value)
            return
        if value.is_U32():
            _UniffiFfiConverterUInt32.check_lower(value.value)
            return
        if value.is_U64():
            _UniffiFfiConverterUInt64.check_lower(value.value)
            return
        if value.is_U128():
            _UniffiFfiConverterSequenceUInt8.check_lower(value.value)
            return
        if value.is_U256():
            _UniffiFfiConverterTypeU256.check_lower(value.value)
            return
        if value.is_BOOL():
            _UniffiFfiConverterBoolean.check_lower(value.value)
            return
        if value.is_FELT252():
            _UniffiFfiConverterTypeFieldElement.check_lower(value.value)
            return
        if value.is_CLASS_HASH():
            _UniffiFfiConverterTypeFieldElement.check_lower(value.value)
            return
        if value.is_CONTRACT_ADDRESS():
            _UniffiFfiConverterTypeFieldElement.check_lower(value.value)
            return
        if value.is_ETH_ADDRESS():
            _UniffiFfiConverterTypeFieldElement.check_lower(value.value)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_I8():
            buf.write_i32(1)
            _UniffiFfiConverterInt8.write(value.value, buf)
        if value.is_I16():
            buf.write_i32(2)
            _UniffiFfiConverterInt16.write(value.value, buf)
        if value.is_I32():
            buf.write_i32(3)
            _UniffiFfiConverterInt32.write(value.value, buf)
        if value.is_I64():
            buf.write_i32(4)
            _UniffiFfiConverterInt64.write(value.value, buf)
        if value.is_I128():
            buf.write_i32(5)
            _UniffiFfiConverterSequenceUInt8.write(value.value, buf)
        if value.is_U8():
            buf.write_i32(6)
            _UniffiFfiConverterUInt8.write(value.value, buf)
        if value.is_U16():
            buf.write_i32(7)
            _UniffiFfiConverterUInt16.write(value.value, buf)
        if value.is_U32():
            buf.write_i32(8)
            _UniffiFfiConverterUInt32.write(value.value, buf)
        if value.is_U64():
            buf.write_i32(9)
            _UniffiFfiConverterUInt64.write(value.value, buf)
        if value.is_U128():
            buf.write_i32(10)
            _UniffiFfiConverterSequenceUInt8.write(value.value, buf)
        if value.is_U256():
            buf.write_i32(11)
            _UniffiFfiConverterTypeU256.write(value.value, buf)
        if value.is_BOOL():
            buf.write_i32(12)
            _UniffiFfiConverterBoolean.write(value.value, buf)
        if value.is_FELT252():
            buf.write_i32(13)
            _UniffiFfiConverterTypeFieldElement.write(value.value, buf)
        if value.is_CLASS_HASH():
            buf.write_i32(14)
            _UniffiFfiConverterTypeFieldElement.write(value.value, buf)
        if value.is_CONTRACT_ADDRESS():
            buf.write_i32(15)
            _UniffiFfiConverterTypeFieldElement.write(value.value, buf)
        if value.is_ETH_ADDRESS():
            buf.write_i32(16)
            _UniffiFfiConverterTypeFieldElement.write(value.value, buf)



class _UniffiFfiConverterSequenceTypeMemberValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeMemberValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeMemberValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeMemberValue.read(buf) for i in range(count)
        ]






class MemberValue:
    def __init__(self):
        raise RuntimeError("MemberValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class PRIMITIVE:
        
        def __init__(self, value:Primitive):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "MemberValue.PRIMITIVE(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_PRIMITIVE():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class STRING:
        
        def __init__(self, value:str):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "MemberValue.STRING(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_STRING():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class LIST:
        
        def __init__(self, values:typing.List[MemberValue]):
            self.values = values
            
            
            pass

    
            
            
    
        def __str__(self):
            return "MemberValue.LIST(values={})".format(self.values)
        def __eq__(self, other):
            if not other.is_LIST():
                return False
            if self.values != other.values:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_PRIMITIVE(self) -> bool:
        return isinstance(self, MemberValue.PRIMITIVE)
    def is_primitive(self) -> bool:
        return isinstance(self, MemberValue.PRIMITIVE)
    def is_STRING(self) -> bool:
        return isinstance(self, MemberValue.STRING)
    def is_string(self) -> bool:
        return isinstance(self, MemberValue.STRING)
    def is_LIST(self) -> bool:
        return isinstance(self, MemberValue.LIST)
    def is_list(self) -> bool:
        return isinstance(self, MemberValue.LIST)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MemberValue.PRIMITIVE = type("MemberValue.PRIMITIVE", (MemberValue.PRIMITIVE, MemberValue,), {})  # type: ignore
MemberValue.STRING = type("MemberValue.STRING", (MemberValue.STRING, MemberValue,), {})  # type: ignore
MemberValue.LIST = type("MemberValue.LIST", (MemberValue.LIST, MemberValue,), {})  # type: ignore




class _UniffiFfiConverterTypeMemberValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MemberValue.PRIMITIVE(
                _UniffiFfiConverterTypePrimitive.read(buf),
            )
        if variant == 2:
            return MemberValue.STRING(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return MemberValue.LIST(
                _UniffiFfiConverterSequenceTypeMemberValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_PRIMITIVE():
            _UniffiFfiConverterTypePrimitive.check_lower(value.value)
            return
        if value.is_STRING():
            _UniffiFfiConverterString.check_lower(value.value)
            return
        if value.is_LIST():
            _UniffiFfiConverterSequenceTypeMemberValue.check_lower(value.values)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_PRIMITIVE():
            buf.write_i32(1)
            _UniffiFfiConverterTypePrimitive.write(value.value, buf)
        if value.is_STRING():
            buf.write_i32(2)
            _UniffiFfiConverterString.write(value.value, buf)
        if value.is_LIST():
            buf.write_i32(3)
            _UniffiFfiConverterSequenceTypeMemberValue.write(value.values, buf)



@dataclass
class MemberClause:
    def __init__(self, *, model:str, member:str, operator:ComparisonOperator, value:MemberValue):
        self.model = model
        self.member = member
        self.operator = operator
        self.value = value
        
        

    
    def __str__(self):
        return "MemberClause(model={}, member={}, operator={}, value={})".format(self.model, self.member, self.operator, self.value)
    def __eq__(self, other):
        if self.model != other.model:
            return False
        if self.member != other.member:
            return False
        if self.operator != other.operator:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiFfiConverterTypeMemberClause(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MemberClause(
            model=_UniffiFfiConverterString.read(buf),
            member=_UniffiFfiConverterString.read(buf),
            operator=_UniffiFfiConverterTypeComparisonOperator.read(buf),
            value=_UniffiFfiConverterTypeMemberValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.model)
        _UniffiFfiConverterString.check_lower(value.member)
        _UniffiFfiConverterTypeComparisonOperator.check_lower(value.operator)
        _UniffiFfiConverterTypeMemberValue.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.model, buf)
        _UniffiFfiConverterString.write(value.member, buf)
        _UniffiFfiConverterTypeComparisonOperator.write(value.operator, buf)
        _UniffiFfiConverterTypeMemberValue.write(value.value, buf)






class Clause:
    def __init__(self):
        raise RuntimeError("Clause cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class HASHED_KEYS:
        
        def __init__(self, keys:typing.List[FieldElement]):
            self.keys = keys
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Clause.HASHED_KEYS(keys={})".format(self.keys)
        def __eq__(self, other):
            if not other.is_HASHED_KEYS():
                return False
            if self.keys != other.keys:
                return False
            return True

    @dataclass
    class KEYS:
        
        def __init__(self, clause:KeysClause):
            self.clause = clause
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Clause.KEYS(clause={})".format(self.clause)
        def __eq__(self, other):
            if not other.is_KEYS():
                return False
            if self.clause != other.clause:
                return False
            return True

    @dataclass
    class MEMBER:
        
        def __init__(self, clause:MemberClause):
            self.clause = clause
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Clause.MEMBER(clause={})".format(self.clause)
        def __eq__(self, other):
            if not other.is_MEMBER():
                return False
            if self.clause != other.clause:
                return False
            return True

    @dataclass
    class COMPOSITE:
        
        def __init__(self, clause:CompositeClause):
            self.clause = clause
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Clause.COMPOSITE(clause={})".format(self.clause)
        def __eq__(self, other):
            if not other.is_COMPOSITE():
                return False
            if self.clause != other.clause:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_HASHED_KEYS(self) -> bool:
        return isinstance(self, Clause.HASHED_KEYS)
    def is_hashed_keys(self) -> bool:
        return isinstance(self, Clause.HASHED_KEYS)
    def is_KEYS(self) -> bool:
        return isinstance(self, Clause.KEYS)
    def is_keys(self) -> bool:
        return isinstance(self, Clause.KEYS)
    def is_MEMBER(self) -> bool:
        return isinstance(self, Clause.MEMBER)
    def is_member(self) -> bool:
        return isinstance(self, Clause.MEMBER)
    def is_COMPOSITE(self) -> bool:
        return isinstance(self, Clause.COMPOSITE)
    def is_composite(self) -> bool:
        return isinstance(self, Clause.COMPOSITE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Clause.HASHED_KEYS = type("Clause.HASHED_KEYS", (Clause.HASHED_KEYS, Clause,), {})  # type: ignore
Clause.KEYS = type("Clause.KEYS", (Clause.KEYS, Clause,), {})  # type: ignore
Clause.MEMBER = type("Clause.MEMBER", (Clause.MEMBER, Clause,), {})  # type: ignore
Clause.COMPOSITE = type("Clause.COMPOSITE", (Clause.COMPOSITE, Clause,), {})  # type: ignore




class _UniffiFfiConverterTypeClause(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Clause.HASHED_KEYS(
                _UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            )
        if variant == 2:
            return Clause.KEYS(
                _UniffiFfiConverterTypeKeysClause.read(buf),
            )
        if variant == 3:
            return Clause.MEMBER(
                _UniffiFfiConverterTypeMemberClause.read(buf),
            )
        if variant == 4:
            return Clause.COMPOSITE(
                _UniffiFfiConverterTypeCompositeClause.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_HASHED_KEYS():
            _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.keys)
            return
        if value.is_KEYS():
            _UniffiFfiConverterTypeKeysClause.check_lower(value.clause)
            return
        if value.is_MEMBER():
            _UniffiFfiConverterTypeMemberClause.check_lower(value.clause)
            return
        if value.is_COMPOSITE():
            _UniffiFfiConverterTypeCompositeClause.check_lower(value.clause)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_HASHED_KEYS():
            buf.write_i32(1)
            _UniffiFfiConverterSequenceTypeFieldElement.write(value.keys, buf)
        if value.is_KEYS():
            buf.write_i32(2)
            _UniffiFfiConverterTypeKeysClause.write(value.clause, buf)
        if value.is_MEMBER():
            buf.write_i32(3)
            _UniffiFfiConverterTypeMemberClause.write(value.clause, buf)
        if value.is_COMPOSITE():
            buf.write_i32(4)
            _UniffiFfiConverterTypeCompositeClause.write(value.clause, buf)



class _UniffiFfiConverterSequenceTypeClause(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeClause.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeClause.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeClause.read(buf) for i in range(count)
        ]

@dataclass
class CompositeClause:
    def __init__(self, *, operator:LogicalOperator, clauses:typing.List[Clause]):
        self.operator = operator
        self.clauses = clauses
        
        

    
    def __str__(self):
        return "CompositeClause(operator={}, clauses={})".format(self.operator, self.clauses)
    def __eq__(self, other):
        if self.operator != other.operator:
            return False
        if self.clauses != other.clauses:
            return False
        return True

class _UniffiFfiConverterTypeCompositeClause(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CompositeClause(
            operator=_UniffiFfiConverterTypeLogicalOperator.read(buf),
            clauses=_UniffiFfiConverterSequenceTypeClause.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeLogicalOperator.check_lower(value.operator)
        _UniffiFfiConverterSequenceTypeClause.check_lower(value.clauses)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeLogicalOperator.write(value.operator, buf)
        _UniffiFfiConverterSequenceTypeClause.write(value.clauses, buf)






class ContractType(enum.Enum):
    
    WORLD = 0
    
    ERC20 = 1
    
    ERC721 = 2
    
    ERC1155 = 3
    
    UDC = 4
    
    OTHER = 5
    


class _UniffiFfiConverterTypeContractType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ContractType.WORLD
        if variant == 2:
            return ContractType.ERC20
        if variant == 3:
            return ContractType.ERC721
        if variant == 4:
            return ContractType.ERC1155
        if variant == 5:
            return ContractType.UDC
        if variant == 6:
            return ContractType.OTHER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ContractType.WORLD:
            return
        if value == ContractType.ERC20:
            return
        if value == ContractType.ERC721:
            return
        if value == ContractType.ERC1155:
            return
        if value == ContractType.UDC:
            return
        if value == ContractType.OTHER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ContractType.WORLD:
            buf.write_i32(1)
        if value == ContractType.ERC20:
            buf.write_i32(2)
        if value == ContractType.ERC721:
            buf.write_i32(3)
        if value == ContractType.ERC1155:
            buf.write_i32(4)
        if value == ContractType.UDC:
            buf.write_i32(5)
        if value == ContractType.OTHER:
            buf.write_i32(6)



@dataclass
class Contract:
    def __init__(self, *, contract_address:FieldElement, contract_type:ContractType, head:typing.Optional[int], tps:typing.Optional[int], last_block_timestamp:typing.Optional[int], last_pending_block_tx:typing.Optional[FieldElement], updated_at:int, created_at:int):
        self.contract_address = contract_address
        self.contract_type = contract_type
        self.head = head
        self.tps = tps
        self.last_block_timestamp = last_block_timestamp
        self.last_pending_block_tx = last_pending_block_tx
        self.updated_at = updated_at
        self.created_at = created_at
        
        

    
    def __str__(self):
        return "Contract(contract_address={}, contract_type={}, head={}, tps={}, last_block_timestamp={}, last_pending_block_tx={}, updated_at={}, created_at={})".format(self.contract_address, self.contract_type, self.head, self.tps, self.last_block_timestamp, self.last_pending_block_tx, self.updated_at, self.created_at)
    def __eq__(self, other):
        if self.contract_address != other.contract_address:
            return False
        if self.contract_type != other.contract_type:
            return False
        if self.head != other.head:
            return False
        if self.tps != other.tps:
            return False
        if self.last_block_timestamp != other.last_block_timestamp:
            return False
        if self.last_pending_block_tx != other.last_pending_block_tx:
            return False
        if self.updated_at != other.updated_at:
            return False
        if self.created_at != other.created_at:
            return False
        return True

class _UniffiFfiConverterTypeContract(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Contract(
            contract_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            contract_type=_UniffiFfiConverterTypeContractType.read(buf),
            head=_UniffiFfiConverterOptionalUInt64.read(buf),
            tps=_UniffiFfiConverterOptionalUInt64.read(buf),
            last_block_timestamp=_UniffiFfiConverterOptionalUInt64.read(buf),
            last_pending_block_tx=_UniffiFfiConverterOptionalTypeFieldElement.read(buf),
            updated_at=_UniffiFfiConverterUInt64.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.contract_address)
        _UniffiFfiConverterTypeContractType.check_lower(value.contract_type)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.head)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.tps)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.last_block_timestamp)
        _UniffiFfiConverterOptionalTypeFieldElement.check_lower(value.last_pending_block_tx)
        _UniffiFfiConverterUInt64.check_lower(value.updated_at)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.contract_address, buf)
        _UniffiFfiConverterTypeContractType.write(value.contract_type, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.head, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.tps, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.last_block_timestamp, buf)
        _UniffiFfiConverterOptionalTypeFieldElement.write(value.last_pending_block_tx, buf)
        _UniffiFfiConverterUInt64.write(value.updated_at, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)

class _UniffiFfiConverterSequenceTypeContractType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeContractType.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeContractType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeContractType.read(buf) for i in range(count)
        ]

@dataclass
class ContractQuery:
    def __init__(self, *, contract_addresses:typing.List[FieldElement], contract_types:typing.List[ContractType]):
        self.contract_addresses = contract_addresses
        self.contract_types = contract_types
        
        

    
    def __str__(self):
        return "ContractQuery(contract_addresses={}, contract_types={})".format(self.contract_addresses, self.contract_types)
    def __eq__(self, other):
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.contract_types != other.contract_types:
            return False
        return True

class _UniffiFfiConverterTypeContractQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ContractQuery(
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            contract_types=_UniffiFfiConverterSequenceTypeContractType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceTypeContractType.check_lower(value.contract_types)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceTypeContractType.write(value.contract_types, buf)

@dataclass
class Controller:
    def __init__(self, *, address:FieldElement, username:str, deployed_at_timestamp:int):
        self.address = address
        self.username = username
        self.deployed_at_timestamp = deployed_at_timestamp
        
        

    
    def __str__(self):
        return "Controller(address={}, username={}, deployed_at_timestamp={})".format(self.address, self.username, self.deployed_at_timestamp)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.username != other.username:
            return False
        if self.deployed_at_timestamp != other.deployed_at_timestamp:
            return False
        return True

class _UniffiFfiConverterTypeController(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Controller(
            address=_UniffiFfiConverterTypeFieldElement.read(buf),
            username=_UniffiFfiConverterString.read(buf),
            deployed_at_timestamp=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.address)
        _UniffiFfiConverterString.check_lower(value.username)
        _UniffiFfiConverterUInt64.check_lower(value.deployed_at_timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.address, buf)
        _UniffiFfiConverterString.write(value.username, buf)
        _UniffiFfiConverterUInt64.write(value.deployed_at_timestamp, buf)

@dataclass
class ControllerQuery:
    def __init__(self, *, pagination:Pagination, contract_addresses:typing.List[FieldElement], usernames:typing.List[str]):
        self.pagination = pagination
        self.contract_addresses = contract_addresses
        self.usernames = usernames
        
        

    
    def __str__(self):
        return "ControllerQuery(pagination={}, contract_addresses={}, usernames={})".format(self.pagination, self.contract_addresses, self.usernames)
    def __eq__(self, other):
        if self.pagination != other.pagination:
            return False
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.usernames != other.usernames:
            return False
        return True

class _UniffiFfiConverterTypeControllerQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ControllerQuery(
            pagination=_UniffiFfiConverterTypePagination.read(buf),
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            usernames=_UniffiFfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceString.check_lower(value.usernames)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceString.write(value.usernames, buf)

@dataclass
class Member:
    def __init__(self, *, name:str, ty:Ty, key:bool):
        self.name = name
        self.ty = ty
        self.key = key
        
        

    
    def __str__(self):
        return "Member(name={}, ty={}, key={})".format(self.name, self.ty, self.key)
    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.ty != other.ty:
            return False
        if self.key != other.key:
            return False
        return True

class _UniffiFfiConverterTypeMember(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Member(
            name=_UniffiFfiConverterString.read(buf),
            ty=_UniffiFfiConverterTypeTy.read(buf),
            key=_UniffiFfiConverterBoolean.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterTypeTy.check_lower(value.ty)
        _UniffiFfiConverterBoolean.check_lower(value.key)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterTypeTy.write(value.ty, buf)
        _UniffiFfiConverterBoolean.write(value.key, buf)

class _UniffiFfiConverterSequenceTypeMember(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeMember.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeMember.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeMember.read(buf) for i in range(count)
        ]

@dataclass
class Struct:
    def __init__(self, *, name:str, children:typing.List[Member]):
        self.name = name
        self.children = children
        
        

    
    def __str__(self):
        return "Struct(name={}, children={})".format(self.name, self.children)
    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.children != other.children:
            return False
        return True

class _UniffiFfiConverterTypeStruct(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Struct(
            name=_UniffiFfiConverterString.read(buf),
            children=_UniffiFfiConverterSequenceTypeMember.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterSequenceTypeMember.check_lower(value.children)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterSequenceTypeMember.write(value.children, buf)

class _UniffiFfiConverterSequenceTypeEnumOption(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeEnumOption.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeEnumOption.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeEnumOption.read(buf) for i in range(count)
        ]

@dataclass
class EnumType:
    def __init__(self, *, name:str, option:int, options:typing.List[EnumOption]):
        self.name = name
        self.option = option
        self.options = options
        
        

    
    def __str__(self):
        return "EnumType(name={}, option={}, options={})".format(self.name, self.option, self.options)
    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.option != other.option:
            return False
        if self.options != other.options:
            return False
        return True

class _UniffiFfiConverterTypeEnumType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EnumType(
            name=_UniffiFfiConverterString.read(buf),
            option=_UniffiFfiConverterUInt8.read(buf),
            options=_UniffiFfiConverterSequenceTypeEnumOption.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterUInt8.check_lower(value.option)
        _UniffiFfiConverterSequenceTypeEnumOption.check_lower(value.options)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterUInt8.write(value.option, buf)
        _UniffiFfiConverterSequenceTypeEnumOption.write(value.options, buf)

class _UniffiFfiConverterSequenceTypeTy(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeTy.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeTy.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeTy.read(buf) for i in range(count)
        ]

@dataclass
class FixedSizeArray:
    def __init__(self, *, array:typing.List[Ty], size:int):
        self.array = array
        self.size = size
        
        

    
    def __str__(self):
        return "FixedSizeArray(array={}, size={})".format(self.array, self.size)
    def __eq__(self, other):
        if self.array != other.array:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiFfiConverterTypeFixedSizeArray(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FixedSizeArray(
            array=_UniffiFfiConverterSequenceTypeTy.read(buf),
            size=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeTy.check_lower(value.array)
        _UniffiFfiConverterUInt32.check_lower(value.size)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeTy.write(value.array, buf)
        _UniffiFfiConverterUInt32.write(value.size, buf)






class Ty:
    def __init__(self):
        raise RuntimeError("Ty cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class PRIMITIVE:
        
        def __init__(self, value:Primitive):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.PRIMITIVE(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_PRIMITIVE():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class STRUCT:
        
        def __init__(self, value:Struct):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.STRUCT(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_STRUCT():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class ENUM:
        
        def __init__(self, value:EnumType):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.ENUM(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_ENUM():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class TUPLE:
        
        def __init__(self, values:typing.List[Ty]):
            self.values = values
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.TUPLE(values={})".format(self.values)
        def __eq__(self, other):
            if not other.is_TUPLE():
                return False
            if self.values != other.values:
                return False
            return True

    @dataclass
    class ARRAY:
        
        def __init__(self, values:typing.List[Ty]):
            self.values = values
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.ARRAY(values={})".format(self.values)
        def __eq__(self, other):
            if not other.is_ARRAY():
                return False
            if self.values != other.values:
                return False
            return True

    @dataclass
    class FIXED_SIZE_ARRAY:
        
        def __init__(self, value:FixedSizeArray):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.FIXED_SIZE_ARRAY(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_FIXED_SIZE_ARRAY():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class BYTE_ARRAY:
        
        def __init__(self, value:str):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "Ty.BYTE_ARRAY(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_BYTE_ARRAY():
                return False
            if self.value != other.value:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_PRIMITIVE(self) -> bool:
        return isinstance(self, Ty.PRIMITIVE)
    def is_primitive(self) -> bool:
        return isinstance(self, Ty.PRIMITIVE)
    def is_STRUCT(self) -> bool:
        return isinstance(self, Ty.STRUCT)
    def is_struct(self) -> bool:
        return isinstance(self, Ty.STRUCT)
    def is_ENUM(self) -> bool:
        return isinstance(self, Ty.ENUM)
    def is_enum(self) -> bool:
        return isinstance(self, Ty.ENUM)
    def is_TUPLE(self) -> bool:
        return isinstance(self, Ty.TUPLE)
    def is_tuple(self) -> bool:
        return isinstance(self, Ty.TUPLE)
    def is_ARRAY(self) -> bool:
        return isinstance(self, Ty.ARRAY)
    def is_array(self) -> bool:
        return isinstance(self, Ty.ARRAY)
    def is_FIXED_SIZE_ARRAY(self) -> bool:
        return isinstance(self, Ty.FIXED_SIZE_ARRAY)
    def is_fixed_size_array(self) -> bool:
        return isinstance(self, Ty.FIXED_SIZE_ARRAY)
    def is_BYTE_ARRAY(self) -> bool:
        return isinstance(self, Ty.BYTE_ARRAY)
    def is_byte_array(self) -> bool:
        return isinstance(self, Ty.BYTE_ARRAY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Ty.PRIMITIVE = type("Ty.PRIMITIVE", (Ty.PRIMITIVE, Ty,), {})  # type: ignore
Ty.STRUCT = type("Ty.STRUCT", (Ty.STRUCT, Ty,), {})  # type: ignore
Ty.ENUM = type("Ty.ENUM", (Ty.ENUM, Ty,), {})  # type: ignore
Ty.TUPLE = type("Ty.TUPLE", (Ty.TUPLE, Ty,), {})  # type: ignore
Ty.ARRAY = type("Ty.ARRAY", (Ty.ARRAY, Ty,), {})  # type: ignore
Ty.FIXED_SIZE_ARRAY = type("Ty.FIXED_SIZE_ARRAY", (Ty.FIXED_SIZE_ARRAY, Ty,), {})  # type: ignore
Ty.BYTE_ARRAY = type("Ty.BYTE_ARRAY", (Ty.BYTE_ARRAY, Ty,), {})  # type: ignore




class _UniffiFfiConverterTypeTy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Ty.PRIMITIVE(
                _UniffiFfiConverterTypePrimitive.read(buf),
            )
        if variant == 2:
            return Ty.STRUCT(
                _UniffiFfiConverterTypeStruct.read(buf),
            )
        if variant == 3:
            return Ty.ENUM(
                _UniffiFfiConverterTypeEnumType.read(buf),
            )
        if variant == 4:
            return Ty.TUPLE(
                _UniffiFfiConverterSequenceTypeTy.read(buf),
            )
        if variant == 5:
            return Ty.ARRAY(
                _UniffiFfiConverterSequenceTypeTy.read(buf),
            )
        if variant == 6:
            return Ty.FIXED_SIZE_ARRAY(
                _UniffiFfiConverterTypeFixedSizeArray.read(buf),
            )
        if variant == 7:
            return Ty.BYTE_ARRAY(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_PRIMITIVE():
            _UniffiFfiConverterTypePrimitive.check_lower(value.value)
            return
        if value.is_STRUCT():
            _UniffiFfiConverterTypeStruct.check_lower(value.value)
            return
        if value.is_ENUM():
            _UniffiFfiConverterTypeEnumType.check_lower(value.value)
            return
        if value.is_TUPLE():
            _UniffiFfiConverterSequenceTypeTy.check_lower(value.values)
            return
        if value.is_ARRAY():
            _UniffiFfiConverterSequenceTypeTy.check_lower(value.values)
            return
        if value.is_FIXED_SIZE_ARRAY():
            _UniffiFfiConverterTypeFixedSizeArray.check_lower(value.value)
            return
        if value.is_BYTE_ARRAY():
            _UniffiFfiConverterString.check_lower(value.value)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_PRIMITIVE():
            buf.write_i32(1)
            _UniffiFfiConverterTypePrimitive.write(value.value, buf)
        if value.is_STRUCT():
            buf.write_i32(2)
            _UniffiFfiConverterTypeStruct.write(value.value, buf)
        if value.is_ENUM():
            buf.write_i32(3)
            _UniffiFfiConverterTypeEnumType.write(value.value, buf)
        if value.is_TUPLE():
            buf.write_i32(4)
            _UniffiFfiConverterSequenceTypeTy.write(value.values, buf)
        if value.is_ARRAY():
            buf.write_i32(5)
            _UniffiFfiConverterSequenceTypeTy.write(value.values, buf)
        if value.is_FIXED_SIZE_ARRAY():
            buf.write_i32(6)
            _UniffiFfiConverterTypeFixedSizeArray.write(value.value, buf)
        if value.is_BYTE_ARRAY():
            buf.write_i32(7)
            _UniffiFfiConverterString.write(value.value, buf)



@dataclass
class EnumOption:
    def __init__(self, *, name:str, ty:Ty):
        self.name = name
        self.ty = ty
        
        

    
    def __str__(self):
        return "EnumOption(name={}, ty={})".format(self.name, self.ty)
    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.ty != other.ty:
            return False
        return True

class _UniffiFfiConverterTypeEnumOption(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EnumOption(
            name=_UniffiFfiConverterString.read(buf),
            ty=_UniffiFfiConverterTypeTy.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterTypeTy.check_lower(value.ty)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterTypeTy.write(value.ty, buf)

@dataclass
class PlayerAchievementStats:
    def __init__(self, *, total_points:int, completed_achievements:int, total_achievements:int, completion_percentage:float, last_achievement_at:typing.Optional[int], created_at:int, updated_at:int):
        self.total_points = total_points
        self.completed_achievements = completed_achievements
        self.total_achievements = total_achievements
        self.completion_percentage = completion_percentage
        self.last_achievement_at = last_achievement_at
        self.created_at = created_at
        self.updated_at = updated_at
        
        

    
    def __str__(self):
        return "PlayerAchievementStats(total_points={}, completed_achievements={}, total_achievements={}, completion_percentage={}, last_achievement_at={}, created_at={}, updated_at={})".format(self.total_points, self.completed_achievements, self.total_achievements, self.completion_percentage, self.last_achievement_at, self.created_at, self.updated_at)
    def __eq__(self, other):
        if self.total_points != other.total_points:
            return False
        if self.completed_achievements != other.completed_achievements:
            return False
        if self.total_achievements != other.total_achievements:
            return False
        if self.completion_percentage != other.completion_percentage:
            return False
        if self.last_achievement_at != other.last_achievement_at:
            return False
        if self.created_at != other.created_at:
            return False
        if self.updated_at != other.updated_at:
            return False
        return True

class _UniffiFfiConverterTypePlayerAchievementStats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlayerAchievementStats(
            total_points=_UniffiFfiConverterUInt32.read(buf),
            completed_achievements=_UniffiFfiConverterUInt32.read(buf),
            total_achievements=_UniffiFfiConverterUInt32.read(buf),
            completion_percentage=_UniffiFfiConverterFloat64.read(buf),
            last_achievement_at=_UniffiFfiConverterOptionalUInt64.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
            updated_at=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt32.check_lower(value.total_points)
        _UniffiFfiConverterUInt32.check_lower(value.completed_achievements)
        _UniffiFfiConverterUInt32.check_lower(value.total_achievements)
        _UniffiFfiConverterFloat64.check_lower(value.completion_percentage)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.last_achievement_at)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)
        _UniffiFfiConverterUInt64.check_lower(value.updated_at)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt32.write(value.total_points, buf)
        _UniffiFfiConverterUInt32.write(value.completed_achievements, buf)
        _UniffiFfiConverterUInt32.write(value.total_achievements, buf)
        _UniffiFfiConverterFloat64.write(value.completion_percentage, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.last_achievement_at, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)
        _UniffiFfiConverterUInt64.write(value.updated_at, buf)

@dataclass
class TaskProgress:
    def __init__(self, *, task_id:str, count:int, completed:bool):
        self.task_id = task_id
        self.count = count
        self.completed = completed
        
        

    
    def __str__(self):
        return "TaskProgress(task_id={}, count={}, completed={})".format(self.task_id, self.count, self.completed)
    def __eq__(self, other):
        if self.task_id != other.task_id:
            return False
        if self.count != other.count:
            return False
        if self.completed != other.completed:
            return False
        return True

class _UniffiFfiConverterTypeTaskProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TaskProgress(
            task_id=_UniffiFfiConverterString.read(buf),
            count=_UniffiFfiConverterUInt32.read(buf),
            completed=_UniffiFfiConverterBoolean.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.task_id)
        _UniffiFfiConverterUInt32.check_lower(value.count)
        _UniffiFfiConverterBoolean.check_lower(value.completed)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.task_id, buf)
        _UniffiFfiConverterUInt32.write(value.count, buf)
        _UniffiFfiConverterBoolean.write(value.completed, buf)

class _UniffiFfiConverterSequenceTypeTaskProgress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeTaskProgress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeTaskProgress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeTaskProgress.read(buf) for i in range(count)
        ]

@dataclass
class PlayerAchievementProgress:
    def __init__(self, *, achievement:Achievement, task_progress:typing.List[TaskProgress], completed:bool, progress_percentage:float):
        self.achievement = achievement
        self.task_progress = task_progress
        self.completed = completed
        self.progress_percentage = progress_percentage
        
        

    
    def __str__(self):
        return "PlayerAchievementProgress(achievement={}, task_progress={}, completed={}, progress_percentage={})".format(self.achievement, self.task_progress, self.completed, self.progress_percentage)
    def __eq__(self, other):
        if self.achievement != other.achievement:
            return False
        if self.task_progress != other.task_progress:
            return False
        if self.completed != other.completed:
            return False
        if self.progress_percentage != other.progress_percentage:
            return False
        return True

class _UniffiFfiConverterTypePlayerAchievementProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlayerAchievementProgress(
            achievement=_UniffiFfiConverterTypeAchievement.read(buf),
            task_progress=_UniffiFfiConverterSequenceTypeTaskProgress.read(buf),
            completed=_UniffiFfiConverterBoolean.read(buf),
            progress_percentage=_UniffiFfiConverterFloat64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeAchievement.check_lower(value.achievement)
        _UniffiFfiConverterSequenceTypeTaskProgress.check_lower(value.task_progress)
        _UniffiFfiConverterBoolean.check_lower(value.completed)
        _UniffiFfiConverterFloat64.check_lower(value.progress_percentage)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeAchievement.write(value.achievement, buf)
        _UniffiFfiConverterSequenceTypeTaskProgress.write(value.task_progress, buf)
        _UniffiFfiConverterBoolean.write(value.completed, buf)
        _UniffiFfiConverterFloat64.write(value.progress_percentage, buf)

class _UniffiFfiConverterSequenceTypePlayerAchievementProgress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypePlayerAchievementProgress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypePlayerAchievementProgress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypePlayerAchievementProgress.read(buf) for i in range(count)
        ]

@dataclass
class PlayerAchievementEntry:
    def __init__(self, *, player_address:FieldElement, stats:PlayerAchievementStats, achievements:typing.List[PlayerAchievementProgress]):
        self.player_address = player_address
        self.stats = stats
        self.achievements = achievements
        
        

    
    def __str__(self):
        return "PlayerAchievementEntry(player_address={}, stats={}, achievements={})".format(self.player_address, self.stats, self.achievements)
    def __eq__(self, other):
        if self.player_address != other.player_address:
            return False
        if self.stats != other.stats:
            return False
        if self.achievements != other.achievements:
            return False
        return True

class _UniffiFfiConverterTypePlayerAchievementEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlayerAchievementEntry(
            player_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            stats=_UniffiFfiConverterTypePlayerAchievementStats.read(buf),
            achievements=_UniffiFfiConverterSequenceTypePlayerAchievementProgress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.player_address)
        _UniffiFfiConverterTypePlayerAchievementStats.check_lower(value.stats)
        _UniffiFfiConverterSequenceTypePlayerAchievementProgress.check_lower(value.achievements)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.player_address, buf)
        _UniffiFfiConverterTypePlayerAchievementStats.write(value.stats, buf)
        _UniffiFfiConverterSequenceTypePlayerAchievementProgress.write(value.achievements, buf)

@dataclass
class PlayerAchievementQuery:
    def __init__(self, *, world_addresses:typing.List[FieldElement], namespaces:typing.List[str], player_addresses:typing.List[FieldElement], pagination:Pagination):
        self.world_addresses = world_addresses
        self.namespaces = namespaces
        self.player_addresses = player_addresses
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "PlayerAchievementQuery(world_addresses={}, namespaces={}, player_addresses={}, pagination={})".format(self.world_addresses, self.namespaces, self.player_addresses, self.pagination)
    def __eq__(self, other):
        if self.world_addresses != other.world_addresses:
            return False
        if self.namespaces != other.namespaces:
            return False
        if self.player_addresses != other.player_addresses:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypePlayerAchievementQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlayerAchievementQuery(
            world_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            namespaces=_UniffiFfiConverterSequenceString.read(buf),
            player_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.world_addresses)
        _UniffiFfiConverterSequenceString.check_lower(value.namespaces)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.player_addresses)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.world_addresses, buf)
        _UniffiFfiConverterSequenceString.write(value.namespaces, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.player_addresses, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)

@dataclass
class Signature:
    def __init__(self, *, r:FieldElement, s:FieldElement):
        self.r = r
        self.s = s
        
        

    
    def __str__(self):
        return "Signature(r={}, s={})".format(self.r, self.s)
    def __eq__(self, other):
        if self.r != other.r:
            return False
        if self.s != other.s:
            return False
        return True

class _UniffiFfiConverterTypeSignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Signature(
            r=_UniffiFfiConverterTypeFieldElement.read(buf),
            s=_UniffiFfiConverterTypeFieldElement.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.r)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.s)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.r, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.s, buf)

class _UniffiFfiConverterOptionalTypeU256(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeU256.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeU256.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeU256.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Token:
    def __init__(self, *, contract_address:FieldElement, token_id:typing.Optional[U256], name:str, symbol:str, decimals:int, metadata:str, total_supply:typing.Optional[U256]):
        self.contract_address = contract_address
        self.token_id = token_id
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.metadata = metadata
        self.total_supply = total_supply
        
        

    
    def __str__(self):
        return "Token(contract_address={}, token_id={}, name={}, symbol={}, decimals={}, metadata={}, total_supply={})".format(self.contract_address, self.token_id, self.name, self.symbol, self.decimals, self.metadata, self.total_supply)
    def __eq__(self, other):
        if self.contract_address != other.contract_address:
            return False
        if self.token_id != other.token_id:
            return False
        if self.name != other.name:
            return False
        if self.symbol != other.symbol:
            return False
        if self.decimals != other.decimals:
            return False
        if self.metadata != other.metadata:
            return False
        if self.total_supply != other.total_supply:
            return False
        return True

class _UniffiFfiConverterTypeToken(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Token(
            contract_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            token_id=_UniffiFfiConverterOptionalTypeU256.read(buf),
            name=_UniffiFfiConverterString.read(buf),
            symbol=_UniffiFfiConverterString.read(buf),
            decimals=_UniffiFfiConverterUInt8.read(buf),
            metadata=_UniffiFfiConverterString.read(buf),
            total_supply=_UniffiFfiConverterOptionalTypeU256.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.contract_address)
        _UniffiFfiConverterOptionalTypeU256.check_lower(value.token_id)
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterString.check_lower(value.symbol)
        _UniffiFfiConverterUInt8.check_lower(value.decimals)
        _UniffiFfiConverterString.check_lower(value.metadata)
        _UniffiFfiConverterOptionalTypeU256.check_lower(value.total_supply)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.contract_address, buf)
        _UniffiFfiConverterOptionalTypeU256.write(value.token_id, buf)
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterString.write(value.symbol, buf)
        _UniffiFfiConverterUInt8.write(value.decimals, buf)
        _UniffiFfiConverterString.write(value.metadata, buf)
        _UniffiFfiConverterOptionalTypeU256.write(value.total_supply, buf)

@dataclass
class TokenBalance:
    def __init__(self, *, balance:U256, account_address:FieldElement, contract_address:FieldElement, token_id:typing.Optional[U256]):
        self.balance = balance
        self.account_address = account_address
        self.contract_address = contract_address
        self.token_id = token_id
        
        

    
    def __str__(self):
        return "TokenBalance(balance={}, account_address={}, contract_address={}, token_id={})".format(self.balance, self.account_address, self.contract_address, self.token_id)
    def __eq__(self, other):
        if self.balance != other.balance:
            return False
        if self.account_address != other.account_address:
            return False
        if self.contract_address != other.contract_address:
            return False
        if self.token_id != other.token_id:
            return False
        return True

class _UniffiFfiConverterTypeTokenBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenBalance(
            balance=_UniffiFfiConverterTypeU256.read(buf),
            account_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            contract_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            token_id=_UniffiFfiConverterOptionalTypeU256.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeU256.check_lower(value.balance)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.account_address)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.contract_address)
        _UniffiFfiConverterOptionalTypeU256.check_lower(value.token_id)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeU256.write(value.balance, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.account_address, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.contract_address, buf)
        _UniffiFfiConverterOptionalTypeU256.write(value.token_id, buf)

class _UniffiFfiConverterSequenceTypeU256(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeU256.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeU256.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeU256.read(buf) for i in range(count)
        ]

@dataclass
class TokenBalanceQuery:
    def __init__(self, *, contract_addresses:typing.List[FieldElement], account_addresses:typing.List[FieldElement], token_ids:typing.List[U256], pagination:Pagination):
        self.contract_addresses = contract_addresses
        self.account_addresses = account_addresses
        self.token_ids = token_ids
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "TokenBalanceQuery(contract_addresses={}, account_addresses={}, token_ids={}, pagination={})".format(self.contract_addresses, self.account_addresses, self.token_ids, self.pagination)
    def __eq__(self, other):
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.account_addresses != other.account_addresses:
            return False
        if self.token_ids != other.token_ids:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeTokenBalanceQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenBalanceQuery(
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            account_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            token_ids=_UniffiFfiConverterSequenceTypeU256.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.account_addresses)
        _UniffiFfiConverterSequenceTypeU256.check_lower(value.token_ids)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.account_addresses, buf)
        _UniffiFfiConverterSequenceTypeU256.write(value.token_ids, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)

@dataclass
class TokenContract:
    def __init__(self, *, contract_address:FieldElement, name:str, symbol:str, decimals:int, metadata:str, token_metadata:str, total_supply:typing.Optional[U256]):
        self.contract_address = contract_address
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.metadata = metadata
        self.token_metadata = token_metadata
        self.total_supply = total_supply
        
        

    
    def __str__(self):
        return "TokenContract(contract_address={}, name={}, symbol={}, decimals={}, metadata={}, token_metadata={}, total_supply={})".format(self.contract_address, self.name, self.symbol, self.decimals, self.metadata, self.token_metadata, self.total_supply)
    def __eq__(self, other):
        if self.contract_address != other.contract_address:
            return False
        if self.name != other.name:
            return False
        if self.symbol != other.symbol:
            return False
        if self.decimals != other.decimals:
            return False
        if self.metadata != other.metadata:
            return False
        if self.token_metadata != other.token_metadata:
            return False
        if self.total_supply != other.total_supply:
            return False
        return True

class _UniffiFfiConverterTypeTokenContract(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenContract(
            contract_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            name=_UniffiFfiConverterString.read(buf),
            symbol=_UniffiFfiConverterString.read(buf),
            decimals=_UniffiFfiConverterUInt8.read(buf),
            metadata=_UniffiFfiConverterString.read(buf),
            token_metadata=_UniffiFfiConverterString.read(buf),
            total_supply=_UniffiFfiConverterOptionalTypeU256.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.contract_address)
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterString.check_lower(value.symbol)
        _UniffiFfiConverterUInt8.check_lower(value.decimals)
        _UniffiFfiConverterString.check_lower(value.metadata)
        _UniffiFfiConverterString.check_lower(value.token_metadata)
        _UniffiFfiConverterOptionalTypeU256.check_lower(value.total_supply)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.contract_address, buf)
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterString.write(value.symbol, buf)
        _UniffiFfiConverterUInt8.write(value.decimals, buf)
        _UniffiFfiConverterString.write(value.metadata, buf)
        _UniffiFfiConverterString.write(value.token_metadata, buf)
        _UniffiFfiConverterOptionalTypeU256.write(value.total_supply, buf)

@dataclass
class TokenContractQuery:
    def __init__(self, *, contract_addresses:typing.List[FieldElement], contract_types:typing.List[ContractType], pagination:Pagination):
        self.contract_addresses = contract_addresses
        self.contract_types = contract_types
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "TokenContractQuery(contract_addresses={}, contract_types={}, pagination={})".format(self.contract_addresses, self.contract_types, self.pagination)
    def __eq__(self, other):
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.contract_types != other.contract_types:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeTokenContractQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenContractQuery(
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            contract_types=_UniffiFfiConverterSequenceTypeContractType.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceTypeContractType.check_lower(value.contract_types)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceTypeContractType.write(value.contract_types, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)

class _UniffiFfiConverterSequenceTypeAttributeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeAttributeFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeAttributeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeAttributeFilter.read(buf) for i in range(count)
        ]

@dataclass
class TokenQuery:
    def __init__(self, *, contract_addresses:typing.List[FieldElement], token_ids:typing.List[U256], attribute_filters:typing.List[AttributeFilter], pagination:Pagination):
        self.contract_addresses = contract_addresses
        self.token_ids = token_ids
        self.attribute_filters = attribute_filters
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "TokenQuery(contract_addresses={}, token_ids={}, attribute_filters={}, pagination={})".format(self.contract_addresses, self.token_ids, self.attribute_filters, self.pagination)
    def __eq__(self, other):
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.token_ids != other.token_ids:
            return False
        if self.attribute_filters != other.attribute_filters:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeTokenQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenQuery(
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            token_ids=_UniffiFfiConverterSequenceTypeU256.read(buf),
            attribute_filters=_UniffiFfiConverterSequenceTypeAttributeFilter.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceTypeU256.check_lower(value.token_ids)
        _UniffiFfiConverterSequenceTypeAttributeFilter.check_lower(value.attribute_filters)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceTypeU256.write(value.token_ids, buf)
        _UniffiFfiConverterSequenceTypeAttributeFilter.write(value.attribute_filters, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)

@dataclass
class TokenTransfer:
    def __init__(self, *, id:str, contract_address:FieldElement, from_address:FieldElement, to_address:FieldElement, amount:U256, token_id:typing.Optional[U256], executed_at:int, event_id:typing.Optional[str]):
        self.id = id
        self.contract_address = contract_address
        self.from_address = from_address
        self.to_address = to_address
        self.amount = amount
        self.token_id = token_id
        self.executed_at = executed_at
        self.event_id = event_id
        
        

    
    def __str__(self):
        return "TokenTransfer(id={}, contract_address={}, from_address={}, to_address={}, amount={}, token_id={}, executed_at={}, event_id={})".format(self.id, self.contract_address, self.from_address, self.to_address, self.amount, self.token_id, self.executed_at, self.event_id)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.contract_address != other.contract_address:
            return False
        if self.from_address != other.from_address:
            return False
        if self.to_address != other.to_address:
            return False
        if self.amount != other.amount:
            return False
        if self.token_id != other.token_id:
            return False
        if self.executed_at != other.executed_at:
            return False
        if self.event_id != other.event_id:
            return False
        return True

class _UniffiFfiConverterTypeTokenTransfer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenTransfer(
            id=_UniffiFfiConverterString.read(buf),
            contract_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            from_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            to_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            amount=_UniffiFfiConverterTypeU256.read(buf),
            token_id=_UniffiFfiConverterOptionalTypeU256.read(buf),
            executed_at=_UniffiFfiConverterUInt64.read(buf),
            event_id=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.contract_address)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.from_address)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.to_address)
        _UniffiFfiConverterTypeU256.check_lower(value.amount)
        _UniffiFfiConverterOptionalTypeU256.check_lower(value.token_id)
        _UniffiFfiConverterUInt64.check_lower(value.executed_at)
        _UniffiFfiConverterOptionalString.check_lower(value.event_id)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.contract_address, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.from_address, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.to_address, buf)
        _UniffiFfiConverterTypeU256.write(value.amount, buf)
        _UniffiFfiConverterOptionalTypeU256.write(value.token_id, buf)
        _UniffiFfiConverterUInt64.write(value.executed_at, buf)
        _UniffiFfiConverterOptionalString.write(value.event_id, buf)

@dataclass
class TokenTransferQuery:
    def __init__(self, *, contract_addresses:typing.List[FieldElement], account_addresses:typing.List[FieldElement], token_ids:typing.List[U256], pagination:Pagination):
        self.contract_addresses = contract_addresses
        self.account_addresses = account_addresses
        self.token_ids = token_ids
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "TokenTransferQuery(contract_addresses={}, account_addresses={}, token_ids={}, pagination={})".format(self.contract_addresses, self.account_addresses, self.token_ids, self.pagination)
    def __eq__(self, other):
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.account_addresses != other.account_addresses:
            return False
        if self.token_ids != other.token_ids:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeTokenTransferQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenTransferQuery(
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            account_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            token_ids=_UniffiFfiConverterSequenceTypeU256.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.account_addresses)
        _UniffiFfiConverterSequenceTypeU256.check_lower(value.token_ids)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.account_addresses, buf)
        _UniffiFfiConverterSequenceTypeU256.write(value.token_ids, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)






class CallType(enum.Enum):
    
    EXECUTE = 0
    
    EXECUTE_FROM_OUTSIDE = 1
    


class _UniffiFfiConverterTypeCallType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CallType.EXECUTE
        if variant == 2:
            return CallType.EXECUTE_FROM_OUTSIDE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == CallType.EXECUTE:
            return
        if value == CallType.EXECUTE_FROM_OUTSIDE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == CallType.EXECUTE:
            buf.write_i32(1)
        if value == CallType.EXECUTE_FROM_OUTSIDE:
            buf.write_i32(2)



@dataclass
class TransactionCall:
    def __init__(self, *, contract_address:FieldElement, entrypoint:str, calldata:typing.List[FieldElement], call_type:CallType, caller_address:FieldElement):
        self.contract_address = contract_address
        self.entrypoint = entrypoint
        self.calldata = calldata
        self.call_type = call_type
        self.caller_address = caller_address
        
        

    
    def __str__(self):
        return "TransactionCall(contract_address={}, entrypoint={}, calldata={}, call_type={}, caller_address={})".format(self.contract_address, self.entrypoint, self.calldata, self.call_type, self.caller_address)
    def __eq__(self, other):
        if self.contract_address != other.contract_address:
            return False
        if self.entrypoint != other.entrypoint:
            return False
        if self.calldata != other.calldata:
            return False
        if self.call_type != other.call_type:
            return False
        if self.caller_address != other.caller_address:
            return False
        return True

class _UniffiFfiConverterTypeTransactionCall(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionCall(
            contract_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            entrypoint=_UniffiFfiConverterString.read(buf),
            calldata=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            call_type=_UniffiFfiConverterTypeCallType.read(buf),
            caller_address=_UniffiFfiConverterTypeFieldElement.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.contract_address)
        _UniffiFfiConverterString.check_lower(value.entrypoint)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.calldata)
        _UniffiFfiConverterTypeCallType.check_lower(value.call_type)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.caller_address)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.contract_address, buf)
        _UniffiFfiConverterString.write(value.entrypoint, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.calldata, buf)
        _UniffiFfiConverterTypeCallType.write(value.call_type, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.caller_address, buf)

class _UniffiFfiConverterSequenceTypeTransactionCall(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeTransactionCall.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeTransactionCall.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeTransactionCall.read(buf) for i in range(count)
        ]

@dataclass
class Transaction:
    def __init__(self, *, transaction_hash:FieldElement, sender_address:FieldElement, calldata:typing.List[FieldElement], max_fee:FieldElement, signature:typing.List[FieldElement], nonce:FieldElement, block_number:int, transaction_type:str, block_timestamp:int, calls:typing.List[TransactionCall], unique_models:typing.List[FieldElement]):
        self.transaction_hash = transaction_hash
        self.sender_address = sender_address
        self.calldata = calldata
        self.max_fee = max_fee
        self.signature = signature
        self.nonce = nonce
        self.block_number = block_number
        self.transaction_type = transaction_type
        self.block_timestamp = block_timestamp
        self.calls = calls
        self.unique_models = unique_models
        
        

    
    def __str__(self):
        return "Transaction(transaction_hash={}, sender_address={}, calldata={}, max_fee={}, signature={}, nonce={}, block_number={}, transaction_type={}, block_timestamp={}, calls={}, unique_models={})".format(self.transaction_hash, self.sender_address, self.calldata, self.max_fee, self.signature, self.nonce, self.block_number, self.transaction_type, self.block_timestamp, self.calls, self.unique_models)
    def __eq__(self, other):
        if self.transaction_hash != other.transaction_hash:
            return False
        if self.sender_address != other.sender_address:
            return False
        if self.calldata != other.calldata:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.signature != other.signature:
            return False
        if self.nonce != other.nonce:
            return False
        if self.block_number != other.block_number:
            return False
        if self.transaction_type != other.transaction_type:
            return False
        if self.block_timestamp != other.block_timestamp:
            return False
        if self.calls != other.calls:
            return False
        if self.unique_models != other.unique_models:
            return False
        return True

class _UniffiFfiConverterTypeTransaction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Transaction(
            transaction_hash=_UniffiFfiConverterTypeFieldElement.read(buf),
            sender_address=_UniffiFfiConverterTypeFieldElement.read(buf),
            calldata=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            max_fee=_UniffiFfiConverterTypeFieldElement.read(buf),
            signature=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            nonce=_UniffiFfiConverterTypeFieldElement.read(buf),
            block_number=_UniffiFfiConverterUInt64.read(buf),
            transaction_type=_UniffiFfiConverterString.read(buf),
            block_timestamp=_UniffiFfiConverterUInt64.read(buf),
            calls=_UniffiFfiConverterSequenceTypeTransactionCall.read(buf),
            unique_models=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFieldElement.check_lower(value.transaction_hash)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.sender_address)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.calldata)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.max_fee)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.signature)
        _UniffiFfiConverterTypeFieldElement.check_lower(value.nonce)
        _UniffiFfiConverterUInt64.check_lower(value.block_number)
        _UniffiFfiConverterString.check_lower(value.transaction_type)
        _UniffiFfiConverterUInt64.check_lower(value.block_timestamp)
        _UniffiFfiConverterSequenceTypeTransactionCall.check_lower(value.calls)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.unique_models)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFieldElement.write(value.transaction_hash, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.sender_address, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.calldata, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.max_fee, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.signature, buf)
        _UniffiFfiConverterTypeFieldElement.write(value.nonce, buf)
        _UniffiFfiConverterUInt64.write(value.block_number, buf)
        _UniffiFfiConverterString.write(value.transaction_type, buf)
        _UniffiFfiConverterUInt64.write(value.block_timestamp, buf)
        _UniffiFfiConverterSequenceTypeTransactionCall.write(value.calls, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.unique_models, buf)

@dataclass
class TransactionFilter:
    def __init__(self, *, transaction_hashes:typing.List[FieldElement], caller_addresses:typing.List[FieldElement], contract_addresses:typing.List[FieldElement], entrypoints:typing.List[str], model_selectors:typing.List[FieldElement], from_block:typing.Optional[int], to_block:typing.Optional[int]):
        self.transaction_hashes = transaction_hashes
        self.caller_addresses = caller_addresses
        self.contract_addresses = contract_addresses
        self.entrypoints = entrypoints
        self.model_selectors = model_selectors
        self.from_block = from_block
        self.to_block = to_block
        
        

    
    def __str__(self):
        return "TransactionFilter(transaction_hashes={}, caller_addresses={}, contract_addresses={}, entrypoints={}, model_selectors={}, from_block={}, to_block={})".format(self.transaction_hashes, self.caller_addresses, self.contract_addresses, self.entrypoints, self.model_selectors, self.from_block, self.to_block)
    def __eq__(self, other):
        if self.transaction_hashes != other.transaction_hashes:
            return False
        if self.caller_addresses != other.caller_addresses:
            return False
        if self.contract_addresses != other.contract_addresses:
            return False
        if self.entrypoints != other.entrypoints:
            return False
        if self.model_selectors != other.model_selectors:
            return False
        if self.from_block != other.from_block:
            return False
        if self.to_block != other.to_block:
            return False
        return True

class _UniffiFfiConverterTypeTransactionFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionFilter(
            transaction_hashes=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            caller_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            contract_addresses=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            entrypoints=_UniffiFfiConverterSequenceString.read(buf),
            model_selectors=_UniffiFfiConverterSequenceTypeFieldElement.read(buf),
            from_block=_UniffiFfiConverterOptionalUInt64.read(buf),
            to_block=_UniffiFfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.transaction_hashes)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.caller_addresses)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.contract_addresses)
        _UniffiFfiConverterSequenceString.check_lower(value.entrypoints)
        _UniffiFfiConverterSequenceTypeFieldElement.check_lower(value.model_selectors)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.from_block)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.to_block)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.transaction_hashes, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.caller_addresses, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.contract_addresses, buf)
        _UniffiFfiConverterSequenceString.write(value.entrypoints, buf)
        _UniffiFfiConverterSequenceTypeFieldElement.write(value.model_selectors, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.from_block, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.to_block, buf)

class _UniffiFfiConverterOptionalTypeTransactionFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeTransactionFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeTransactionFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeTransactionFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class TransactionQuery:
    def __init__(self, *, filter:typing.Optional[TransactionFilter], pagination:Pagination):
        self.filter = filter
        self.pagination = pagination
        
        

    
    def __str__(self):
        return "TransactionQuery(filter={}, pagination={})".format(self.filter, self.pagination)
    def __eq__(self, other):
        if self.filter != other.filter:
            return False
        if self.pagination != other.pagination:
            return False
        return True

class _UniffiFfiConverterTypeTransactionQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionQuery(
            filter=_UniffiFfiConverterOptionalTypeTransactionFilter.read(buf),
            pagination=_UniffiFfiConverterTypePagination.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalTypeTransactionFilter.check_lower(value.filter)
        _UniffiFfiConverterTypePagination.check_lower(value.pagination)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalTypeTransactionFilter.write(value.filter, buf)
        _UniffiFfiConverterTypePagination.write(value.pagination, buf)



# DojoError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DojoError(Exception):
    pass

_UniffiTempDojoError = DojoError

class DojoError:  # type: ignore
    
    class ClientError(_UniffiTempDojoError):
        def __repr__(self):
            return "DojoError.ClientError({})".format(repr(str(self)))
    _UniffiTempDojoError.ClientError = ClientError # type: ignore
    class SerializationError(_UniffiTempDojoError):
        def __repr__(self):
            return "DojoError.SerializationError({})".format(repr(str(self)))
    _UniffiTempDojoError.SerializationError = SerializationError # type: ignore
    class NetworkError(_UniffiTempDojoError):
        def __repr__(self):
            return "DojoError.NetworkError({})".format(repr(str(self)))
    _UniffiTempDojoError.NetworkError = NetworkError # type: ignore
    class InvalidInput(_UniffiTempDojoError):
        def __repr__(self):
            return "DojoError.InvalidInput({})".format(repr(str(self)))
    _UniffiTempDojoError.InvalidInput = InvalidInput # type: ignore

DojoError = _UniffiTempDojoError # type: ignore
del _UniffiTempDojoError


class _UniffiFfiConverterTypeDojoError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DojoError.ClientError(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return DojoError.SerializationError(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return DojoError.NetworkError(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 4:
            return DojoError.InvalidInput(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DojoError.ClientError):
            return
        if isinstance(value, DojoError.SerializationError):
            return
        if isinstance(value, DojoError.NetworkError):
            return
        if isinstance(value, DojoError.InvalidInput):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DojoError.ClientError):
            buf.write_i32(1)
        if isinstance(value, DojoError.SerializationError):
            buf.write_i32(2)
        if isinstance(value, DojoError.NetworkError):
            buf.write_i32(3)
        if isinstance(value, DojoError.InvalidInput):
            buf.write_i32(4)






class ValueType:
    def __init__(self):
        raise RuntimeError("ValueType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class STRING:
        
        def __init__(self, value:str):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "ValueType.STRING(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_STRING():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class INT:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "ValueType.INT(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_INT():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class U_INT:
        
        def __init__(self, value:int):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "ValueType.U_INT(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_U_INT():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class BOOL:
        
        def __init__(self, value:bool):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "ValueType.BOOL(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_BOOL():
                return False
            if self.value != other.value:
                return False
            return True

    @dataclass
    class BYTES:
        
        def __init__(self, value:typing.List[int]):
            self.value = value
            
            
            pass

    
            
            
    
        def __str__(self):
            return "ValueType.BYTES(value={})".format(self.value)
        def __eq__(self, other):
            if not other.is_BYTES():
                return False
            if self.value != other.value:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_STRING(self) -> bool:
        return isinstance(self, ValueType.STRING)
    def is_string(self) -> bool:
        return isinstance(self, ValueType.STRING)
    def is_INT(self) -> bool:
        return isinstance(self, ValueType.INT)
    def is_int(self) -> bool:
        return isinstance(self, ValueType.INT)
    def is_U_INT(self) -> bool:
        return isinstance(self, ValueType.U_INT)
    def is_u_int(self) -> bool:
        return isinstance(self, ValueType.U_INT)
    def is_BOOL(self) -> bool:
        return isinstance(self, ValueType.BOOL)
    def is_bool(self) -> bool:
        return isinstance(self, ValueType.BOOL)
    def is_BYTES(self) -> bool:
        return isinstance(self, ValueType.BYTES)
    def is_bytes(self) -> bool:
        return isinstance(self, ValueType.BYTES)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ValueType.STRING = type("ValueType.STRING", (ValueType.STRING, ValueType,), {})  # type: ignore
ValueType.INT = type("ValueType.INT", (ValueType.INT, ValueType,), {})  # type: ignore
ValueType.U_INT = type("ValueType.U_INT", (ValueType.U_INT, ValueType,), {})  # type: ignore
ValueType.BOOL = type("ValueType.BOOL", (ValueType.BOOL, ValueType,), {})  # type: ignore
ValueType.BYTES = type("ValueType.BYTES", (ValueType.BYTES, ValueType,), {})  # type: ignore




class _UniffiFfiConverterTypeValueType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ValueType.STRING(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return ValueType.INT(
                _UniffiFfiConverterInt64.read(buf),
            )
        if variant == 3:
            return ValueType.U_INT(
                _UniffiFfiConverterUInt64.read(buf),
            )
        if variant == 4:
            return ValueType.BOOL(
                _UniffiFfiConverterBoolean.read(buf),
            )
        if variant == 5:
            return ValueType.BYTES(
                _UniffiFfiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_STRING():
            _UniffiFfiConverterString.check_lower(value.value)
            return
        if value.is_INT():
            _UniffiFfiConverterInt64.check_lower(value.value)
            return
        if value.is_U_INT():
            _UniffiFfiConverterUInt64.check_lower(value.value)
            return
        if value.is_BOOL():
            _UniffiFfiConverterBoolean.check_lower(value.value)
            return
        if value.is_BYTES():
            _UniffiFfiConverterSequenceUInt8.check_lower(value.value)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_STRING():
            buf.write_i32(1)
            _UniffiFfiConverterString.write(value.value, buf)
        if value.is_INT():
            buf.write_i32(2)
            _UniffiFfiConverterInt64.write(value.value, buf)
        if value.is_U_INT():
            buf.write_i32(3)
            _UniffiFfiConverterUInt64.write(value.value, buf)
        if value.is_BOOL():
            buf.write_i32(4)
            _UniffiFfiConverterBoolean.write(value.value, buf)
        if value.is_BYTES():
            buf.write_i32(5)
            _UniffiFfiConverterSequenceUInt8.write(value.value, buf)



__all__ = [
    "InternalError",
    "PaginationDirection",
    "OrderDirection",
    "LogicalOperator",
    "PatternMatching",
    "ComparisonOperator",
    "Primitive",
    "MemberValue",
    "Clause",
    "ContractType",
    "Ty",
    "CallType",
    "DojoError",
    "ValueType",
    "AchievementTask",
    "Achievement",
    "AchievementProgression",
    "OrderBy",
    "Pagination",
    "AchievementQuery",
    "ActionCount",
    "Activity",
    "ActivityQuery",
    "AggregationEntry",
    "AggregationQuery",
    "AttributeFilter",
    "KeysClause",
    "MemberClause",
    "CompositeClause",
    "Contract",
    "ContractQuery",
    "Controller",
    "ControllerQuery",
    "Member",
    "Struct",
    "EnumType",
    "FixedSizeArray",
    "EnumOption",
    "PlayerAchievementStats",
    "TaskProgress",
    "PlayerAchievementProgress",
    "PlayerAchievementEntry",
    "PlayerAchievementQuery",
    "Signature",
    "Token",
    "TokenBalance",
    "TokenBalanceQuery",
    "TokenContract",
    "TokenContractQuery",
    "TokenQuery",
    "TokenTransfer",
    "TokenTransferQuery",
    "TransactionCall",
    "Transaction",
    "TransactionFilter",
    "TransactionQuery",
]