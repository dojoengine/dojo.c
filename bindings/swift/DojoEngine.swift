// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(DojoEngineFFI)
import DojoEngineFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_dojo_c_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_dojo_c_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureDojoCInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt16: FfiConverterPrimitive {
    typealias FfiType = Int16
    typealias SwiftType = Int16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int16, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol ToriiClientProtocol: AnyObject, Sendable {
    
    func achievements(query: AchievementQuery) async throws  -> PageAchievement
    
    func activities(query: ActivityQuery) async throws  -> PageActivity
    
    func aggregations(query: AggregationQuery) async throws  -> PageAggregationEntry
    
    func contracts(query: ContractQuery) async throws  -> [Contract]
    
    func controllers(query: ControllerQuery) async throws  -> PageController
    
    func entities(query: Query) async throws  -> PageEntity
    
    func eventMessages(query: Query) async throws  -> PageEntity
    
    func playerAchievements(query: PlayerAchievementQuery) async throws  -> PagePlayerAchievement
    
    func publishMessage(message: Message) async throws  -> String
    
    func publishMessageBatch(messages: [Message]) async throws  -> [String]
    
    func sql(query: String) async throws  -> [SqlRow]
    
    func starknetEvents(query: EventQuery) async throws  -> PageEvent
    
    func tokenBalances(query: TokenBalanceQuery) async throws  -> PageTokenBalance
    
    func tokenContracts(query: TokenContractQuery) async throws  -> PageTokenContract
    
    func tokenTransfers(query: TokenTransferQuery) async throws  -> PageTokenTransfer
    
    func tokens(query: TokenQuery) async throws  -> PageToken
    
    func transactions(query: TransactionQuery) async throws  -> PageTransaction
    
    func worlds(worldAddresses: [FieldElement]) async throws  -> [World]
    
}
open class ToriiClient: ToriiClientProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_dojo_c_fn_clone_toriiclient(self.handle, $0) }
    }
public convenience init(toriiUrl: String)async throws  {
    let handle =
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_constructor_toriiclient_new(FfiConverterString.lower(toriiUrl)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_u64,
            completeFunc: ffi_dojo_c_rust_future_complete_u64,
            freeFunc: ffi_dojo_c_rust_future_free_u64,
            liftFunc: FfiConverterTypeToriiClient_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
        
        .uniffiCloneHandle()
    self.init(unsafeFromHandle: handle)
}

    deinit {
        try! rustCall { uniffi_dojo_c_fn_free_toriiclient(handle, $0) }
    }

    
public static func newWithConfig(toriiUrl: String, maxMessageSize: UInt64)async throws  -> ToriiClient  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_constructor_toriiclient_new_with_config(FfiConverterString.lower(toriiUrl),FfiConverterUInt64.lower(maxMessageSize)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_u64,
            completeFunc: ffi_dojo_c_rust_future_complete_u64,
            freeFunc: ffi_dojo_c_rust_future_free_u64,
            liftFunc: FfiConverterTypeToriiClient_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    

    
open func achievements(query: AchievementQuery)async throws  -> PageAchievement  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_achievements(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeAchievementQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageAchievement_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func activities(query: ActivityQuery)async throws  -> PageActivity  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_activities(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeActivityQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageActivity_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func aggregations(query: AggregationQuery)async throws  -> PageAggregationEntry  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_aggregations(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeAggregationQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageAggregationEntry_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func contracts(query: ContractQuery)async throws  -> [Contract]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_contracts(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeContractQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeContract.lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func controllers(query: ControllerQuery)async throws  -> PageController  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_controllers(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeControllerQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageController_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func entities(query: Query)async throws  -> PageEntity  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_entities(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageEntity_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func eventMessages(query: Query)async throws  -> PageEntity  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_event_messages(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageEntity_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func playerAchievements(query: PlayerAchievementQuery)async throws  -> PagePlayerAchievement  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_player_achievements(
                    self.uniffiCloneHandle(),
                    FfiConverterTypePlayerAchievementQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePagePlayerAchievement_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func publishMessage(message: Message)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_publish_message(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeMessage_lower(message)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func publishMessageBatch(messages: [Message])async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_publish_message_batch(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceTypeMessage.lower(messages)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func sql(query: String)async throws  -> [SqlRow]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_sql(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSqlRow.lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func starknetEvents(query: EventQuery)async throws  -> PageEvent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_starknet_events(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeEventQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageEvent_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func tokenBalances(query: TokenBalanceQuery)async throws  -> PageTokenBalance  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_token_balances(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTokenBalanceQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageTokenBalance_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func tokenContracts(query: TokenContractQuery)async throws  -> PageTokenContract  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_token_contracts(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTokenContractQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageTokenContract_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func tokenTransfers(query: TokenTransferQuery)async throws  -> PageTokenTransfer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_token_transfers(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTokenTransferQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageTokenTransfer_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func tokens(query: TokenQuery)async throws  -> PageToken  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_tokens(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTokenQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageToken_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func transactions(query: TransactionQuery)async throws  -> PageTransaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_transactions(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTransactionQuery_lower(query)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePageTransaction_lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    
open func worlds(worldAddresses: [FieldElement])async throws  -> [World]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_dojo_c_fn_method_toriiclient_worlds(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceTypeFieldElement.lower(worldAddresses)
                )
            },
            pollFunc: ffi_dojo_c_rust_future_poll_rust_buffer,
            completeFunc: ffi_dojo_c_rust_future_complete_rust_buffer,
            freeFunc: ffi_dojo_c_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeWorld.lift,
            errorHandler: FfiConverterTypeDojoError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeToriiClient: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ToriiClient

    public static func lift(_ handle: UInt64) throws -> ToriiClient {
        return ToriiClient(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ToriiClient) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ToriiClient {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ToriiClient, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToriiClient_lift(_ handle: UInt64) throws -> ToriiClient {
    return try FfiConverterTypeToriiClient.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToriiClient_lower(_ value: ToriiClient) -> UInt64 {
    return FfiConverterTypeToriiClient.lower(value)
}




public struct Achievement: Equatable, Hashable {
    public let id: String
    public let worldAddress: FieldElement
    public let namespace: String
    public let entityId: String
    public let hidden: Bool
    public let index: UInt32
    public let points: UInt32
    public let start: String
    public let end: String
    public let group: String
    public let icon: String
    public let title: String
    public let description: String
    public let tasks: [AchievementTask]
    public let data: String?
    public let totalCompletions: UInt32
    public let completionRate: Double
    public let createdAt: UInt64
    public let updatedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, worldAddress: FieldElement, namespace: String, entityId: String, hidden: Bool, index: UInt32, points: UInt32, start: String, end: String, group: String, icon: String, title: String, description: String, tasks: [AchievementTask], data: String?, totalCompletions: UInt32, completionRate: Double, createdAt: UInt64, updatedAt: UInt64) {
        self.id = id
        self.worldAddress = worldAddress
        self.namespace = namespace
        self.entityId = entityId
        self.hidden = hidden
        self.index = index
        self.points = points
        self.start = start
        self.end = end
        self.group = group
        self.icon = icon
        self.title = title
        self.description = description
        self.tasks = tasks
        self.data = data
        self.totalCompletions = totalCompletions
        self.completionRate = completionRate
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    
}

#if compiler(>=6)
extension Achievement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAchievement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Achievement {
        return
            try Achievement(
                id: FfiConverterString.read(from: &buf), 
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                namespace: FfiConverterString.read(from: &buf), 
                entityId: FfiConverterString.read(from: &buf), 
                hidden: FfiConverterBool.read(from: &buf), 
                index: FfiConverterUInt32.read(from: &buf), 
                points: FfiConverterUInt32.read(from: &buf), 
                start: FfiConverterString.read(from: &buf), 
                end: FfiConverterString.read(from: &buf), 
                group: FfiConverterString.read(from: &buf), 
                icon: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                tasks: FfiConverterSequenceTypeAchievementTask.read(from: &buf), 
                data: FfiConverterOptionString.read(from: &buf), 
                totalCompletions: FfiConverterUInt32.read(from: &buf), 
                completionRate: FfiConverterDouble.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Achievement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
        FfiConverterString.write(value.namespace, into: &buf)
        FfiConverterString.write(value.entityId, into: &buf)
        FfiConverterBool.write(value.hidden, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterUInt32.write(value.points, into: &buf)
        FfiConverterString.write(value.start, into: &buf)
        FfiConverterString.write(value.end, into: &buf)
        FfiConverterString.write(value.group, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterSequenceTypeAchievementTask.write(value.tasks, into: &buf)
        FfiConverterOptionString.write(value.data, into: &buf)
        FfiConverterUInt32.write(value.totalCompletions, into: &buf)
        FfiConverterDouble.write(value.completionRate, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievement_lift(_ buf: RustBuffer) throws -> Achievement {
    return try FfiConverterTypeAchievement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievement_lower(_ value: Achievement) -> RustBuffer {
    return FfiConverterTypeAchievement.lower(value)
}


public struct AchievementProgression: Equatable, Hashable {
    public let id: String
    public let achievementId: String
    public let taskId: String
    public let worldAddress: FieldElement
    public let namespace: String
    public let playerId: FieldElement
    public let count: UInt32
    public let completed: Bool
    public let completedAt: UInt64?
    public let createdAt: UInt64
    public let updatedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, achievementId: String, taskId: String, worldAddress: FieldElement, namespace: String, playerId: FieldElement, count: UInt32, completed: Bool, completedAt: UInt64?, createdAt: UInt64, updatedAt: UInt64) {
        self.id = id
        self.achievementId = achievementId
        self.taskId = taskId
        self.worldAddress = worldAddress
        self.namespace = namespace
        self.playerId = playerId
        self.count = count
        self.completed = completed
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    
}

#if compiler(>=6)
extension AchievementProgression: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAchievementProgression: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AchievementProgression {
        return
            try AchievementProgression(
                id: FfiConverterString.read(from: &buf), 
                achievementId: FfiConverterString.read(from: &buf), 
                taskId: FfiConverterString.read(from: &buf), 
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                namespace: FfiConverterString.read(from: &buf), 
                playerId: FfiConverterTypeFieldElement.read(from: &buf), 
                count: FfiConverterUInt32.read(from: &buf), 
                completed: FfiConverterBool.read(from: &buf), 
                completedAt: FfiConverterOptionUInt64.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AchievementProgression, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.achievementId, into: &buf)
        FfiConverterString.write(value.taskId, into: &buf)
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
        FfiConverterString.write(value.namespace, into: &buf)
        FfiConverterTypeFieldElement.write(value.playerId, into: &buf)
        FfiConverterUInt32.write(value.count, into: &buf)
        FfiConverterBool.write(value.completed, into: &buf)
        FfiConverterOptionUInt64.write(value.completedAt, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievementProgression_lift(_ buf: RustBuffer) throws -> AchievementProgression {
    return try FfiConverterTypeAchievementProgression.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievementProgression_lower(_ value: AchievementProgression) -> RustBuffer {
    return FfiConverterTypeAchievementProgression.lower(value)
}


public struct AchievementQuery: Equatable, Hashable {
    public let worldAddresses: [FieldElement]
    public let namespaces: [String]
    public let hidden: Bool?
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddresses: [FieldElement], namespaces: [String], hidden: Bool?, pagination: Pagination) {
        self.worldAddresses = worldAddresses
        self.namespaces = namespaces
        self.hidden = hidden
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension AchievementQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAchievementQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AchievementQuery {
        return
            try AchievementQuery(
                worldAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                namespaces: FfiConverterSequenceString.read(from: &buf), 
                hidden: FfiConverterOptionBool.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: AchievementQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.worldAddresses, into: &buf)
        FfiConverterSequenceString.write(value.namespaces, into: &buf)
        FfiConverterOptionBool.write(value.hidden, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievementQuery_lift(_ buf: RustBuffer) throws -> AchievementQuery {
    return try FfiConverterTypeAchievementQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievementQuery_lower(_ value: AchievementQuery) -> RustBuffer {
    return FfiConverterTypeAchievementQuery.lower(value)
}


public struct AchievementTask: Equatable, Hashable {
    public let taskId: String
    public let description: String
    public let total: UInt32
    public let totalCompletions: UInt32
    public let completionRate: Double
    public let createdAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(taskId: String, description: String, total: UInt32, totalCompletions: UInt32, completionRate: Double, createdAt: UInt64) {
        self.taskId = taskId
        self.description = description
        self.total = total
        self.totalCompletions = totalCompletions
        self.completionRate = completionRate
        self.createdAt = createdAt
    }

    
}

#if compiler(>=6)
extension AchievementTask: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAchievementTask: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AchievementTask {
        return
            try AchievementTask(
                taskId: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                total: FfiConverterUInt32.read(from: &buf), 
                totalCompletions: FfiConverterUInt32.read(from: &buf), 
                completionRate: FfiConverterDouble.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AchievementTask, into buf: inout [UInt8]) {
        FfiConverterString.write(value.taskId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterUInt32.write(value.total, into: &buf)
        FfiConverterUInt32.write(value.totalCompletions, into: &buf)
        FfiConverterDouble.write(value.completionRate, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievementTask_lift(_ buf: RustBuffer) throws -> AchievementTask {
    return try FfiConverterTypeAchievementTask.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAchievementTask_lower(_ value: AchievementTask) -> RustBuffer {
    return FfiConverterTypeAchievementTask.lower(value)
}


public struct ActionCount: Equatable, Hashable {
    public let actionName: String
    public let count: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(actionName: String, count: UInt32) {
        self.actionName = actionName
        self.count = count
    }

    
}

#if compiler(>=6)
extension ActionCount: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActionCount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActionCount {
        return
            try ActionCount(
                actionName: FfiConverterString.read(from: &buf), 
                count: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ActionCount, into buf: inout [UInt8]) {
        FfiConverterString.write(value.actionName, into: &buf)
        FfiConverterUInt32.write(value.count, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActionCount_lift(_ buf: RustBuffer) throws -> ActionCount {
    return try FfiConverterTypeActionCount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActionCount_lower(_ value: ActionCount) -> RustBuffer {
    return FfiConverterTypeActionCount.lower(value)
}


public struct Activity: Equatable, Hashable {
    public let id: String
    public let worldAddress: FieldElement
    public let namespace: String
    public let callerAddress: FieldElement
    public let sessionStart: UInt64
    public let sessionEnd: UInt64
    public let actionCount: UInt32
    public let actions: [ActionCount]
    public let updatedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, worldAddress: FieldElement, namespace: String, callerAddress: FieldElement, sessionStart: UInt64, sessionEnd: UInt64, actionCount: UInt32, actions: [ActionCount], updatedAt: UInt64) {
        self.id = id
        self.worldAddress = worldAddress
        self.namespace = namespace
        self.callerAddress = callerAddress
        self.sessionStart = sessionStart
        self.sessionEnd = sessionEnd
        self.actionCount = actionCount
        self.actions = actions
        self.updatedAt = updatedAt
    }

    
}

#if compiler(>=6)
extension Activity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActivity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Activity {
        return
            try Activity(
                id: FfiConverterString.read(from: &buf), 
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                namespace: FfiConverterString.read(from: &buf), 
                callerAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                sessionStart: FfiConverterUInt64.read(from: &buf), 
                sessionEnd: FfiConverterUInt64.read(from: &buf), 
                actionCount: FfiConverterUInt32.read(from: &buf), 
                actions: FfiConverterSequenceTypeActionCount.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Activity, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
        FfiConverterString.write(value.namespace, into: &buf)
        FfiConverterTypeFieldElement.write(value.callerAddress, into: &buf)
        FfiConverterUInt64.write(value.sessionStart, into: &buf)
        FfiConverterUInt64.write(value.sessionEnd, into: &buf)
        FfiConverterUInt32.write(value.actionCount, into: &buf)
        FfiConverterSequenceTypeActionCount.write(value.actions, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivity_lift(_ buf: RustBuffer) throws -> Activity {
    return try FfiConverterTypeActivity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivity_lower(_ value: Activity) -> RustBuffer {
    return FfiConverterTypeActivity.lower(value)
}


public struct ActivityQuery: Equatable, Hashable {
    public let worldAddresses: [FieldElement]
    public let namespaces: [String]
    public let callerAddresses: [FieldElement]
    public let fromTime: UInt64?
    public let toTime: UInt64?
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddresses: [FieldElement], namespaces: [String], callerAddresses: [FieldElement], fromTime: UInt64?, toTime: UInt64?, pagination: Pagination) {
        self.worldAddresses = worldAddresses
        self.namespaces = namespaces
        self.callerAddresses = callerAddresses
        self.fromTime = fromTime
        self.toTime = toTime
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension ActivityQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActivityQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActivityQuery {
        return
            try ActivityQuery(
                worldAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                namespaces: FfiConverterSequenceString.read(from: &buf), 
                callerAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                fromTime: FfiConverterOptionUInt64.read(from: &buf), 
                toTime: FfiConverterOptionUInt64.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: ActivityQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.worldAddresses, into: &buf)
        FfiConverterSequenceString.write(value.namespaces, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.callerAddresses, into: &buf)
        FfiConverterOptionUInt64.write(value.fromTime, into: &buf)
        FfiConverterOptionUInt64.write(value.toTime, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivityQuery_lift(_ buf: RustBuffer) throws -> ActivityQuery {
    return try FfiConverterTypeActivityQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivityQuery_lower(_ value: ActivityQuery) -> RustBuffer {
    return FfiConverterTypeActivityQuery.lower(value)
}


public struct AggregationEntry: Equatable, Hashable {
    public let id: String
    public let aggregatorId: String
    public let entityId: String
    public let value: U256
    public let displayValue: String
    public let position: UInt64
    public let modelId: String
    public let createdAt: UInt64
    public let updatedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, aggregatorId: String, entityId: String, value: U256, displayValue: String, position: UInt64, modelId: String, createdAt: UInt64, updatedAt: UInt64) {
        self.id = id
        self.aggregatorId = aggregatorId
        self.entityId = entityId
        self.value = value
        self.displayValue = displayValue
        self.position = position
        self.modelId = modelId
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    
}

#if compiler(>=6)
extension AggregationEntry: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAggregationEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AggregationEntry {
        return
            try AggregationEntry(
                id: FfiConverterString.read(from: &buf), 
                aggregatorId: FfiConverterString.read(from: &buf), 
                entityId: FfiConverterString.read(from: &buf), 
                value: FfiConverterTypeU256.read(from: &buf), 
                displayValue: FfiConverterString.read(from: &buf), 
                position: FfiConverterUInt64.read(from: &buf), 
                modelId: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AggregationEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.aggregatorId, into: &buf)
        FfiConverterString.write(value.entityId, into: &buf)
        FfiConverterTypeU256.write(value.value, into: &buf)
        FfiConverterString.write(value.displayValue, into: &buf)
        FfiConverterUInt64.write(value.position, into: &buf)
        FfiConverterString.write(value.modelId, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAggregationEntry_lift(_ buf: RustBuffer) throws -> AggregationEntry {
    return try FfiConverterTypeAggregationEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAggregationEntry_lower(_ value: AggregationEntry) -> RustBuffer {
    return FfiConverterTypeAggregationEntry.lower(value)
}


public struct AggregationQuery: Equatable, Hashable {
    public let aggregatorIds: [String]
    public let entityIds: [String]
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(aggregatorIds: [String], entityIds: [String], pagination: Pagination) {
        self.aggregatorIds = aggregatorIds
        self.entityIds = entityIds
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension AggregationQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAggregationQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AggregationQuery {
        return
            try AggregationQuery(
                aggregatorIds: FfiConverterSequenceString.read(from: &buf), 
                entityIds: FfiConverterSequenceString.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: AggregationQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.aggregatorIds, into: &buf)
        FfiConverterSequenceString.write(value.entityIds, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAggregationQuery_lift(_ buf: RustBuffer) throws -> AggregationQuery {
    return try FfiConverterTypeAggregationQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAggregationQuery_lower(_ value: AggregationQuery) -> RustBuffer {
    return FfiConverterTypeAggregationQuery.lower(value)
}


public struct AttributeFilter: Equatable, Hashable {
    public let traitName: String
    public let traitValue: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(traitName: String, traitValue: String) {
        self.traitName = traitName
        self.traitValue = traitValue
    }

    
}

#if compiler(>=6)
extension AttributeFilter: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeFilter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeFilter {
        return
            try AttributeFilter(
                traitName: FfiConverterString.read(from: &buf), 
                traitValue: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AttributeFilter, into buf: inout [UInt8]) {
        FfiConverterString.write(value.traitName, into: &buf)
        FfiConverterString.write(value.traitValue, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeFilter_lift(_ buf: RustBuffer) throws -> AttributeFilter {
    return try FfiConverterTypeAttributeFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeFilter_lower(_ value: AttributeFilter) -> RustBuffer {
    return FfiConverterTypeAttributeFilter.lower(value)
}


public struct CompositeClause: Equatable, Hashable {
    public let `operator`: LogicalOperator
    public let clauses: [Clause]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`operator`: LogicalOperator, clauses: [Clause]) {
        self.`operator` = `operator`
        self.clauses = clauses
    }

    
}

#if compiler(>=6)
extension CompositeClause: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompositeClause: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompositeClause {
        return
            try CompositeClause(
                operator: FfiConverterTypeLogicalOperator.read(from: &buf), 
                clauses: FfiConverterSequenceTypeClause.read(from: &buf)
        )
    }

    public static func write(_ value: CompositeClause, into buf: inout [UInt8]) {
        FfiConverterTypeLogicalOperator.write(value.`operator`, into: &buf)
        FfiConverterSequenceTypeClause.write(value.clauses, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompositeClause_lift(_ buf: RustBuffer) throws -> CompositeClause {
    return try FfiConverterTypeCompositeClause.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompositeClause_lower(_ value: CompositeClause) -> RustBuffer {
    return FfiConverterTypeCompositeClause.lower(value)
}


public struct Contract: Equatable, Hashable {
    public let contractAddress: FieldElement
    public let contractType: ContractType
    public let head: UInt64?
    public let tps: UInt64?
    public let lastBlockTimestamp: UInt64?
    public let lastPendingBlockTx: FieldElement?
    public let updatedAt: UInt64
    public let createdAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddress: FieldElement, contractType: ContractType, head: UInt64?, tps: UInt64?, lastBlockTimestamp: UInt64?, lastPendingBlockTx: FieldElement?, updatedAt: UInt64, createdAt: UInt64) {
        self.contractAddress = contractAddress
        self.contractType = contractType
        self.head = head
        self.tps = tps
        self.lastBlockTimestamp = lastBlockTimestamp
        self.lastPendingBlockTx = lastPendingBlockTx
        self.updatedAt = updatedAt
        self.createdAt = createdAt
    }

    
}

#if compiler(>=6)
extension Contract: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContract: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contract {
        return
            try Contract(
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                contractType: FfiConverterTypeContractType.read(from: &buf), 
                head: FfiConverterOptionUInt64.read(from: &buf), 
                tps: FfiConverterOptionUInt64.read(from: &buf), 
                lastBlockTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                lastPendingBlockTx: FfiConverterOptionTypeFieldElement.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Contract, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterTypeContractType.write(value.contractType, into: &buf)
        FfiConverterOptionUInt64.write(value.head, into: &buf)
        FfiConverterOptionUInt64.write(value.tps, into: &buf)
        FfiConverterOptionUInt64.write(value.lastBlockTimestamp, into: &buf)
        FfiConverterOptionTypeFieldElement.write(value.lastPendingBlockTx, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContract_lift(_ buf: RustBuffer) throws -> Contract {
    return try FfiConverterTypeContract.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContract_lower(_ value: Contract) -> RustBuffer {
    return FfiConverterTypeContract.lower(value)
}


public struct ContractQuery: Equatable, Hashable {
    public let contractAddresses: [FieldElement]
    public let contractTypes: [ContractType]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddresses: [FieldElement], contractTypes: [ContractType]) {
        self.contractAddresses = contractAddresses
        self.contractTypes = contractTypes
    }

    
}

#if compiler(>=6)
extension ContractQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContractQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContractQuery {
        return
            try ContractQuery(
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                contractTypes: FfiConverterSequenceTypeContractType.read(from: &buf)
        )
    }

    public static func write(_ value: ContractQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceTypeContractType.write(value.contractTypes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContractQuery_lift(_ buf: RustBuffer) throws -> ContractQuery {
    return try FfiConverterTypeContractQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContractQuery_lower(_ value: ContractQuery) -> RustBuffer {
    return FfiConverterTypeContractQuery.lower(value)
}


public struct Controller: Equatable, Hashable {
    public let address: FieldElement
    public let username: String
    public let deployedAtTimestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: FieldElement, username: String, deployedAtTimestamp: UInt64) {
        self.address = address
        self.username = username
        self.deployedAtTimestamp = deployedAtTimestamp
    }

    
}

#if compiler(>=6)
extension Controller: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeController: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Controller {
        return
            try Controller(
                address: FfiConverterTypeFieldElement.read(from: &buf), 
                username: FfiConverterString.read(from: &buf), 
                deployedAtTimestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Controller, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.address, into: &buf)
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterUInt64.write(value.deployedAtTimestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeController_lift(_ buf: RustBuffer) throws -> Controller {
    return try FfiConverterTypeController.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeController_lower(_ value: Controller) -> RustBuffer {
    return FfiConverterTypeController.lower(value)
}


public struct ControllerQuery: Equatable, Hashable {
    public let pagination: Pagination
    public let contractAddresses: [FieldElement]
    public let usernames: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pagination: Pagination, contractAddresses: [FieldElement], usernames: [String]) {
        self.pagination = pagination
        self.contractAddresses = contractAddresses
        self.usernames = usernames
    }

    
}

#if compiler(>=6)
extension ControllerQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeControllerQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ControllerQuery {
        return
            try ControllerQuery(
                pagination: FfiConverterTypePagination.read(from: &buf), 
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                usernames: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ControllerQuery, into buf: inout [UInt8]) {
        FfiConverterTypePagination.write(value.pagination, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceString.write(value.usernames, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeControllerQuery_lift(_ buf: RustBuffer) throws -> ControllerQuery {
    return try FfiConverterTypeControllerQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeControllerQuery_lower(_ value: ControllerQuery) -> RustBuffer {
    return FfiConverterTypeControllerQuery.lower(value)
}


public struct Entity: Equatable, Hashable {
    public let worldAddress: FieldElement
    public let hashedKeys: FieldElement
    public let models: [Struct]
    public let createdAt: UInt64
    public let updatedAt: UInt64
    public let executedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddress: FieldElement, hashedKeys: FieldElement, models: [Struct], createdAt: UInt64, updatedAt: UInt64, executedAt: UInt64) {
        self.worldAddress = worldAddress
        self.hashedKeys = hashedKeys
        self.models = models
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.executedAt = executedAt
    }

    
}

#if compiler(>=6)
extension Entity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entity {
        return
            try Entity(
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                hashedKeys: FfiConverterTypeFieldElement.read(from: &buf), 
                models: FfiConverterSequenceTypeStruct.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf), 
                executedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Entity, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
        FfiConverterTypeFieldElement.write(value.hashedKeys, into: &buf)
        FfiConverterSequenceTypeStruct.write(value.models, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
        FfiConverterUInt64.write(value.executedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntity_lift(_ buf: RustBuffer) throws -> Entity {
    return try FfiConverterTypeEntity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntity_lower(_ value: Entity) -> RustBuffer {
    return FfiConverterTypeEntity.lower(value)
}


public struct EnumOption: Equatable, Hashable {
    public let name: String
    public let ty: Ty

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, ty: Ty) {
        self.name = name
        self.ty = ty
    }

    
}

#if compiler(>=6)
extension EnumOption: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnumOption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnumOption {
        return
            try EnumOption(
                name: FfiConverterString.read(from: &buf), 
                ty: FfiConverterTypeTy.read(from: &buf)
        )
    }

    public static func write(_ value: EnumOption, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeTy.write(value.ty, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnumOption_lift(_ buf: RustBuffer) throws -> EnumOption {
    return try FfiConverterTypeEnumOption.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnumOption_lower(_ value: EnumOption) -> RustBuffer {
    return FfiConverterTypeEnumOption.lower(value)
}


public struct EnumType: Equatable, Hashable {
    public let name: String
    public let option: UInt8
    public let options: [EnumOption]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, option: UInt8, options: [EnumOption]) {
        self.name = name
        self.option = option
        self.options = options
    }

    
}

#if compiler(>=6)
extension EnumType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnumType: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnumType {
        return
            try EnumType(
                name: FfiConverterString.read(from: &buf), 
                option: FfiConverterUInt8.read(from: &buf), 
                options: FfiConverterSequenceTypeEnumOption.read(from: &buf)
        )
    }

    public static func write(_ value: EnumType, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt8.write(value.option, into: &buf)
        FfiConverterSequenceTypeEnumOption.write(value.options, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnumType_lift(_ buf: RustBuffer) throws -> EnumType {
    return try FfiConverterTypeEnumType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnumType_lower(_ value: EnumType) -> RustBuffer {
    return FfiConverterTypeEnumType.lower(value)
}


public struct Event: Equatable, Hashable {
    public let keys: [FieldElement]
    public let data: [FieldElement]
    public let transactionHash: FieldElement

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keys: [FieldElement], data: [FieldElement], transactionHash: FieldElement) {
        self.keys = keys
        self.data = data
        self.transactionHash = transactionHash
    }

    
}

#if compiler(>=6)
extension Event: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        return
            try Event(
                keys: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                data: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                transactionHash: FfiConverterTypeFieldElement.read(from: &buf)
        )
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.keys, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.data, into: &buf)
        FfiConverterTypeFieldElement.write(value.transactionHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}


public struct EventQuery: Equatable, Hashable {
    public let keys: KeysClause?
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keys: KeysClause?, pagination: Pagination) {
        self.keys = keys
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension EventQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventQuery {
        return
            try EventQuery(
                keys: FfiConverterOptionTypeKeysClause.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: EventQuery, into buf: inout [UInt8]) {
        FfiConverterOptionTypeKeysClause.write(value.keys, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventQuery_lift(_ buf: RustBuffer) throws -> EventQuery {
    return try FfiConverterTypeEventQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventQuery_lower(_ value: EventQuery) -> RustBuffer {
    return FfiConverterTypeEventQuery.lower(value)
}


public struct FixedSizeArray: Equatable, Hashable {
    public let array: [Ty]
    public let size: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(array: [Ty], size: UInt32) {
        self.array = array
        self.size = size
    }

    
}

#if compiler(>=6)
extension FixedSizeArray: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFixedSizeArray: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FixedSizeArray {
        return
            try FixedSizeArray(
                array: FfiConverterSequenceTypeTy.read(from: &buf), 
                size: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: FixedSizeArray, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTy.write(value.array, into: &buf)
        FfiConverterUInt32.write(value.size, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFixedSizeArray_lift(_ buf: RustBuffer) throws -> FixedSizeArray {
    return try FfiConverterTypeFixedSizeArray.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFixedSizeArray_lower(_ value: FixedSizeArray) -> RustBuffer {
    return FfiConverterTypeFixedSizeArray.lower(value)
}


public struct KeysClause: Equatable, Hashable {
    public let keys: [FieldElement?]
    public let patternMatching: PatternMatching
    public let models: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keys: [FieldElement?], patternMatching: PatternMatching, models: [String]) {
        self.keys = keys
        self.patternMatching = patternMatching
        self.models = models
    }

    
}

#if compiler(>=6)
extension KeysClause: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeysClause: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysClause {
        return
            try KeysClause(
                keys: FfiConverterSequenceOptionTypeFieldElement.read(from: &buf), 
                patternMatching: FfiConverterTypePatternMatching.read(from: &buf), 
                models: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysClause, into buf: inout [UInt8]) {
        FfiConverterSequenceOptionTypeFieldElement.write(value.keys, into: &buf)
        FfiConverterTypePatternMatching.write(value.patternMatching, into: &buf)
        FfiConverterSequenceString.write(value.models, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeysClause_lift(_ buf: RustBuffer) throws -> KeysClause {
    return try FfiConverterTypeKeysClause.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeysClause_lower(_ value: KeysClause) -> RustBuffer {
    return FfiConverterTypeKeysClause.lower(value)
}


public struct Member: Equatable, Hashable {
    public let name: String
    public let ty: Ty
    public let key: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, ty: Ty, key: Bool) {
        self.name = name
        self.ty = ty
        self.key = key
    }

    
}

#if compiler(>=6)
extension Member: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Member {
        return
            try Member(
                name: FfiConverterString.read(from: &buf), 
                ty: FfiConverterTypeTy.read(from: &buf), 
                key: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Member, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeTy.write(value.ty, into: &buf)
        FfiConverterBool.write(value.key, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMember_lift(_ buf: RustBuffer) throws -> Member {
    return try FfiConverterTypeMember.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMember_lower(_ value: Member) -> RustBuffer {
    return FfiConverterTypeMember.lower(value)
}


public struct MemberClause: Equatable, Hashable {
    public let model: String
    public let member: String
    public let `operator`: ComparisonOperator
    public let value: MemberValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(model: String, member: String, `operator`: ComparisonOperator, value: MemberValue) {
        self.model = model
        self.member = member
        self.`operator` = `operator`
        self.value = value
    }

    
}

#if compiler(>=6)
extension MemberClause: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMemberClause: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MemberClause {
        return
            try MemberClause(
                model: FfiConverterString.read(from: &buf), 
                member: FfiConverterString.read(from: &buf), 
                operator: FfiConverterTypeComparisonOperator.read(from: &buf), 
                value: FfiConverterTypeMemberValue.read(from: &buf)
        )
    }

    public static func write(_ value: MemberClause, into buf: inout [UInt8]) {
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterString.write(value.member, into: &buf)
        FfiConverterTypeComparisonOperator.write(value.`operator`, into: &buf)
        FfiConverterTypeMemberValue.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMemberClause_lift(_ buf: RustBuffer) throws -> MemberClause {
    return try FfiConverterTypeMemberClause.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMemberClause_lower(_ value: MemberClause) -> RustBuffer {
    return FfiConverterTypeMemberClause.lower(value)
}


public struct Message: Equatable, Hashable {
    public let message: String
    public let signature: [FieldElement]
    public let worldAddress: FieldElement

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, signature: [FieldElement], worldAddress: FieldElement) {
        self.message = message
        self.signature = signature
        self.worldAddress = worldAddress
    }

    
}

#if compiler(>=6)
extension Message: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        return
            try Message(
                message: FfiConverterString.read(from: &buf), 
                signature: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf)
        )
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.signature, into: &buf)
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


public struct Model: Equatable, Hashable {
    public let worldAddress: FieldElement
    public let schema: Ty
    public let namespace: String
    public let name: String
    public let selector: FieldElement
    public let packedSize: UInt32
    public let unpackedSize: UInt32
    public let classHash: FieldElement
    public let contractAddress: FieldElement
    public let layout: String
    public let useLegacyStore: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddress: FieldElement, schema: Ty, namespace: String, name: String, selector: FieldElement, packedSize: UInt32, unpackedSize: UInt32, classHash: FieldElement, contractAddress: FieldElement, layout: String, useLegacyStore: Bool) {
        self.worldAddress = worldAddress
        self.schema = schema
        self.namespace = namespace
        self.name = name
        self.selector = selector
        self.packedSize = packedSize
        self.unpackedSize = unpackedSize
        self.classHash = classHash
        self.contractAddress = contractAddress
        self.layout = layout
        self.useLegacyStore = useLegacyStore
    }

    
}

#if compiler(>=6)
extension Model: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Model {
        return
            try Model(
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                schema: FfiConverterTypeTy.read(from: &buf), 
                namespace: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                selector: FfiConverterTypeFieldElement.read(from: &buf), 
                packedSize: FfiConverterUInt32.read(from: &buf), 
                unpackedSize: FfiConverterUInt32.read(from: &buf), 
                classHash: FfiConverterTypeFieldElement.read(from: &buf), 
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                layout: FfiConverterString.read(from: &buf), 
                useLegacyStore: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Model, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
        FfiConverterTypeTy.write(value.schema, into: &buf)
        FfiConverterString.write(value.namespace, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeFieldElement.write(value.selector, into: &buf)
        FfiConverterUInt32.write(value.packedSize, into: &buf)
        FfiConverterUInt32.write(value.unpackedSize, into: &buf)
        FfiConverterTypeFieldElement.write(value.classHash, into: &buf)
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterString.write(value.layout, into: &buf)
        FfiConverterBool.write(value.useLegacyStore, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModel_lift(_ buf: RustBuffer) throws -> Model {
    return try FfiConverterTypeModel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModel_lower(_ value: Model) -> RustBuffer {
    return FfiConverterTypeModel.lower(value)
}


public struct OrderBy: Equatable, Hashable {
    public let field: String
    public let direction: OrderDirection

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(field: String, direction: OrderDirection) {
        self.field = field
        self.direction = direction
    }

    
}

#if compiler(>=6)
extension OrderBy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOrderBy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrderBy {
        return
            try OrderBy(
                field: FfiConverterString.read(from: &buf), 
                direction: FfiConverterTypeOrderDirection.read(from: &buf)
        )
    }

    public static func write(_ value: OrderBy, into buf: inout [UInt8]) {
        FfiConverterString.write(value.field, into: &buf)
        FfiConverterTypeOrderDirection.write(value.direction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrderBy_lift(_ buf: RustBuffer) throws -> OrderBy {
    return try FfiConverterTypeOrderBy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrderBy_lower(_ value: OrderBy) -> RustBuffer {
    return FfiConverterTypeOrderBy.lower(value)
}


public struct PageAchievement: Equatable, Hashable {
    public let items: [Achievement]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Achievement], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageAchievement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageAchievement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageAchievement {
        return
            try PageAchievement(
                items: FfiConverterSequenceTypeAchievement.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageAchievement, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAchievement.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageAchievement_lift(_ buf: RustBuffer) throws -> PageAchievement {
    return try FfiConverterTypePageAchievement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageAchievement_lower(_ value: PageAchievement) -> RustBuffer {
    return FfiConverterTypePageAchievement.lower(value)
}


public struct PageActivity: Equatable, Hashable {
    public let items: [Activity]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Activity], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageActivity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageActivity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageActivity {
        return
            try PageActivity(
                items: FfiConverterSequenceTypeActivity.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageActivity, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeActivity.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageActivity_lift(_ buf: RustBuffer) throws -> PageActivity {
    return try FfiConverterTypePageActivity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageActivity_lower(_ value: PageActivity) -> RustBuffer {
    return FfiConverterTypePageActivity.lower(value)
}


public struct PageAggregationEntry: Equatable, Hashable {
    public let items: [AggregationEntry]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [AggregationEntry], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageAggregationEntry: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageAggregationEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageAggregationEntry {
        return
            try PageAggregationEntry(
                items: FfiConverterSequenceTypeAggregationEntry.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageAggregationEntry, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAggregationEntry.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageAggregationEntry_lift(_ buf: RustBuffer) throws -> PageAggregationEntry {
    return try FfiConverterTypePageAggregationEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageAggregationEntry_lower(_ value: PageAggregationEntry) -> RustBuffer {
    return FfiConverterTypePageAggregationEntry.lower(value)
}


public struct PageController: Equatable, Hashable {
    public let items: [Controller]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Controller], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageController: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageController: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageController {
        return
            try PageController(
                items: FfiConverterSequenceTypeController.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageController, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeController.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageController_lift(_ buf: RustBuffer) throws -> PageController {
    return try FfiConverterTypePageController.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageController_lower(_ value: PageController) -> RustBuffer {
    return FfiConverterTypePageController.lower(value)
}


public struct PageEntity: Equatable, Hashable {
    public let items: [Entity]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Entity], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageEntity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageEntity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageEntity {
        return
            try PageEntity(
                items: FfiConverterSequenceTypeEntity.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageEntity, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEntity.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageEntity_lift(_ buf: RustBuffer) throws -> PageEntity {
    return try FfiConverterTypePageEntity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageEntity_lower(_ value: PageEntity) -> RustBuffer {
    return FfiConverterTypePageEntity.lower(value)
}


public struct PageEvent: Equatable, Hashable {
    public let items: [Event]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Event], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageEvent {
        return
            try PageEvent(
                items: FfiConverterSequenceTypeEvent.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageEvent, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEvent.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageEvent_lift(_ buf: RustBuffer) throws -> PageEvent {
    return try FfiConverterTypePageEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageEvent_lower(_ value: PageEvent) -> RustBuffer {
    return FfiConverterTypePageEvent.lower(value)
}


public struct PagePlayerAchievement: Equatable, Hashable {
    public let items: [PlayerAchievementEntry]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [PlayerAchievementEntry], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PagePlayerAchievement: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePagePlayerAchievement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PagePlayerAchievement {
        return
            try PagePlayerAchievement(
                items: FfiConverterSequenceTypePlayerAchievementEntry.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PagePlayerAchievement, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePlayerAchievementEntry.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePagePlayerAchievement_lift(_ buf: RustBuffer) throws -> PagePlayerAchievement {
    return try FfiConverterTypePagePlayerAchievement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePagePlayerAchievement_lower(_ value: PagePlayerAchievement) -> RustBuffer {
    return FfiConverterTypePagePlayerAchievement.lower(value)
}


public struct PageToken: Equatable, Hashable {
    public let items: [Token]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Token], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageToken: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageToken: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageToken {
        return
            try PageToken(
                items: FfiConverterSequenceTypeToken.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageToken, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeToken.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageToken_lift(_ buf: RustBuffer) throws -> PageToken {
    return try FfiConverterTypePageToken.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageToken_lower(_ value: PageToken) -> RustBuffer {
    return FfiConverterTypePageToken.lower(value)
}


public struct PageTokenBalance: Equatable, Hashable {
    public let items: [TokenBalance]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [TokenBalance], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageTokenBalance: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageTokenBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageTokenBalance {
        return
            try PageTokenBalance(
                items: FfiConverterSequenceTypeTokenBalance.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageTokenBalance, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTokenBalance.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTokenBalance_lift(_ buf: RustBuffer) throws -> PageTokenBalance {
    return try FfiConverterTypePageTokenBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTokenBalance_lower(_ value: PageTokenBalance) -> RustBuffer {
    return FfiConverterTypePageTokenBalance.lower(value)
}


public struct PageTokenContract: Equatable, Hashable {
    public let items: [TokenContract]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [TokenContract], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageTokenContract: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageTokenContract: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageTokenContract {
        return
            try PageTokenContract(
                items: FfiConverterSequenceTypeTokenContract.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageTokenContract, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTokenContract.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTokenContract_lift(_ buf: RustBuffer) throws -> PageTokenContract {
    return try FfiConverterTypePageTokenContract.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTokenContract_lower(_ value: PageTokenContract) -> RustBuffer {
    return FfiConverterTypePageTokenContract.lower(value)
}


public struct PageTokenTransfer: Equatable, Hashable {
    public let items: [TokenTransfer]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [TokenTransfer], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageTokenTransfer: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageTokenTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageTokenTransfer {
        return
            try PageTokenTransfer(
                items: FfiConverterSequenceTypeTokenTransfer.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageTokenTransfer, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTokenTransfer.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTokenTransfer_lift(_ buf: RustBuffer) throws -> PageTokenTransfer {
    return try FfiConverterTypePageTokenTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTokenTransfer_lower(_ value: PageTokenTransfer) -> RustBuffer {
    return FfiConverterTypePageTokenTransfer.lower(value)
}


public struct PageTransaction: Equatable, Hashable {
    public let items: [Transaction]
    public let nextCursor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [Transaction], nextCursor: String?) {
        self.items = items
        self.nextCursor = nextCursor
    }

    
}

#if compiler(>=6)
extension PageTransaction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageTransaction {
        return
            try PageTransaction(
                items: FfiConverterSequenceTypeTransaction.read(from: &buf), 
                nextCursor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PageTransaction, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTransaction.write(value.items, into: &buf)
        FfiConverterOptionString.write(value.nextCursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTransaction_lift(_ buf: RustBuffer) throws -> PageTransaction {
    return try FfiConverterTypePageTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageTransaction_lower(_ value: PageTransaction) -> RustBuffer {
    return FfiConverterTypePageTransaction.lower(value)
}


public struct Pagination: Equatable, Hashable {
    public let cursor: String?
    public let limit: UInt32?
    public let direction: PaginationDirection
    public let orderBy: [OrderBy]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cursor: String?, limit: UInt32?, direction: PaginationDirection, orderBy: [OrderBy]) {
        self.cursor = cursor
        self.limit = limit
        self.direction = direction
        self.orderBy = orderBy
    }

    
}

#if compiler(>=6)
extension Pagination: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePagination: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Pagination {
        return
            try Pagination(
                cursor: FfiConverterOptionString.read(from: &buf), 
                limit: FfiConverterOptionUInt32.read(from: &buf), 
                direction: FfiConverterTypePaginationDirection.read(from: &buf), 
                orderBy: FfiConverterSequenceTypeOrderBy.read(from: &buf)
        )
    }

    public static func write(_ value: Pagination, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.cursor, into: &buf)
        FfiConverterOptionUInt32.write(value.limit, into: &buf)
        FfiConverterTypePaginationDirection.write(value.direction, into: &buf)
        FfiConverterSequenceTypeOrderBy.write(value.orderBy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePagination_lift(_ buf: RustBuffer) throws -> Pagination {
    return try FfiConverterTypePagination.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePagination_lower(_ value: Pagination) -> RustBuffer {
    return FfiConverterTypePagination.lower(value)
}


public struct PlayerAchievementEntry: Equatable, Hashable {
    public let playerAddress: FieldElement
    public let stats: PlayerAchievementStats
    public let achievements: [PlayerAchievementProgress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(playerAddress: FieldElement, stats: PlayerAchievementStats, achievements: [PlayerAchievementProgress]) {
        self.playerAddress = playerAddress
        self.stats = stats
        self.achievements = achievements
    }

    
}

#if compiler(>=6)
extension PlayerAchievementEntry: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePlayerAchievementEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlayerAchievementEntry {
        return
            try PlayerAchievementEntry(
                playerAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                stats: FfiConverterTypePlayerAchievementStats.read(from: &buf), 
                achievements: FfiConverterSequenceTypePlayerAchievementProgress.read(from: &buf)
        )
    }

    public static func write(_ value: PlayerAchievementEntry, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.playerAddress, into: &buf)
        FfiConverterTypePlayerAchievementStats.write(value.stats, into: &buf)
        FfiConverterSequenceTypePlayerAchievementProgress.write(value.achievements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementEntry_lift(_ buf: RustBuffer) throws -> PlayerAchievementEntry {
    return try FfiConverterTypePlayerAchievementEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementEntry_lower(_ value: PlayerAchievementEntry) -> RustBuffer {
    return FfiConverterTypePlayerAchievementEntry.lower(value)
}


public struct PlayerAchievementProgress: Equatable, Hashable {
    public let achievement: Achievement
    public let taskProgress: [TaskProgress]
    public let completed: Bool
    public let progressPercentage: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(achievement: Achievement, taskProgress: [TaskProgress], completed: Bool, progressPercentage: Double) {
        self.achievement = achievement
        self.taskProgress = taskProgress
        self.completed = completed
        self.progressPercentage = progressPercentage
    }

    
}

#if compiler(>=6)
extension PlayerAchievementProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePlayerAchievementProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlayerAchievementProgress {
        return
            try PlayerAchievementProgress(
                achievement: FfiConverterTypeAchievement.read(from: &buf), 
                taskProgress: FfiConverterSequenceTypeTaskProgress.read(from: &buf), 
                completed: FfiConverterBool.read(from: &buf), 
                progressPercentage: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: PlayerAchievementProgress, into buf: inout [UInt8]) {
        FfiConverterTypeAchievement.write(value.achievement, into: &buf)
        FfiConverterSequenceTypeTaskProgress.write(value.taskProgress, into: &buf)
        FfiConverterBool.write(value.completed, into: &buf)
        FfiConverterDouble.write(value.progressPercentage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementProgress_lift(_ buf: RustBuffer) throws -> PlayerAchievementProgress {
    return try FfiConverterTypePlayerAchievementProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementProgress_lower(_ value: PlayerAchievementProgress) -> RustBuffer {
    return FfiConverterTypePlayerAchievementProgress.lower(value)
}


public struct PlayerAchievementQuery: Equatable, Hashable {
    public let worldAddresses: [FieldElement]
    public let namespaces: [String]
    public let playerAddresses: [FieldElement]
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddresses: [FieldElement], namespaces: [String], playerAddresses: [FieldElement], pagination: Pagination) {
        self.worldAddresses = worldAddresses
        self.namespaces = namespaces
        self.playerAddresses = playerAddresses
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension PlayerAchievementQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePlayerAchievementQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlayerAchievementQuery {
        return
            try PlayerAchievementQuery(
                worldAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                namespaces: FfiConverterSequenceString.read(from: &buf), 
                playerAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: PlayerAchievementQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.worldAddresses, into: &buf)
        FfiConverterSequenceString.write(value.namespaces, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.playerAddresses, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementQuery_lift(_ buf: RustBuffer) throws -> PlayerAchievementQuery {
    return try FfiConverterTypePlayerAchievementQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementQuery_lower(_ value: PlayerAchievementQuery) -> RustBuffer {
    return FfiConverterTypePlayerAchievementQuery.lower(value)
}


public struct PlayerAchievementStats: Equatable, Hashable {
    public let totalPoints: UInt32
    public let completedAchievements: UInt32
    public let totalAchievements: UInt32
    public let completionPercentage: Double
    public let lastAchievementAt: UInt64?
    public let createdAt: UInt64
    public let updatedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(totalPoints: UInt32, completedAchievements: UInt32, totalAchievements: UInt32, completionPercentage: Double, lastAchievementAt: UInt64?, createdAt: UInt64, updatedAt: UInt64) {
        self.totalPoints = totalPoints
        self.completedAchievements = completedAchievements
        self.totalAchievements = totalAchievements
        self.completionPercentage = completionPercentage
        self.lastAchievementAt = lastAchievementAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    
}

#if compiler(>=6)
extension PlayerAchievementStats: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePlayerAchievementStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlayerAchievementStats {
        return
            try PlayerAchievementStats(
                totalPoints: FfiConverterUInt32.read(from: &buf), 
                completedAchievements: FfiConverterUInt32.read(from: &buf), 
                totalAchievements: FfiConverterUInt32.read(from: &buf), 
                completionPercentage: FfiConverterDouble.read(from: &buf), 
                lastAchievementAt: FfiConverterOptionUInt64.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                updatedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PlayerAchievementStats, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.totalPoints, into: &buf)
        FfiConverterUInt32.write(value.completedAchievements, into: &buf)
        FfiConverterUInt32.write(value.totalAchievements, into: &buf)
        FfiConverterDouble.write(value.completionPercentage, into: &buf)
        FfiConverterOptionUInt64.write(value.lastAchievementAt, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt64.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementStats_lift(_ buf: RustBuffer) throws -> PlayerAchievementStats {
    return try FfiConverterTypePlayerAchievementStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlayerAchievementStats_lower(_ value: PlayerAchievementStats) -> RustBuffer {
    return FfiConverterTypePlayerAchievementStats.lower(value)
}


public struct Query: Equatable, Hashable {
    public let worldAddresses: [FieldElement]
    public let pagination: Pagination
    public let clause: Clause?
    public let noHashedKeys: Bool
    public let models: [String]
    public let historical: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddresses: [FieldElement], pagination: Pagination, clause: Clause?, noHashedKeys: Bool, models: [String], historical: Bool) {
        self.worldAddresses = worldAddresses
        self.pagination = pagination
        self.clause = clause
        self.noHashedKeys = noHashedKeys
        self.models = models
        self.historical = historical
    }

    
}

#if compiler(>=6)
extension Query: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Query {
        return
            try Query(
                worldAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf), 
                clause: FfiConverterOptionTypeClause.read(from: &buf), 
                noHashedKeys: FfiConverterBool.read(from: &buf), 
                models: FfiConverterSequenceString.read(from: &buf), 
                historical: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Query, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.worldAddresses, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
        FfiConverterOptionTypeClause.write(value.clause, into: &buf)
        FfiConverterBool.write(value.noHashedKeys, into: &buf)
        FfiConverterSequenceString.write(value.models, into: &buf)
        FfiConverterBool.write(value.historical, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuery_lift(_ buf: RustBuffer) throws -> Query {
    return try FfiConverterTypeQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuery_lower(_ value: Query) -> RustBuffer {
    return FfiConverterTypeQuery.lower(value)
}


public struct Signature: Equatable, Hashable {
    public let r: FieldElement
    public let s: FieldElement

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: FieldElement, s: FieldElement) {
        self.r = r
        self.s = s
    }

    
}

#if compiler(>=6)
extension Signature: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        return
            try Signature(
                r: FfiConverterTypeFieldElement.read(from: &buf), 
                s: FfiConverterTypeFieldElement.read(from: &buf)
        )
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.r, into: &buf)
        FfiConverterTypeFieldElement.write(value.s, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}


public struct SqlField: Equatable, Hashable {
    public let name: String
    public let value: SqlValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, value: SqlValue) {
        self.name = name
        self.value = value
    }

    
}

#if compiler(>=6)
extension SqlField: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSqlField: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SqlField {
        return
            try SqlField(
                name: FfiConverterString.read(from: &buf), 
                value: FfiConverterTypeSqlValue.read(from: &buf)
        )
    }

    public static func write(_ value: SqlField, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeSqlValue.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqlField_lift(_ buf: RustBuffer) throws -> SqlField {
    return try FfiConverterTypeSqlField.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqlField_lower(_ value: SqlField) -> RustBuffer {
    return FfiConverterTypeSqlField.lower(value)
}


public struct SqlRow: Equatable, Hashable {
    public let fields: [SqlField]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fields: [SqlField]) {
        self.fields = fields
    }

    
}

#if compiler(>=6)
extension SqlRow: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSqlRow: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SqlRow {
        return
            try SqlRow(
                fields: FfiConverterSequenceTypeSqlField.read(from: &buf)
        )
    }

    public static func write(_ value: SqlRow, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSqlField.write(value.fields, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqlRow_lift(_ buf: RustBuffer) throws -> SqlRow {
    return try FfiConverterTypeSqlRow.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqlRow_lower(_ value: SqlRow) -> RustBuffer {
    return FfiConverterTypeSqlRow.lower(value)
}


public struct Struct: Equatable, Hashable {
    public let name: String
    public let children: [Member]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, children: [Member]) {
        self.name = name
        self.children = children
    }

    
}

#if compiler(>=6)
extension Struct: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStruct: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Struct {
        return
            try Struct(
                name: FfiConverterString.read(from: &buf), 
                children: FfiConverterSequenceTypeMember.read(from: &buf)
        )
    }

    public static func write(_ value: Struct, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceTypeMember.write(value.children, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStruct_lift(_ buf: RustBuffer) throws -> Struct {
    return try FfiConverterTypeStruct.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStruct_lower(_ value: Struct) -> RustBuffer {
    return FfiConverterTypeStruct.lower(value)
}


public struct TaskProgress: Equatable, Hashable {
    public let taskId: String
    public let count: UInt32
    public let completed: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(taskId: String, count: UInt32, completed: Bool) {
        self.taskId = taskId
        self.count = count
        self.completed = completed
    }

    
}

#if compiler(>=6)
extension TaskProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTaskProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskProgress {
        return
            try TaskProgress(
                taskId: FfiConverterString.read(from: &buf), 
                count: FfiConverterUInt32.read(from: &buf), 
                completed: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TaskProgress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.taskId, into: &buf)
        FfiConverterUInt32.write(value.count, into: &buf)
        FfiConverterBool.write(value.completed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskProgress_lift(_ buf: RustBuffer) throws -> TaskProgress {
    return try FfiConverterTypeTaskProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskProgress_lower(_ value: TaskProgress) -> RustBuffer {
    return FfiConverterTypeTaskProgress.lower(value)
}


public struct Token: Equatable, Hashable {
    public let contractAddress: FieldElement
    public let tokenId: U256?
    public let name: String
    public let symbol: String
    public let decimals: UInt8
    public let metadata: String
    public let totalSupply: U256?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddress: FieldElement, tokenId: U256?, name: String, symbol: String, decimals: UInt8, metadata: String, totalSupply: U256?) {
        self.contractAddress = contractAddress
        self.tokenId = tokenId
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.metadata = metadata
        self.totalSupply = totalSupply
    }

    
}

#if compiler(>=6)
extension Token: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeToken: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Token {
        return
            try Token(
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                tokenId: FfiConverterOptionTypeU256.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                symbol: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt8.read(from: &buf), 
                metadata: FfiConverterString.read(from: &buf), 
                totalSupply: FfiConverterOptionTypeU256.read(from: &buf)
        )
    }

    public static func write(_ value: Token, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterOptionTypeU256.write(value.tokenId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterUInt8.write(value.decimals, into: &buf)
        FfiConverterString.write(value.metadata, into: &buf)
        FfiConverterOptionTypeU256.write(value.totalSupply, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToken_lift(_ buf: RustBuffer) throws -> Token {
    return try FfiConverterTypeToken.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToken_lower(_ value: Token) -> RustBuffer {
    return FfiConverterTypeToken.lower(value)
}


public struct TokenBalance: Equatable, Hashable {
    public let balance: U256
    public let accountAddress: FieldElement
    public let contractAddress: FieldElement
    public let tokenId: U256?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(balance: U256, accountAddress: FieldElement, contractAddress: FieldElement, tokenId: U256?) {
        self.balance = balance
        self.accountAddress = accountAddress
        self.contractAddress = contractAddress
        self.tokenId = tokenId
    }

    
}

#if compiler(>=6)
extension TokenBalance: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenBalance {
        return
            try TokenBalance(
                balance: FfiConverterTypeU256.read(from: &buf), 
                accountAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                tokenId: FfiConverterOptionTypeU256.read(from: &buf)
        )
    }

    public static func write(_ value: TokenBalance, into buf: inout [UInt8]) {
        FfiConverterTypeU256.write(value.balance, into: &buf)
        FfiConverterTypeFieldElement.write(value.accountAddress, into: &buf)
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterOptionTypeU256.write(value.tokenId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lift(_ buf: RustBuffer) throws -> TokenBalance {
    return try FfiConverterTypeTokenBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lower(_ value: TokenBalance) -> RustBuffer {
    return FfiConverterTypeTokenBalance.lower(value)
}


public struct TokenBalanceQuery: Equatable, Hashable {
    public let contractAddresses: [FieldElement]
    public let accountAddresses: [FieldElement]
    public let tokenIds: [U256]
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddresses: [FieldElement], accountAddresses: [FieldElement], tokenIds: [U256], pagination: Pagination) {
        self.contractAddresses = contractAddresses
        self.accountAddresses = accountAddresses
        self.tokenIds = tokenIds
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension TokenBalanceQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenBalanceQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenBalanceQuery {
        return
            try TokenBalanceQuery(
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                accountAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                tokenIds: FfiConverterSequenceTypeU256.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: TokenBalanceQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.accountAddresses, into: &buf)
        FfiConverterSequenceTypeU256.write(value.tokenIds, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalanceQuery_lift(_ buf: RustBuffer) throws -> TokenBalanceQuery {
    return try FfiConverterTypeTokenBalanceQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalanceQuery_lower(_ value: TokenBalanceQuery) -> RustBuffer {
    return FfiConverterTypeTokenBalanceQuery.lower(value)
}


public struct TokenContract: Equatable, Hashable {
    public let contractAddress: FieldElement
    public let name: String
    public let symbol: String
    public let decimals: UInt8
    public let metadata: String
    public let tokenMetadata: String
    public let totalSupply: U256?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddress: FieldElement, name: String, symbol: String, decimals: UInt8, metadata: String, tokenMetadata: String, totalSupply: U256?) {
        self.contractAddress = contractAddress
        self.name = name
        self.symbol = symbol
        self.decimals = decimals
        self.metadata = metadata
        self.tokenMetadata = tokenMetadata
        self.totalSupply = totalSupply
    }

    
}

#if compiler(>=6)
extension TokenContract: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenContract: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenContract {
        return
            try TokenContract(
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                symbol: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt8.read(from: &buf), 
                metadata: FfiConverterString.read(from: &buf), 
                tokenMetadata: FfiConverterString.read(from: &buf), 
                totalSupply: FfiConverterOptionTypeU256.read(from: &buf)
        )
    }

    public static func write(_ value: TokenContract, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterUInt8.write(value.decimals, into: &buf)
        FfiConverterString.write(value.metadata, into: &buf)
        FfiConverterString.write(value.tokenMetadata, into: &buf)
        FfiConverterOptionTypeU256.write(value.totalSupply, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenContract_lift(_ buf: RustBuffer) throws -> TokenContract {
    return try FfiConverterTypeTokenContract.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenContract_lower(_ value: TokenContract) -> RustBuffer {
    return FfiConverterTypeTokenContract.lower(value)
}


public struct TokenContractQuery: Equatable, Hashable {
    public let contractAddresses: [FieldElement]
    public let contractTypes: [ContractType]
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddresses: [FieldElement], contractTypes: [ContractType], pagination: Pagination) {
        self.contractAddresses = contractAddresses
        self.contractTypes = contractTypes
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension TokenContractQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenContractQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenContractQuery {
        return
            try TokenContractQuery(
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                contractTypes: FfiConverterSequenceTypeContractType.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: TokenContractQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceTypeContractType.write(value.contractTypes, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenContractQuery_lift(_ buf: RustBuffer) throws -> TokenContractQuery {
    return try FfiConverterTypeTokenContractQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenContractQuery_lower(_ value: TokenContractQuery) -> RustBuffer {
    return FfiConverterTypeTokenContractQuery.lower(value)
}


public struct TokenQuery: Equatable, Hashable {
    public let contractAddresses: [FieldElement]
    public let tokenIds: [U256]
    public let attributeFilters: [AttributeFilter]
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddresses: [FieldElement], tokenIds: [U256], attributeFilters: [AttributeFilter], pagination: Pagination) {
        self.contractAddresses = contractAddresses
        self.tokenIds = tokenIds
        self.attributeFilters = attributeFilters
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension TokenQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenQuery {
        return
            try TokenQuery(
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                tokenIds: FfiConverterSequenceTypeU256.read(from: &buf), 
                attributeFilters: FfiConverterSequenceTypeAttributeFilter.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: TokenQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceTypeU256.write(value.tokenIds, into: &buf)
        FfiConverterSequenceTypeAttributeFilter.write(value.attributeFilters, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenQuery_lift(_ buf: RustBuffer) throws -> TokenQuery {
    return try FfiConverterTypeTokenQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenQuery_lower(_ value: TokenQuery) -> RustBuffer {
    return FfiConverterTypeTokenQuery.lower(value)
}


public struct TokenTransfer: Equatable, Hashable {
    public let id: String
    public let contractAddress: FieldElement
    public let fromAddress: FieldElement
    public let toAddress: FieldElement
    public let amount: U256
    public let tokenId: U256?
    public let executedAt: UInt64
    public let eventId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, contractAddress: FieldElement, fromAddress: FieldElement, toAddress: FieldElement, amount: U256, tokenId: U256?, executedAt: UInt64, eventId: String?) {
        self.id = id
        self.contractAddress = contractAddress
        self.fromAddress = fromAddress
        self.toAddress = toAddress
        self.amount = amount
        self.tokenId = tokenId
        self.executedAt = executedAt
        self.eventId = eventId
    }

    
}

#if compiler(>=6)
extension TokenTransfer: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenTransfer {
        return
            try TokenTransfer(
                id: FfiConverterString.read(from: &buf), 
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                fromAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                toAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                amount: FfiConverterTypeU256.read(from: &buf), 
                tokenId: FfiConverterOptionTypeU256.read(from: &buf), 
                executedAt: FfiConverterUInt64.read(from: &buf), 
                eventId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: TokenTransfer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterTypeFieldElement.write(value.fromAddress, into: &buf)
        FfiConverterTypeFieldElement.write(value.toAddress, into: &buf)
        FfiConverterTypeU256.write(value.amount, into: &buf)
        FfiConverterOptionTypeU256.write(value.tokenId, into: &buf)
        FfiConverterUInt64.write(value.executedAt, into: &buf)
        FfiConverterOptionString.write(value.eventId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenTransfer_lift(_ buf: RustBuffer) throws -> TokenTransfer {
    return try FfiConverterTypeTokenTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenTransfer_lower(_ value: TokenTransfer) -> RustBuffer {
    return FfiConverterTypeTokenTransfer.lower(value)
}


public struct TokenTransferQuery: Equatable, Hashable {
    public let contractAddresses: [FieldElement]
    public let accountAddresses: [FieldElement]
    public let tokenIds: [U256]
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddresses: [FieldElement], accountAddresses: [FieldElement], tokenIds: [U256], pagination: Pagination) {
        self.contractAddresses = contractAddresses
        self.accountAddresses = accountAddresses
        self.tokenIds = tokenIds
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension TokenTransferQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenTransferQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenTransferQuery {
        return
            try TokenTransferQuery(
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                accountAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                tokenIds: FfiConverterSequenceTypeU256.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: TokenTransferQuery, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.accountAddresses, into: &buf)
        FfiConverterSequenceTypeU256.write(value.tokenIds, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenTransferQuery_lift(_ buf: RustBuffer) throws -> TokenTransferQuery {
    return try FfiConverterTypeTokenTransferQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenTransferQuery_lower(_ value: TokenTransferQuery) -> RustBuffer {
    return FfiConverterTypeTokenTransferQuery.lower(value)
}


public struct Transaction: Equatable, Hashable {
    public let transactionHash: FieldElement
    public let senderAddress: FieldElement
    public let calldata: [FieldElement]
    public let maxFee: FieldElement
    public let signature: [FieldElement]
    public let nonce: FieldElement
    public let blockNumber: UInt64
    public let transactionType: String
    public let blockTimestamp: UInt64
    public let calls: [TransactionCall]
    public let uniqueModels: [FieldElement]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionHash: FieldElement, senderAddress: FieldElement, calldata: [FieldElement], maxFee: FieldElement, signature: [FieldElement], nonce: FieldElement, blockNumber: UInt64, transactionType: String, blockTimestamp: UInt64, calls: [TransactionCall], uniqueModels: [FieldElement]) {
        self.transactionHash = transactionHash
        self.senderAddress = senderAddress
        self.calldata = calldata
        self.maxFee = maxFee
        self.signature = signature
        self.nonce = nonce
        self.blockNumber = blockNumber
        self.transactionType = transactionType
        self.blockTimestamp = blockTimestamp
        self.calls = calls
        self.uniqueModels = uniqueModels
    }

    
}

#if compiler(>=6)
extension Transaction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        return
            try Transaction(
                transactionHash: FfiConverterTypeFieldElement.read(from: &buf), 
                senderAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                calldata: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                maxFee: FfiConverterTypeFieldElement.read(from: &buf), 
                signature: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                nonce: FfiConverterTypeFieldElement.read(from: &buf), 
                blockNumber: FfiConverterUInt64.read(from: &buf), 
                transactionType: FfiConverterString.read(from: &buf), 
                blockTimestamp: FfiConverterUInt64.read(from: &buf), 
                calls: FfiConverterSequenceTypeTransactionCall.read(from: &buf), 
                uniqueModels: FfiConverterSequenceTypeFieldElement.read(from: &buf)
        )
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.transactionHash, into: &buf)
        FfiConverterTypeFieldElement.write(value.senderAddress, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.calldata, into: &buf)
        FfiConverterTypeFieldElement.write(value.maxFee, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.signature, into: &buf)
        FfiConverterTypeFieldElement.write(value.nonce, into: &buf)
        FfiConverterUInt64.write(value.blockNumber, into: &buf)
        FfiConverterString.write(value.transactionType, into: &buf)
        FfiConverterUInt64.write(value.blockTimestamp, into: &buf)
        FfiConverterSequenceTypeTransactionCall.write(value.calls, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.uniqueModels, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}


public struct TransactionCall: Equatable, Hashable {
    public let contractAddress: FieldElement
    public let entrypoint: String
    public let calldata: [FieldElement]
    public let callType: CallType
    public let callerAddress: FieldElement

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contractAddress: FieldElement, entrypoint: String, calldata: [FieldElement], callType: CallType, callerAddress: FieldElement) {
        self.contractAddress = contractAddress
        self.entrypoint = entrypoint
        self.calldata = calldata
        self.callType = callType
        self.callerAddress = callerAddress
    }

    
}

#if compiler(>=6)
extension TransactionCall: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionCall: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionCall {
        return
            try TransactionCall(
                contractAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                entrypoint: FfiConverterString.read(from: &buf), 
                calldata: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                callType: FfiConverterTypeCallType.read(from: &buf), 
                callerAddress: FfiConverterTypeFieldElement.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionCall, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.contractAddress, into: &buf)
        FfiConverterString.write(value.entrypoint, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.calldata, into: &buf)
        FfiConverterTypeCallType.write(value.callType, into: &buf)
        FfiConverterTypeFieldElement.write(value.callerAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionCall_lift(_ buf: RustBuffer) throws -> TransactionCall {
    return try FfiConverterTypeTransactionCall.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionCall_lower(_ value: TransactionCall) -> RustBuffer {
    return FfiConverterTypeTransactionCall.lower(value)
}


public struct TransactionFilter: Equatable, Hashable {
    public let transactionHashes: [FieldElement]
    public let callerAddresses: [FieldElement]
    public let contractAddresses: [FieldElement]
    public let entrypoints: [String]
    public let modelSelectors: [FieldElement]
    public let fromBlock: UInt64?
    public let toBlock: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionHashes: [FieldElement], callerAddresses: [FieldElement], contractAddresses: [FieldElement], entrypoints: [String], modelSelectors: [FieldElement], fromBlock: UInt64?, toBlock: UInt64?) {
        self.transactionHashes = transactionHashes
        self.callerAddresses = callerAddresses
        self.contractAddresses = contractAddresses
        self.entrypoints = entrypoints
        self.modelSelectors = modelSelectors
        self.fromBlock = fromBlock
        self.toBlock = toBlock
    }

    
}

#if compiler(>=6)
extension TransactionFilter: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionFilter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionFilter {
        return
            try TransactionFilter(
                transactionHashes: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                callerAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                contractAddresses: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                entrypoints: FfiConverterSequenceString.read(from: &buf), 
                modelSelectors: FfiConverterSequenceTypeFieldElement.read(from: &buf), 
                fromBlock: FfiConverterOptionUInt64.read(from: &buf), 
                toBlock: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionFilter, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldElement.write(value.transactionHashes, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.callerAddresses, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.contractAddresses, into: &buf)
        FfiConverterSequenceString.write(value.entrypoints, into: &buf)
        FfiConverterSequenceTypeFieldElement.write(value.modelSelectors, into: &buf)
        FfiConverterOptionUInt64.write(value.fromBlock, into: &buf)
        FfiConverterOptionUInt64.write(value.toBlock, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionFilter_lift(_ buf: RustBuffer) throws -> TransactionFilter {
    return try FfiConverterTypeTransactionFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionFilter_lower(_ value: TransactionFilter) -> RustBuffer {
    return FfiConverterTypeTransactionFilter.lower(value)
}


public struct TransactionQuery: Equatable, Hashable {
    public let filter: TransactionFilter?
    public let pagination: Pagination

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(filter: TransactionFilter?, pagination: Pagination) {
        self.filter = filter
        self.pagination = pagination
    }

    
}

#if compiler(>=6)
extension TransactionQuery: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionQuery: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionQuery {
        return
            try TransactionQuery(
                filter: FfiConverterOptionTypeTransactionFilter.read(from: &buf), 
                pagination: FfiConverterTypePagination.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionQuery, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTransactionFilter.write(value.filter, into: &buf)
        FfiConverterTypePagination.write(value.pagination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionQuery_lift(_ buf: RustBuffer) throws -> TransactionQuery {
    return try FfiConverterTypeTransactionQuery.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionQuery_lower(_ value: TransactionQuery) -> RustBuffer {
    return FfiConverterTypeTransactionQuery.lower(value)
}


public struct World: Equatable, Hashable {
    public let worldAddress: FieldElement
    public let models: [Model]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(worldAddress: FieldElement, models: [Model]) {
        self.worldAddress = worldAddress
        self.models = models
    }

    
}

#if compiler(>=6)
extension World: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWorld: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> World {
        return
            try World(
                worldAddress: FfiConverterTypeFieldElement.read(from: &buf), 
                models: FfiConverterSequenceTypeModel.read(from: &buf)
        )
    }

    public static func write(_ value: World, into buf: inout [UInt8]) {
        FfiConverterTypeFieldElement.write(value.worldAddress, into: &buf)
        FfiConverterSequenceTypeModel.write(value.models, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWorld_lift(_ buf: RustBuffer) throws -> World {
    return try FfiConverterTypeWorld.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWorld_lower(_ value: World) -> RustBuffer {
    return FfiConverterTypeWorld.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CallType: Equatable, Hashable {
    
    case execute
    case executeFromOutside



}

#if compiler(>=6)
extension CallType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCallType: FfiConverterRustBuffer {
    typealias SwiftType = CallType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CallType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .execute
        
        case 2: return .executeFromOutside
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CallType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .execute:
            writeInt(&buf, Int32(1))
        
        
        case .executeFromOutside:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCallType_lift(_ buf: RustBuffer) throws -> CallType {
    return try FfiConverterTypeCallType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCallType_lower(_ value: CallType) -> RustBuffer {
    return FfiConverterTypeCallType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Clause: Equatable, Hashable {
    
    case hashedKeys(keys: [FieldElement]
    )
    case keys(clause: KeysClause
    )
    case member(clause: MemberClause
    )
    case composite(clause: CompositeClause
    )



}

#if compiler(>=6)
extension Clause: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClause: FfiConverterRustBuffer {
    typealias SwiftType = Clause

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Clause {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hashedKeys(keys: try FfiConverterSequenceTypeFieldElement.read(from: &buf)
        )
        
        case 2: return .keys(clause: try FfiConverterTypeKeysClause.read(from: &buf)
        )
        
        case 3: return .member(clause: try FfiConverterTypeMemberClause.read(from: &buf)
        )
        
        case 4: return .composite(clause: try FfiConverterTypeCompositeClause.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Clause, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hashedKeys(keys):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeFieldElement.write(keys, into: &buf)
            
        
        case let .keys(clause):
            writeInt(&buf, Int32(2))
            FfiConverterTypeKeysClause.write(clause, into: &buf)
            
        
        case let .member(clause):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMemberClause.write(clause, into: &buf)
            
        
        case let .composite(clause):
            writeInt(&buf, Int32(4))
            FfiConverterTypeCompositeClause.write(clause, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClause_lift(_ buf: RustBuffer) throws -> Clause {
    return try FfiConverterTypeClause.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClause_lower(_ value: Clause) -> RustBuffer {
    return FfiConverterTypeClause.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ComparisonOperator: Equatable, Hashable {
    
    case eq
    case neq
    case gt
    case gte
    case lt
    case lte
    case `in`
    case notIn
    case contains
    case containsAll
    case containsAny
    case arrayLengthEq
    case arrayLengthGt
    case arrayLengthLt



}

#if compiler(>=6)
extension ComparisonOperator: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeComparisonOperator: FfiConverterRustBuffer {
    typealias SwiftType = ComparisonOperator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComparisonOperator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eq
        
        case 2: return .neq
        
        case 3: return .gt
        
        case 4: return .gte
        
        case 5: return .lt
        
        case 6: return .lte
        
        case 7: return .`in`
        
        case 8: return .notIn
        
        case 9: return .contains
        
        case 10: return .containsAll
        
        case 11: return .containsAny
        
        case 12: return .arrayLengthEq
        
        case 13: return .arrayLengthGt
        
        case 14: return .arrayLengthLt
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ComparisonOperator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .eq:
            writeInt(&buf, Int32(1))
        
        
        case .neq:
            writeInt(&buf, Int32(2))
        
        
        case .gt:
            writeInt(&buf, Int32(3))
        
        
        case .gte:
            writeInt(&buf, Int32(4))
        
        
        case .lt:
            writeInt(&buf, Int32(5))
        
        
        case .lte:
            writeInt(&buf, Int32(6))
        
        
        case .`in`:
            writeInt(&buf, Int32(7))
        
        
        case .notIn:
            writeInt(&buf, Int32(8))
        
        
        case .contains:
            writeInt(&buf, Int32(9))
        
        
        case .containsAll:
            writeInt(&buf, Int32(10))
        
        
        case .containsAny:
            writeInt(&buf, Int32(11))
        
        
        case .arrayLengthEq:
            writeInt(&buf, Int32(12))
        
        
        case .arrayLengthGt:
            writeInt(&buf, Int32(13))
        
        
        case .arrayLengthLt:
            writeInt(&buf, Int32(14))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComparisonOperator_lift(_ buf: RustBuffer) throws -> ComparisonOperator {
    return try FfiConverterTypeComparisonOperator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComparisonOperator_lower(_ value: ComparisonOperator) -> RustBuffer {
    return FfiConverterTypeComparisonOperator.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ContractType: Equatable, Hashable {
    
    case world
    case erc20
    case erc721
    case erc1155
    case udc
    case other



}

#if compiler(>=6)
extension ContractType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContractType: FfiConverterRustBuffer {
    typealias SwiftType = ContractType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContractType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .world
        
        case 2: return .erc20
        
        case 3: return .erc721
        
        case 4: return .erc1155
        
        case 5: return .udc
        
        case 6: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContractType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .world:
            writeInt(&buf, Int32(1))
        
        
        case .erc20:
            writeInt(&buf, Int32(2))
        
        
        case .erc721:
            writeInt(&buf, Int32(3))
        
        
        case .erc1155:
            writeInt(&buf, Int32(4))
        
        
        case .udc:
            writeInt(&buf, Int32(5))
        
        
        case .other:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContractType_lift(_ buf: RustBuffer) throws -> ContractType {
    return try FfiConverterTypeContractType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContractType_lower(_ value: ContractType) -> RustBuffer {
    return FfiConverterTypeContractType.lower(value)
}



public enum DojoError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case ClientError(message: String)
    
    case SerializationError(message: String)
    
    case NetworkError(message: String)
    
    case InvalidInput(message: String)
    
    case ConnectionError(message: String)
    
    case PublishError(message: String)
    
    case QueryError(message: String)
    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension DojoError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDojoError: FfiConverterRustBuffer {
    typealias SwiftType = DojoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DojoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ClientError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .SerializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .NetworkError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ConnectionError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .PublishError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .QueryError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DojoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .ClientError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .SerializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .NetworkError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .ConnectionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .PublishError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .QueryError(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDojoError_lift(_ buf: RustBuffer) throws -> DojoError {
    return try FfiConverterTypeDojoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDojoError_lower(_ value: DojoError) -> RustBuffer {
    return FfiConverterTypeDojoError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogicalOperator: Equatable, Hashable {
    
    case and
    case or



}

#if compiler(>=6)
extension LogicalOperator: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogicalOperator: FfiConverterRustBuffer {
    typealias SwiftType = LogicalOperator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogicalOperator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .and
        
        case 2: return .or
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogicalOperator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .and:
            writeInt(&buf, Int32(1))
        
        
        case .or:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogicalOperator_lift(_ buf: RustBuffer) throws -> LogicalOperator {
    return try FfiConverterTypeLogicalOperator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogicalOperator_lower(_ value: LogicalOperator) -> RustBuffer {
    return FfiConverterTypeLogicalOperator.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MemberValue: Equatable, Hashable {
    
    case primitive(value: Primitive
    )
    case string(value: String
    )
    case list(values: [MemberValue]
    )



}

#if compiler(>=6)
extension MemberValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMemberValue: FfiConverterRustBuffer {
    typealias SwiftType = MemberValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MemberValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .primitive(value: try FfiConverterTypePrimitive.read(from: &buf)
        )
        
        case 2: return .string(value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .list(values: try FfiConverterSequenceTypeMemberValue.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MemberValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .primitive(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypePrimitive.write(value, into: &buf)
            
        
        case let .string(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .list(values):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeMemberValue.write(values, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMemberValue_lift(_ buf: RustBuffer) throws -> MemberValue {
    return try FfiConverterTypeMemberValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMemberValue_lower(_ value: MemberValue) -> RustBuffer {
    return FfiConverterTypeMemberValue.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OrderDirection: Equatable, Hashable {
    
    case asc
    case desc



}

#if compiler(>=6)
extension OrderDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOrderDirection: FfiConverterRustBuffer {
    typealias SwiftType = OrderDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrderDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .asc
        
        case 2: return .desc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OrderDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .asc:
            writeInt(&buf, Int32(1))
        
        
        case .desc:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrderDirection_lift(_ buf: RustBuffer) throws -> OrderDirection {
    return try FfiConverterTypeOrderDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrderDirection_lower(_ value: OrderDirection) -> RustBuffer {
    return FfiConverterTypeOrderDirection.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaginationDirection: Equatable, Hashable {
    
    case forward
    case backward



}

#if compiler(>=6)
extension PaginationDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaginationDirection: FfiConverterRustBuffer {
    typealias SwiftType = PaginationDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaginationDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .forward
        
        case 2: return .backward
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaginationDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .forward:
            writeInt(&buf, Int32(1))
        
        
        case .backward:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaginationDirection_lift(_ buf: RustBuffer) throws -> PaginationDirection {
    return try FfiConverterTypePaginationDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaginationDirection_lower(_ value: PaginationDirection) -> RustBuffer {
    return FfiConverterTypePaginationDirection.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PatternMatching: Equatable, Hashable {
    
    case fixedLen
    case variableLen



}

#if compiler(>=6)
extension PatternMatching: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePatternMatching: FfiConverterRustBuffer {
    typealias SwiftType = PatternMatching

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PatternMatching {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixedLen
        
        case 2: return .variableLen
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PatternMatching, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fixedLen:
            writeInt(&buf, Int32(1))
        
        
        case .variableLen:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePatternMatching_lift(_ buf: RustBuffer) throws -> PatternMatching {
    return try FfiConverterTypePatternMatching.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePatternMatching_lower(_ value: PatternMatching) -> RustBuffer {
    return FfiConverterTypePatternMatching.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Primitive: Equatable, Hashable {
    
    case i8(value: Int8
    )
    case i16(value: Int16
    )
    case i32(value: Int32
    )
    case i64(value: Int64
    )
    case i128(value: [UInt8]
    )
    case u8(value: UInt8
    )
    case u16(value: UInt16
    )
    case u32(value: UInt32
    )
    case u64(value: UInt64
    )
    case u128(value: [UInt8]
    )
    case u256(value: U256
    )
    case bool(value: Bool
    )
    case felt252(value: FieldElement
    )
    case classHash(value: FieldElement
    )
    case contractAddress(value: FieldElement
    )
    case ethAddress(value: FieldElement
    )



}

#if compiler(>=6)
extension Primitive: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrimitive: FfiConverterRustBuffer {
    typealias SwiftType = Primitive

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Primitive {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .i8(value: try FfiConverterInt8.read(from: &buf)
        )
        
        case 2: return .i16(value: try FfiConverterInt16.read(from: &buf)
        )
        
        case 3: return .i32(value: try FfiConverterInt32.read(from: &buf)
        )
        
        case 4: return .i64(value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 5: return .i128(value: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 6: return .u8(value: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 7: return .u16(value: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 8: return .u32(value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 9: return .u64(value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 10: return .u128(value: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 11: return .u256(value: try FfiConverterTypeU256.read(from: &buf)
        )
        
        case 12: return .bool(value: try FfiConverterBool.read(from: &buf)
        )
        
        case 13: return .felt252(value: try FfiConverterTypeFieldElement.read(from: &buf)
        )
        
        case 14: return .classHash(value: try FfiConverterTypeFieldElement.read(from: &buf)
        )
        
        case 15: return .contractAddress(value: try FfiConverterTypeFieldElement.read(from: &buf)
        )
        
        case 16: return .ethAddress(value: try FfiConverterTypeFieldElement.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Primitive, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .i8(value):
            writeInt(&buf, Int32(1))
            FfiConverterInt8.write(value, into: &buf)
            
        
        case let .i16(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt16.write(value, into: &buf)
            
        
        case let .i32(value):
            writeInt(&buf, Int32(3))
            FfiConverterInt32.write(value, into: &buf)
            
        
        case let .i64(value):
            writeInt(&buf, Int32(4))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .i128(value):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceUInt8.write(value, into: &buf)
            
        
        case let .u8(value):
            writeInt(&buf, Int32(6))
            FfiConverterUInt8.write(value, into: &buf)
            
        
        case let .u16(value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt16.write(value, into: &buf)
            
        
        case let .u32(value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .u64(value):
            writeInt(&buf, Int32(9))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .u128(value):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceUInt8.write(value, into: &buf)
            
        
        case let .u256(value):
            writeInt(&buf, Int32(11))
            FfiConverterTypeU256.write(value, into: &buf)
            
        
        case let .bool(value):
            writeInt(&buf, Int32(12))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .felt252(value):
            writeInt(&buf, Int32(13))
            FfiConverterTypeFieldElement.write(value, into: &buf)
            
        
        case let .classHash(value):
            writeInt(&buf, Int32(14))
            FfiConverterTypeFieldElement.write(value, into: &buf)
            
        
        case let .contractAddress(value):
            writeInt(&buf, Int32(15))
            FfiConverterTypeFieldElement.write(value, into: &buf)
            
        
        case let .ethAddress(value):
            writeInt(&buf, Int32(16))
            FfiConverterTypeFieldElement.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimitive_lift(_ buf: RustBuffer) throws -> Primitive {
    return try FfiConverterTypePrimitive.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimitive_lower(_ value: Primitive) -> RustBuffer {
    return FfiConverterTypePrimitive.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SqlValue: Equatable, Hashable {
    
    case text(value: String
    )
    case integer(value: Int64
    )
    case real(value: Double
    )
    case blob(value: [UInt8]
    )
    case null



}

#if compiler(>=6)
extension SqlValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSqlValue: FfiConverterRustBuffer {
    typealias SwiftType = SqlValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SqlValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .integer(value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 3: return .real(value: try FfiConverterDouble.read(from: &buf)
        )
        
        case 4: return .blob(value: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 5: return .null
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SqlValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .integer(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .real(value):
            writeInt(&buf, Int32(3))
            FfiConverterDouble.write(value, into: &buf)
            
        
        case let .blob(value):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceUInt8.write(value, into: &buf)
            
        
        case .null:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqlValue_lift(_ buf: RustBuffer) throws -> SqlValue {
    return try FfiConverterTypeSqlValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqlValue_lower(_ value: SqlValue) -> RustBuffer {
    return FfiConverterTypeSqlValue.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Ty: Equatable, Hashable {
    
    case primitive(value: Primitive
    )
    case `struct`(value: Struct
    )
    case `enum`(value: EnumType
    )
    case tuple(values: [Ty]
    )
    case array(values: [Ty]
    )
    case fixedSizeArray(value: FixedSizeArray
    )
    case byteArray(value: String
    )



}

#if compiler(>=6)
extension Ty: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTy: FfiConverterRustBuffer {
    typealias SwiftType = Ty

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ty {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .primitive(value: try FfiConverterTypePrimitive.read(from: &buf)
        )
        
        case 2: return .`struct`(value: try FfiConverterTypeStruct.read(from: &buf)
        )
        
        case 3: return .`enum`(value: try FfiConverterTypeEnumType.read(from: &buf)
        )
        
        case 4: return .tuple(values: try FfiConverterSequenceTypeTy.read(from: &buf)
        )
        
        case 5: return .array(values: try FfiConverterSequenceTypeTy.read(from: &buf)
        )
        
        case 6: return .fixedSizeArray(value: try FfiConverterTypeFixedSizeArray.read(from: &buf)
        )
        
        case 7: return .byteArray(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Ty, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .primitive(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypePrimitive.write(value, into: &buf)
            
        
        case let .`struct`(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStruct.write(value, into: &buf)
            
        
        case let .`enum`(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEnumType.write(value, into: &buf)
            
        
        case let .tuple(values):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeTy.write(values, into: &buf)
            
        
        case let .array(values):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeTy.write(values, into: &buf)
            
        
        case let .fixedSizeArray(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFixedSizeArray.write(value, into: &buf)
            
        
        case let .byteArray(value):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTy_lift(_ buf: RustBuffer) throws -> Ty {
    return try FfiConverterTypeTy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTy_lower(_ value: Ty) -> RustBuffer {
    return FfiConverterTypeTy.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ValueType: Equatable, Hashable {
    
    case string(value: String
    )
    case int(value: Int64
    )
    case uInt(value: UInt64
    )
    case bool(value: Bool
    )
    case bytes(value: [UInt8]
    )



}

#if compiler(>=6)
extension ValueType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValueType: FfiConverterRustBuffer {
    typealias SwiftType = ValueType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValueType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .int(value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 3: return .uInt(value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 4: return .bool(value: try FfiConverterBool.read(from: &buf)
        )
        
        case 5: return .bytes(value: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ValueType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .int(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .uInt(value):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .bool(value):
            writeInt(&buf, Int32(4))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .bytes(value):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceUInt8.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValueType_lift(_ buf: RustBuffer) throws -> ValueType {
    return try FfiConverterTypeValueType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValueType_lower(_ value: ValueType) -> RustBuffer {
    return FfiConverterTypeValueType.lower(value)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKeysClause: FfiConverterRustBuffer {
    typealias SwiftType = KeysClause?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeysClause.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeysClause.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransactionFilter: FfiConverterRustBuffer {
    typealias SwiftType = TransactionFilter?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeClause: FfiConverterRustBuffer {
    typealias SwiftType = Clause?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClause.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClause.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFieldElement: FfiConverterRustBuffer {
    typealias SwiftType = FieldElement?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFieldElement.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFieldElement.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeU256: FfiConverterRustBuffer {
    typealias SwiftType = U256?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeU256.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeU256.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAchievement: FfiConverterRustBuffer {
    typealias SwiftType = [Achievement]

    public static func write(_ value: [Achievement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAchievement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Achievement] {
        let len: Int32 = try readInt(&buf)
        var seq = [Achievement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAchievement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAchievementTask: FfiConverterRustBuffer {
    typealias SwiftType = [AchievementTask]

    public static func write(_ value: [AchievementTask], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAchievementTask.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AchievementTask] {
        let len: Int32 = try readInt(&buf)
        var seq = [AchievementTask]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAchievementTask.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeActionCount: FfiConverterRustBuffer {
    typealias SwiftType = [ActionCount]

    public static func write(_ value: [ActionCount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeActionCount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ActionCount] {
        let len: Int32 = try readInt(&buf)
        var seq = [ActionCount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeActionCount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeActivity: FfiConverterRustBuffer {
    typealias SwiftType = [Activity]

    public static func write(_ value: [Activity], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeActivity.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Activity] {
        let len: Int32 = try readInt(&buf)
        var seq = [Activity]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeActivity.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAggregationEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AggregationEntry]

    public static func write(_ value: [AggregationEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAggregationEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AggregationEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AggregationEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAggregationEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAttributeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [AttributeFilter]

    public static func write(_ value: [AttributeFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttributeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttributeFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttributeFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttributeFilter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeContract: FfiConverterRustBuffer {
    typealias SwiftType = [Contract]

    public static func write(_ value: [Contract], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContract.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contract] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contract]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContract.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeController: FfiConverterRustBuffer {
    typealias SwiftType = [Controller]

    public static func write(_ value: [Controller], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeController.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Controller] {
        let len: Int32 = try readInt(&buf)
        var seq = [Controller]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeController.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEntity: FfiConverterRustBuffer {
    typealias SwiftType = [Entity]

    public static func write(_ value: [Entity], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntity.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Entity] {
        let len: Int32 = try readInt(&buf)
        var seq = [Entity]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEntity.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEnumOption: FfiConverterRustBuffer {
    typealias SwiftType = [EnumOption]

    public static func write(_ value: [EnumOption], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEnumOption.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EnumOption] {
        let len: Int32 = try readInt(&buf)
        var seq = [EnumOption]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEnumOption.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMember: FfiConverterRustBuffer {
    typealias SwiftType = [Member]

    public static func write(_ value: [Member], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Member] {
        let len: Int32 = try readInt(&buf)
        var seq = [Member]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMember.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = [Message]

    public static func write(_ value: [Message], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Message] {
        let len: Int32 = try readInt(&buf)
        var seq = [Message]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeModel: FfiConverterRustBuffer {
    typealias SwiftType = [Model]

    public static func write(_ value: [Model], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeModel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Model] {
        let len: Int32 = try readInt(&buf)
        var seq = [Model]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeModel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = [OrderBy]

    public static func write(_ value: [OrderBy], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOrderBy.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OrderBy] {
        let len: Int32 = try readInt(&buf)
        var seq = [OrderBy]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOrderBy.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePlayerAchievementEntry: FfiConverterRustBuffer {
    typealias SwiftType = [PlayerAchievementEntry]

    public static func write(_ value: [PlayerAchievementEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePlayerAchievementEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PlayerAchievementEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [PlayerAchievementEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePlayerAchievementEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePlayerAchievementProgress: FfiConverterRustBuffer {
    typealias SwiftType = [PlayerAchievementProgress]

    public static func write(_ value: [PlayerAchievementProgress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePlayerAchievementProgress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PlayerAchievementProgress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PlayerAchievementProgress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePlayerAchievementProgress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSqlField: FfiConverterRustBuffer {
    typealias SwiftType = [SqlField]

    public static func write(_ value: [SqlField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSqlField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SqlField] {
        let len: Int32 = try readInt(&buf)
        var seq = [SqlField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSqlField.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSqlRow: FfiConverterRustBuffer {
    typealias SwiftType = [SqlRow]

    public static func write(_ value: [SqlRow], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSqlRow.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SqlRow] {
        let len: Int32 = try readInt(&buf)
        var seq = [SqlRow]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSqlRow.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeStruct: FfiConverterRustBuffer {
    typealias SwiftType = [Struct]

    public static func write(_ value: [Struct], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStruct.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Struct] {
        let len: Int32 = try readInt(&buf)
        var seq = [Struct]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStruct.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTaskProgress: FfiConverterRustBuffer {
    typealias SwiftType = [TaskProgress]

    public static func write(_ value: [TaskProgress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTaskProgress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TaskProgress] {
        let len: Int32 = try readInt(&buf)
        var seq = [TaskProgress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTaskProgress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeToken: FfiConverterRustBuffer {
    typealias SwiftType = [Token]

    public static func write(_ value: [Token], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeToken.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Token] {
        let len: Int32 = try readInt(&buf)
        var seq = [Token]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeToken.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTokenBalance: FfiConverterRustBuffer {
    typealias SwiftType = [TokenBalance]

    public static func write(_ value: [TokenBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTokenBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TokenBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [TokenBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTokenBalance.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTokenContract: FfiConverterRustBuffer {
    typealias SwiftType = [TokenContract]

    public static func write(_ value: [TokenContract], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTokenContract.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TokenContract] {
        let len: Int32 = try readInt(&buf)
        var seq = [TokenContract]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTokenContract.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTokenTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [TokenTransfer]

    public static func write(_ value: [TokenTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTokenTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TokenTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [TokenTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTokenTransfer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransactionCall: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionCall]

    public static func write(_ value: [TransactionCall], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionCall.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionCall] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionCall]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionCall.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWorld: FfiConverterRustBuffer {
    typealias SwiftType = [World]

    public static func write(_ value: [World], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWorld.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [World] {
        let len: Int32 = try readInt(&buf)
        var seq = [World]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWorld.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeClause: FfiConverterRustBuffer {
    typealias SwiftType = [Clause]

    public static func write(_ value: [Clause], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeClause.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Clause] {
        let len: Int32 = try readInt(&buf)
        var seq = [Clause]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeClause.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeContractType: FfiConverterRustBuffer {
    typealias SwiftType = [ContractType]

    public static func write(_ value: [ContractType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContractType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ContractType] {
        let len: Int32 = try readInt(&buf)
        var seq = [ContractType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContractType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMemberValue: FfiConverterRustBuffer {
    typealias SwiftType = [MemberValue]

    public static func write(_ value: [MemberValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMemberValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MemberValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [MemberValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMemberValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTy: FfiConverterRustBuffer {
    typealias SwiftType = [Ty]

    public static func write(_ value: [Ty], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTy.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Ty] {
        let len: Int32 = try readInt(&buf)
        var seq = [Ty]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTy.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceOptionTypeFieldElement: FfiConverterRustBuffer {
    typealias SwiftType = [FieldElement?]

    public static func write(_ value: [FieldElement?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterOptionTypeFieldElement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldElement?] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldElement?]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterOptionTypeFieldElement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFieldElement: FfiConverterRustBuffer {
    typealias SwiftType = [FieldElement]

    public static func write(_ value: [FieldElement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFieldElement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldElement] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldElement]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFieldElement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeU256: FfiConverterRustBuffer {
    typealias SwiftType = [U256]

    public static func write(_ value: [U256], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeU256.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [U256] {
        let len: Int32 = try readInt(&buf)
        var seq = [U256]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeU256.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias FieldElement = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFieldElement: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldElement {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: FieldElement, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> FieldElement {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: FieldElement) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFieldElement_lift(_ value: RustBuffer) throws -> FieldElement {
    return try FfiConverterTypeFieldElement.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFieldElement_lower(_ value: FieldElement) -> RustBuffer {
    return FfiConverterTypeFieldElement.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias U256 = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU256: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U256 {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: U256, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> U256 {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: U256) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU256_lift(_ value: RustBuffer) throws -> U256 {
    return try FfiConverterTypeU256.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU256_lower(_ value: U256) -> RustBuffer {
    return FfiConverterTypeU256.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_WAKE: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureDojoCInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                { handle, pollResult in
                    uniffiFutureContinuationCallback(handle: handle, pollResult: pollResult)
                },
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_dojo_c_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_achievements() != 53465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_activities() != 57395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_aggregations() != 38469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_contracts() != 25010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_controllers() != 20116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_entities() != 42902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_event_messages() != 61368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_player_achievements() != 7710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_publish_message() != 26581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_publish_message_batch() != 12967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_sql() != 47285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_starknet_events() != 46078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_token_balances() != 54254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_token_contracts() != 7124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_token_transfers() != 52205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_tokens() != 55378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_transactions() != 16952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_method_toriiclient_worlds() != 35445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_constructor_toriiclient_new() != 9333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_dojo_c_checksum_constructor_toriiclient_new_with_config() != 41101) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureDojoCInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all