/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "dojo.hpp"

namespace dojo {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 30;
    auto scaffolding_contract_version = ffi_dojo_uniffi_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error("UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_achievements() != 45327) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_activities() != 43349) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_aggregations() != 12858) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_cancel_subscription() != 31182) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_contracts() != 1861) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_controllers() != 55573) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_entities() != 50647) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_event_messages() != 35425) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_player_achievements() != 61773) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message() != 30179) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message_batch() != 2146) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_sql() != 38286) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_starknet_events() != 44694) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_entity_updates() != 17350) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_event_updates() != 63983) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_balance_updates() != 26741) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_updates() != 54836) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_transaction_updates() != 10040) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_token_balances() != 1716) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_token_contracts() != 49563) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_token_transfers() != 10363) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_tokens() != 10630) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_transactions() != 46460) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_toriiclient_worlds() != 23254) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_constructor_toriiclient_new() != 18057) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_constructor_toriiclient_new_with_config() != 42232) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_update() != 15850) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_error() != 340) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_update() != 13627) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_error() != 61050) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_update() != 10763) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_error() != 46610) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_update() != 40037) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_error() != 14408) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_update() != 11896) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_error() != 18113) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }

    uniffi::UniffiCallbackInterfaceEntityUpdateCallback::init();
    uniffi::UniffiCallbackInterfaceEventUpdateCallback::init();
    uniffi::UniffiCallbackInterfaceTokenBalanceUpdateCallback::init();
    uniffi::UniffiCallbackInterfaceTokenUpdateCallback::init();
    uniffi::UniffiCallbackInterfaceTransactionUpdateCallback::init();
    }

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
}

template <typename F>
void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F, typename EF, typename... Args, typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = { 0 };

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

template <typename F, typename W>
void rust_call_trait_interface(RustCallStatus* status, F make_call, W write_value) {
    initialize();

    constexpr bool has_return_type = std::negation<std::is_same<void, std::invoke_result_t<F>>>::value;

    try {
        if constexpr(has_return_type) {
            write_value(make_call());
        } else {
            make_call();
        }
    } catch (std::exception &e) {
        status->code = 2;
        status->error_buf = FfiConverterString::lower(e.what());
    }
}

template <typename E, typename W, typename F, typename EF>
void rust_call_trait_interface_with_error(RustCallStatus* status, F make_call, W write_value, EF error_cb) {
    initialize();

    constexpr bool has_return_type = std::negation<std::is_same<void, std::invoke_result_t<F>>>::value;

    try {
        try {
            if constexpr(has_return_type) {
                write_value(make_call());
            } else {
                make_call();
            }
        } catch (E &e) {
            status->code = 1;
            status->error_buf = error_cb(e);
        }
    } catch (std::exception &e) {
        status->code = 2;
        status->error_buf = FfiConverterString::lower(e.what());
    }
}


RustBuffer rustbuffer_alloc(uint64_t len) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_dojo_uniffi_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_dojo_uniffi_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = { 0 };

    ffi_dojo_uniffi_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}


uint8_t FfiConverterUInt8::lift(uint8_t val) {
    return val;
}

uint8_t FfiConverterUInt8::lower(uint8_t val) {
    return val;
}

uint8_t FfiConverterUInt8::read(RustStream &stream) {
    uint8_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt8::write(RustStream &stream, uint8_t val) {
    stream << val;
}

uint64_t FfiConverterUInt8::allocation_size(uint8_t) {
    return static_cast<uint64_t>(sizeof(uint8_t));
}
int8_t FfiConverterInt8::lift(int8_t val) {
    return val;
}

int8_t FfiConverterInt8::lower(int8_t val) {
    return val;
}

int8_t FfiConverterInt8::read(RustStream &stream) {
    int8_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt8::write(RustStream &stream, int8_t val) {
    stream << val;
}

uint64_t FfiConverterInt8::allocation_size(int8_t) {
    return static_cast<uint64_t>(sizeof(int8_t));
}
uint16_t FfiConverterUInt16::lift(uint16_t val) {
    return val;
}

uint16_t FfiConverterUInt16::lower(uint16_t val) {
    return val;
}

uint16_t FfiConverterUInt16::read(RustStream &stream) {
    uint16_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt16::write(RustStream &stream, uint16_t val) {
    stream << val;
}

uint64_t FfiConverterUInt16::allocation_size(uint16_t) {
    return static_cast<uint64_t>(sizeof(uint16_t));
}
int16_t FfiConverterInt16::lift(int16_t val) {
    return val;
}

int16_t FfiConverterInt16::lower(int16_t val) {
    return val;
}

int16_t FfiConverterInt16::read(RustStream &stream) {
    int16_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt16::write(RustStream &stream, int16_t val) {
    stream << val;
}

uint64_t FfiConverterInt16::allocation_size(int16_t) {
    return static_cast<uint64_t>(sizeof(int16_t));
}
uint32_t FfiConverterUInt32::lift(uint32_t val) {
    return val;
}

uint32_t FfiConverterUInt32::lower(uint32_t val) {
    return val;
}

uint32_t FfiConverterUInt32::read(RustStream &stream) {
    uint32_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt32::write(RustStream &stream, uint32_t val) {
    stream << val;
}

uint64_t FfiConverterUInt32::allocation_size(uint32_t) {
    return static_cast<uint64_t>(sizeof(uint32_t));
}
int32_t FfiConverterInt32::lift(int32_t val) {
    return val;
}

int32_t FfiConverterInt32::lower(int32_t val) {
    return val;
}

int32_t FfiConverterInt32::read(RustStream &stream) {
    int32_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt32::write(RustStream &stream, int32_t val) {
    stream << val;
}

uint64_t FfiConverterInt32::allocation_size(int32_t) {
    return static_cast<uint64_t>(sizeof(int32_t));
}
uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

uint64_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}
int64_t FfiConverterInt64::lift(int64_t val) {
    return val;
}

int64_t FfiConverterInt64::lower(int64_t val) {
    return val;
}

int64_t FfiConverterInt64::read(RustStream &stream) {
    int64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt64::write(RustStream &stream, int64_t val) {
    stream << val;
}

uint64_t FfiConverterInt64::allocation_size(int64_t) {
    return static_cast<uint64_t>(sizeof(int64_t));
}
double FfiConverterDouble::lift(double val) {
    return val;
}

double FfiConverterDouble::lower(double val) {
    return val;
}

double FfiConverterDouble::read(RustStream &stream) {
    double ret;
    stream >> ret;

    return ret;
}

void FfiConverterDouble::write(RustStream &stream, double val) {
    stream << val;
}

uint64_t FfiConverterDouble::allocation_size(double) {
    return static_cast<uint64_t>(sizeof(double));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

uint64_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes { len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data())) };

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

uint64_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<uint64_t>(sizeof(int32_t) + val.length());
}
} // namespace uniffi
















ToriiClient::ToriiClient(void *ptr): instance(ptr) {}

ToriiClient::ToriiClient(const ToriiClient &other) : instance(nullptr) {
    if (other.instance) {
        instance = other._uniffi_internal_clone_pointer();
    }
}




std::shared_ptr<ToriiClient> ToriiClient::init(const std::string &torii_url) {
    return std::shared_ptr<ToriiClient>(
        new ToriiClient(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_constructor_toriiclient_new,
        uniffi::FfiConverterDojoError::lift, uniffi::FfiConverterString::lower(torii_url)))
    );
}

std::shared_ptr<ToriiClient> ToriiClient::new_with_config(const std::string &torii_url, uint64_t max_message_size) {
    return std::shared_ptr<ToriiClient>(new ToriiClient(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_constructor_toriiclient_new_with_config,
        uniffi::FfiConverterDojoError::lift, uniffi::FfiConverterString::lower(torii_url), uniffi::FfiConverterUInt64::lower(max_message_size))));
}

PageAchievement ToriiClient::achievements(const AchievementQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageAchievement::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_achievements,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeAchievementQuery::lower(query)));
}
PageActivity ToriiClient::activities(const ActivityQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageActivity::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_activities,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeActivityQuery::lower(query)));
}
PageAggregationEntry ToriiClient::aggregations(const AggregationQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageAggregationEntry::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_aggregations,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeAggregationQuery::lower(query)));
}
void ToriiClient::cancel_subscription(uint64_t subscription_id) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_cancel_subscription,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterUInt64::lower(subscription_id));
}
std::vector<std::shared_ptr<Contract>> ToriiClient::contracts(const ContractQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterSequenceTypeContract::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_contracts,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeContractQuery::lower(query)));
}
PageController ToriiClient::controllers(const ControllerQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageController::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_controllers,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeControllerQuery::lower(query)));
}
PageEntity ToriiClient::entities(const Query &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageEntity::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_entities,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeQuery::lower(query)));
}
PageEntity ToriiClient::event_messages(const Query &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageEntity::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_event_messages,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeQuery::lower(query)));
}
PagePlayerAchievement ToriiClient::player_achievements(const PlayerAchievementQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePagePlayerAchievement::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_player_achievements,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypePlayerAchievementQuery::lower(query)));
}
std::string ToriiClient::publish_message(const Message &message) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_publish_message,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeMessage::lower(message)));
}
std::vector<std::string> ToriiClient::publish_message_batch(const std::vector<std::shared_ptr<Message>> &messages) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterSequenceString::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_publish_message_batch,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterSequenceTypeMessage::lower(messages)));
}
std::vector<std::shared_ptr<SqlRow>> ToriiClient::sql(const std::string &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterSequenceTypeSqlRow::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_sql,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterString::lower(query)));
}
PageEvent ToriiClient::starknet_events(const EventQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageEvent::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_starknet_events,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeEventQuery::lower(query)));
}
uint64_t ToriiClient::subscribe_entity_updates(std::optional<std::shared_ptr<Clause>> clause, const std::vector<FieldElement> &world_addresses, const std::shared_ptr<EntityUpdateCallback> &callback) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_entity_updates,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterOptionalClause::lower(clause), uniffi::FfiConverterSequenceTypeFieldElement::lower(world_addresses), uniffi::FfiConverterEntityUpdateCallback::lower(callback)));
}
uint64_t ToriiClient::subscribe_event_updates(const std::vector<std::shared_ptr<KeysClause>> &keys, const std::shared_ptr<EventUpdateCallback> &callback) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_event_updates,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterSequenceTypeKeysClause::lower(keys), uniffi::FfiConverterEventUpdateCallback::lower(callback)));
}
uint64_t ToriiClient::subscribe_token_balance_updates(const std::vector<FieldElement> &contract_addresses, const std::vector<FieldElement> &account_addresses, const std::vector<U256> &token_ids, const std::shared_ptr<TokenBalanceUpdateCallback> &callback) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_balance_updates,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterSequenceTypeFieldElement::lower(contract_addresses), uniffi::FfiConverterSequenceTypeFieldElement::lower(account_addresses), uniffi::FfiConverterSequenceTypeU256::lower(token_ids), uniffi::FfiConverterTokenBalanceUpdateCallback::lower(callback)));
}
uint64_t ToriiClient::subscribe_token_updates(const std::vector<FieldElement> &contract_addresses, const std::vector<U256> &token_ids, const std::shared_ptr<TokenUpdateCallback> &callback) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_updates,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterSequenceTypeFieldElement::lower(contract_addresses), uniffi::FfiConverterSequenceTypeU256::lower(token_ids), uniffi::FfiConverterTokenUpdateCallback::lower(callback)));
}
uint64_t ToriiClient::subscribe_transaction_updates(std::optional<std::shared_ptr<TransactionFilter>> filter, const std::shared_ptr<TransactionUpdateCallback> &callback) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_transaction_updates,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterOptionalTypeTransactionFilter::lower(filter), uniffi::FfiConverterTransactionUpdateCallback::lower(callback)));
}
PageTokenBalance ToriiClient::token_balances(const TokenBalanceQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageTokenBalance::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_token_balances,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeTokenBalanceQuery::lower(query)));
}
PageTokenContract ToriiClient::token_contracts(const TokenContractQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageTokenContract::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_token_contracts,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeTokenContractQuery::lower(query)));
}
PageTokenTransfer ToriiClient::token_transfers(const TokenTransferQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageTokenTransfer::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_token_transfers,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeTokenTransferQuery::lower(query)));
}
PageToken ToriiClient::tokens(const TokenQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageToken::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_tokens,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeTokenQuery::lower(query)));
}
PageTransaction ToriiClient::transactions(const TransactionQuery &query) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypePageTransaction::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_transactions,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterTypeTransactionQuery::lower(query)));
}
std::vector<std::shared_ptr<World>> ToriiClient::worlds(const std::vector<FieldElement> &world_addresses) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterSequenceTypeWorld::lift(uniffi::rust_call(
        uniffi_dojo_uniffi_fn_method_toriiclient_worlds,
        uniffi::FfiConverterDojoError::lift,
        ptr, uniffi::FfiConverterSequenceTypeFieldElement::lower(world_addresses)));
}

ToriiClient::~ToriiClient() {
    uniffi::rust_call(
        uniffi_dojo_uniffi_fn_free_toriiclient,
        nullptr,
        this->instance
    );
}

void *ToriiClient::_uniffi_internal_clone_pointer() const {
    return uniffi::rust_call(
        uniffi_dojo_uniffi_fn_clone_toriiclient,
        nullptr,
        this->instance
    );
}




































































































































namespace uniffi {













std::shared_ptr<ToriiClient> FfiConverterToriiClient::lift(void *ptr) {
    return std::shared_ptr<ToriiClient>(new ToriiClient(ptr));
}

void *FfiConverterToriiClient::lower(const std::shared_ptr<ToriiClient> &obj) {
    return reinterpret_cast<ToriiClient*>(obj.get())->_uniffi_internal_clone_pointer();
}

std::shared_ptr<ToriiClient> FfiConverterToriiClient::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return FfiConverterToriiClient::lift(reinterpret_cast<void *>(ptr));
}

void FfiConverterToriiClient::write(RustStream &stream, const std::shared_ptr<ToriiClient> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(FfiConverterToriiClient::lower(obj));
}

uint64_t FfiConverterToriiClient::allocation_size(const std::shared_ptr<ToriiClient> &) {
    return 8;
}


Achievement FfiConverterTypeAchievement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAchievement::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAchievement::lower(const Achievement &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAchievement::write(stream, val);

    return std::move(buf);
}

Achievement FfiConverterTypeAchievement::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterSequenceTypeAchievementTask::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeAchievement::write(RustStream &stream, const Achievement &val) {
    FfiConverterString::write(stream, val.id);
    FfiConverterTypeFieldElement::write(stream, val.world_address);
    FfiConverterString::write(stream, val.namespace_);
    FfiConverterString::write(stream, val.entity_id);
    FfiConverterBool::write(stream, val.hidden);
    FfiConverterUInt32::write(stream, val.index);
    FfiConverterUInt32::write(stream, val.points);
    FfiConverterString::write(stream, val.start);
    FfiConverterString::write(stream, val.end);
    FfiConverterString::write(stream, val.group);
    FfiConverterString::write(stream, val.icon);
    FfiConverterString::write(stream, val.title);
    FfiConverterString::write(stream, val.description);
    FfiConverterSequenceTypeAchievementTask::write(stream, val.tasks);
    FfiConverterOptionalString::write(stream, val.data);
    FfiConverterUInt32::write(stream, val.total_completions);
    FfiConverterDouble::write(stream, val.completion_rate);
    FfiConverterUInt64::write(stream, val.created_at);
    FfiConverterUInt64::write(stream, val.updated_at);
}

uint64_t FfiConverterTypeAchievement::allocation_size(const Achievement &val) {
    
    return 
        FfiConverterString::allocation_size(val.id) +
        FfiConverterTypeFieldElement::allocation_size(val.world_address) +
        FfiConverterString::allocation_size(val.namespace_) +
        FfiConverterString::allocation_size(val.entity_id) +
        FfiConverterBool::allocation_size(val.hidden) +
        FfiConverterUInt32::allocation_size(val.index) +
        FfiConverterUInt32::allocation_size(val.points) +
        FfiConverterString::allocation_size(val.start) +
        FfiConverterString::allocation_size(val.end) +
        FfiConverterString::allocation_size(val.group) +
        FfiConverterString::allocation_size(val.icon) +
        FfiConverterString::allocation_size(val.title) +
        FfiConverterString::allocation_size(val.description) +
        FfiConverterSequenceTypeAchievementTask::allocation_size(val.tasks) +
        FfiConverterOptionalString::allocation_size(val.data) +
        FfiConverterUInt32::allocation_size(val.total_completions) +
        FfiConverterDouble::allocation_size(val.completion_rate) +
        FfiConverterUInt64::allocation_size(val.created_at) +
        FfiConverterUInt64::allocation_size(val.updated_at);
    
}


AchievementProgression FfiConverterTypeAchievementProgression::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAchievementProgression::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAchievementProgression::lower(const AchievementProgression &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAchievementProgression::write(stream, val);

    return std::move(buf);
}

AchievementProgression FfiConverterTypeAchievementProgression::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeAchievementProgression::write(RustStream &stream, const AchievementProgression &val) {
    FfiConverterString::write(stream, val.id);
    FfiConverterString::write(stream, val.achievement_id);
    FfiConverterString::write(stream, val.task_id);
    FfiConverterTypeFieldElement::write(stream, val.world_address);
    FfiConverterString::write(stream, val.namespace_);
    FfiConverterTypeFieldElement::write(stream, val.player_id);
    FfiConverterUInt32::write(stream, val.count);
    FfiConverterBool::write(stream, val.completed);
    FfiConverterOptionalUInt64::write(stream, val.completed_at);
    FfiConverterUInt64::write(stream, val.created_at);
    FfiConverterUInt64::write(stream, val.updated_at);
}

uint64_t FfiConverterTypeAchievementProgression::allocation_size(const AchievementProgression &val) {
    
    return 
        FfiConverterString::allocation_size(val.id) +
        FfiConverterString::allocation_size(val.achievement_id) +
        FfiConverterString::allocation_size(val.task_id) +
        FfiConverterTypeFieldElement::allocation_size(val.world_address) +
        FfiConverterString::allocation_size(val.namespace_) +
        FfiConverterTypeFieldElement::allocation_size(val.player_id) +
        FfiConverterUInt32::allocation_size(val.count) +
        FfiConverterBool::allocation_size(val.completed) +
        FfiConverterOptionalUInt64::allocation_size(val.completed_at) +
        FfiConverterUInt64::allocation_size(val.created_at) +
        FfiConverterUInt64::allocation_size(val.updated_at);
    
}


AchievementQuery FfiConverterTypeAchievementQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAchievementQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAchievementQuery::lower(const AchievementQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAchievementQuery::write(stream, val);

    return std::move(buf);
}

AchievementQuery FfiConverterTypeAchievementQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceString::read(stream),
        FfiConverterOptionalBool::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeAchievementQuery::write(RustStream &stream, const AchievementQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.world_addresses);
    FfiConverterSequenceString::write(stream, val.namespaces);
    FfiConverterOptionalBool::write(stream, val.hidden);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeAchievementQuery::allocation_size(const AchievementQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.world_addresses) +
        FfiConverterSequenceString::allocation_size(val.namespaces) +
        FfiConverterOptionalBool::allocation_size(val.hidden) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


AchievementTask FfiConverterTypeAchievementTask::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAchievementTask::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAchievementTask::lower(const AchievementTask &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAchievementTask::write(stream, val);

    return std::move(buf);
}

AchievementTask FfiConverterTypeAchievementTask::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeAchievementTask::write(RustStream &stream, const AchievementTask &val) {
    FfiConverterString::write(stream, val.task_id);
    FfiConverterString::write(stream, val.description);
    FfiConverterUInt32::write(stream, val.total);
    FfiConverterUInt32::write(stream, val.total_completions);
    FfiConverterDouble::write(stream, val.completion_rate);
    FfiConverterUInt64::write(stream, val.created_at);
}

uint64_t FfiConverterTypeAchievementTask::allocation_size(const AchievementTask &val) {
    
    return 
        FfiConverterString::allocation_size(val.task_id) +
        FfiConverterString::allocation_size(val.description) +
        FfiConverterUInt32::allocation_size(val.total) +
        FfiConverterUInt32::allocation_size(val.total_completions) +
        FfiConverterDouble::allocation_size(val.completion_rate) +
        FfiConverterUInt64::allocation_size(val.created_at);
    
}


ActionCount FfiConverterTypeActionCount::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeActionCount::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeActionCount::lower(const ActionCount &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeActionCount::write(stream, val);

    return std::move(buf);
}

ActionCount FfiConverterTypeActionCount::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterUInt32::read(stream)
    };
}

void FfiConverterTypeActionCount::write(RustStream &stream, const ActionCount &val) {
    FfiConverterString::write(stream, val.action_name);
    FfiConverterUInt32::write(stream, val.count);
}

uint64_t FfiConverterTypeActionCount::allocation_size(const ActionCount &val) {
    
    return 
        FfiConverterString::allocation_size(val.action_name) +
        FfiConverterUInt32::allocation_size(val.count);
    
}


Activity FfiConverterTypeActivity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeActivity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeActivity::lower(const Activity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeActivity::write(stream, val);

    return std::move(buf);
}

Activity FfiConverterTypeActivity::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterSequenceTypeActionCount::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeActivity::write(RustStream &stream, const Activity &val) {
    FfiConverterString::write(stream, val.id);
    FfiConverterTypeFieldElement::write(stream, val.world_address);
    FfiConverterString::write(stream, val.namespace_);
    FfiConverterTypeFieldElement::write(stream, val.caller_address);
    FfiConverterUInt64::write(stream, val.session_start);
    FfiConverterUInt64::write(stream, val.session_end);
    FfiConverterUInt32::write(stream, val.action_count);
    FfiConverterSequenceTypeActionCount::write(stream, val.actions);
    FfiConverterUInt64::write(stream, val.updated_at);
}

uint64_t FfiConverterTypeActivity::allocation_size(const Activity &val) {
    
    return 
        FfiConverterString::allocation_size(val.id) +
        FfiConverterTypeFieldElement::allocation_size(val.world_address) +
        FfiConverterString::allocation_size(val.namespace_) +
        FfiConverterTypeFieldElement::allocation_size(val.caller_address) +
        FfiConverterUInt64::allocation_size(val.session_start) +
        FfiConverterUInt64::allocation_size(val.session_end) +
        FfiConverterUInt32::allocation_size(val.action_count) +
        FfiConverterSequenceTypeActionCount::allocation_size(val.actions) +
        FfiConverterUInt64::allocation_size(val.updated_at);
    
}


ActivityQuery FfiConverterTypeActivityQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeActivityQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeActivityQuery::lower(const ActivityQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeActivityQuery::write(stream, val);

    return std::move(buf);
}

ActivityQuery FfiConverterTypeActivityQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceString::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeActivityQuery::write(RustStream &stream, const ActivityQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.world_addresses);
    FfiConverterSequenceString::write(stream, val.namespaces);
    FfiConverterSequenceTypeFieldElement::write(stream, val.caller_addresses);
    FfiConverterOptionalUInt64::write(stream, val.from_time);
    FfiConverterOptionalUInt64::write(stream, val.to_time);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeActivityQuery::allocation_size(const ActivityQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.world_addresses) +
        FfiConverterSequenceString::allocation_size(val.namespaces) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.caller_addresses) +
        FfiConverterOptionalUInt64::allocation_size(val.from_time) +
        FfiConverterOptionalUInt64::allocation_size(val.to_time) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


AggregationEntry FfiConverterTypeAggregationEntry::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAggregationEntry::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAggregationEntry::lower(const AggregationEntry &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAggregationEntry::write(stream, val);

    return std::move(buf);
}

AggregationEntry FfiConverterTypeAggregationEntry::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeU256::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeAggregationEntry::write(RustStream &stream, const AggregationEntry &val) {
    FfiConverterString::write(stream, val.id);
    FfiConverterString::write(stream, val.aggregator_id);
    FfiConverterString::write(stream, val.entity_id);
    FfiConverterTypeU256::write(stream, val.value);
    FfiConverterString::write(stream, val.display_value);
    FfiConverterUInt64::write(stream, val.position);
    FfiConverterString::write(stream, val.model_id);
    FfiConverterUInt64::write(stream, val.created_at);
    FfiConverterUInt64::write(stream, val.updated_at);
}

uint64_t FfiConverterTypeAggregationEntry::allocation_size(const AggregationEntry &val) {
    
    return 
        FfiConverterString::allocation_size(val.id) +
        FfiConverterString::allocation_size(val.aggregator_id) +
        FfiConverterString::allocation_size(val.entity_id) +
        FfiConverterTypeU256::allocation_size(val.value) +
        FfiConverterString::allocation_size(val.display_value) +
        FfiConverterUInt64::allocation_size(val.position) +
        FfiConverterString::allocation_size(val.model_id) +
        FfiConverterUInt64::allocation_size(val.created_at) +
        FfiConverterUInt64::allocation_size(val.updated_at);
    
}


AggregationQuery FfiConverterTypeAggregationQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAggregationQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAggregationQuery::lower(const AggregationQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAggregationQuery::write(stream, val);

    return std::move(buf);
}

AggregationQuery FfiConverterTypeAggregationQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceString::read(stream),
        FfiConverterSequenceString::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeAggregationQuery::write(RustStream &stream, const AggregationQuery &val) {
    FfiConverterSequenceString::write(stream, val.aggregator_ids);
    FfiConverterSequenceString::write(stream, val.entity_ids);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeAggregationQuery::allocation_size(const AggregationQuery &val) {
    
    return 
        FfiConverterSequenceString::allocation_size(val.aggregator_ids) +
        FfiConverterSequenceString::allocation_size(val.entity_ids) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


AttributeFilter FfiConverterTypeAttributeFilter::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAttributeFilter::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAttributeFilter::lower(const AttributeFilter &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAttributeFilter::write(stream, val);

    return std::move(buf);
}

AttributeFilter FfiConverterTypeAttributeFilter::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeAttributeFilter::write(RustStream &stream, const AttributeFilter &val) {
    FfiConverterString::write(stream, val.trait_name);
    FfiConverterString::write(stream, val.trait_value);
}

uint64_t FfiConverterTypeAttributeFilter::allocation_size(const AttributeFilter &val) {
    
    return 
        FfiConverterString::allocation_size(val.trait_name) +
        FfiConverterString::allocation_size(val.trait_value);
    
}


CompositeClause FfiConverterTypeCompositeClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeCompositeClause::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeCompositeClause::lower(const CompositeClause &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeCompositeClause::write(stream, val);

    return std::move(buf);
}

CompositeClause FfiConverterTypeCompositeClause::read(RustStream &stream) {
    return {
        FfiConverterLogicalOperator::read(stream),
        FfiConverterSequenceClause::read(stream)
    };
}

void FfiConverterTypeCompositeClause::write(RustStream &stream, const CompositeClause &val) {
    FfiConverterLogicalOperator::write(stream, val.operator_);
    FfiConverterSequenceClause::write(stream, val.clauses);
}

uint64_t FfiConverterTypeCompositeClause::allocation_size(const CompositeClause &val) {
    
    return 
        FfiConverterLogicalOperator::allocation_size(val.operator_) +
        FfiConverterSequenceClause::allocation_size(val.clauses);
    
}


Contract FfiConverterTypeContract::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeContract::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeContract::lower(const Contract &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeContract::write(stream, val);

    return std::move(buf);
}

Contract FfiConverterTypeContract::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterContractType::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterOptionalTypeFieldElement::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeContract::write(RustStream &stream, const Contract &val) {
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterContractType::write(stream, val.contract_type);
    FfiConverterOptionalUInt64::write(stream, val.head);
    FfiConverterOptionalUInt64::write(stream, val.tps);
    FfiConverterOptionalUInt64::write(stream, val.last_block_timestamp);
    FfiConverterOptionalTypeFieldElement::write(stream, val.last_pending_block_tx);
    FfiConverterUInt64::write(stream, val.updated_at);
    FfiConverterUInt64::write(stream, val.created_at);
}

uint64_t FfiConverterTypeContract::allocation_size(const Contract &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterContractType::allocation_size(val.contract_type) +
        FfiConverterOptionalUInt64::allocation_size(val.head) +
        FfiConverterOptionalUInt64::allocation_size(val.tps) +
        FfiConverterOptionalUInt64::allocation_size(val.last_block_timestamp) +
        FfiConverterOptionalTypeFieldElement::allocation_size(val.last_pending_block_tx) +
        FfiConverterUInt64::allocation_size(val.updated_at) +
        FfiConverterUInt64::allocation_size(val.created_at);
    
}


ContractQuery FfiConverterTypeContractQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeContractQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeContractQuery::lower(const ContractQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeContractQuery::write(stream, val);

    return std::move(buf);
}

ContractQuery FfiConverterTypeContractQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceContractType::read(stream)
    };
}

void FfiConverterTypeContractQuery::write(RustStream &stream, const ContractQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceContractType::write(stream, val.contract_types);
}

uint64_t FfiConverterTypeContractQuery::allocation_size(const ContractQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceContractType::allocation_size(val.contract_types);
    
}


Controller FfiConverterTypeController::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeController::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeController::lower(const Controller &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeController::write(stream, val);

    return std::move(buf);
}

Controller FfiConverterTypeController::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeController::write(RustStream &stream, const Controller &val) {
    FfiConverterTypeFieldElement::write(stream, val.address);
    FfiConverterString::write(stream, val.username);
    FfiConverterUInt64::write(stream, val.deployed_at_timestamp);
}

uint64_t FfiConverterTypeController::allocation_size(const Controller &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.address) +
        FfiConverterString::allocation_size(val.username) +
        FfiConverterUInt64::allocation_size(val.deployed_at_timestamp);
    
}


ControllerQuery FfiConverterTypeControllerQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeControllerQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeControllerQuery::lower(const ControllerQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeControllerQuery::write(stream, val);

    return std::move(buf);
}

ControllerQuery FfiConverterTypeControllerQuery::read(RustStream &stream) {
    return {
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream)),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceString::read(stream)
    };
}

void FfiConverterTypeControllerQuery::write(RustStream &stream, const ControllerQuery &val) {
    FfiConverterTypePagination::write(stream, *val.pagination);
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceString::write(stream, val.usernames);
}

uint64_t FfiConverterTypeControllerQuery::allocation_size(const ControllerQuery &val) {
    
    return 
        FfiConverterTypePagination::allocation_size(*val.pagination) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceString::allocation_size(val.usernames);
    
}


Entity FfiConverterTypeEntity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEntity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEntity::lower(const Entity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEntity::write(stream, val);

    return std::move(buf);
}

Entity FfiConverterTypeEntity::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterSequenceTypeStruct::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypeEntity::write(RustStream &stream, const Entity &val) {
    FfiConverterTypeFieldElement::write(stream, val.world_address);
    FfiConverterTypeFieldElement::write(stream, val.hashed_keys);
    FfiConverterSequenceTypeStruct::write(stream, val.models);
    FfiConverterUInt64::write(stream, val.created_at);
    FfiConverterUInt64::write(stream, val.updated_at);
    FfiConverterUInt64::write(stream, val.executed_at);
}

uint64_t FfiConverterTypeEntity::allocation_size(const Entity &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.world_address) +
        FfiConverterTypeFieldElement::allocation_size(val.hashed_keys) +
        FfiConverterSequenceTypeStruct::allocation_size(val.models) +
        FfiConverterUInt64::allocation_size(val.created_at) +
        FfiConverterUInt64::allocation_size(val.updated_at) +
        FfiConverterUInt64::allocation_size(val.executed_at);
    
}


EnumOption FfiConverterTypeEnumOption::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEnumOption::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEnumOption::lower(const EnumOption &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEnumOption::write(stream, val);

    return std::move(buf);
}

EnumOption FfiConverterTypeEnumOption::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        std::make_shared<Ty>(FfiConverterTy::read(stream))
    };
}

void FfiConverterTypeEnumOption::write(RustStream &stream, const EnumOption &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterTy::write(stream, *val.ty);
}

uint64_t FfiConverterTypeEnumOption::allocation_size(const EnumOption &val) {
    
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterTy::allocation_size(*val.ty);
    
}


EnumType FfiConverterTypeEnumType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEnumType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEnumType::lower(const EnumType &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEnumType::write(stream, val);

    return std::move(buf);
}

EnumType FfiConverterTypeEnumType::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterUInt8::read(stream),
        FfiConverterSequenceTypeEnumOption::read(stream)
    };
}

void FfiConverterTypeEnumType::write(RustStream &stream, const EnumType &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterUInt8::write(stream, val.option);
    FfiConverterSequenceTypeEnumOption::write(stream, val.options);
}

uint64_t FfiConverterTypeEnumType::allocation_size(const EnumType &val) {
    
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterUInt8::allocation_size(val.option) +
        FfiConverterSequenceTypeEnumOption::allocation_size(val.options);
    
}


Event FfiConverterTypeEvent::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEvent::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEvent::lower(const Event &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEvent::write(stream, val);

    return std::move(buf);
}

Event FfiConverterTypeEvent::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream)
    };
}

void FfiConverterTypeEvent::write(RustStream &stream, const Event &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.keys);
    FfiConverterSequenceTypeFieldElement::write(stream, val.data);
    FfiConverterTypeFieldElement::write(stream, val.transaction_hash);
}

uint64_t FfiConverterTypeEvent::allocation_size(const Event &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.keys) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.data) +
        FfiConverterTypeFieldElement::allocation_size(val.transaction_hash);
    
}


EventQuery FfiConverterTypeEventQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEventQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEventQuery::lower(const EventQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEventQuery::write(stream, val);

    return std::move(buf);
}

EventQuery FfiConverterTypeEventQuery::read(RustStream &stream) {
    return {
        FfiConverterOptionalTypeKeysClause::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeEventQuery::write(RustStream &stream, const EventQuery &val) {
    FfiConverterOptionalTypeKeysClause::write(stream, val.keys);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeEventQuery::allocation_size(const EventQuery &val) {
    
    return 
        FfiConverterOptionalTypeKeysClause::allocation_size(val.keys) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


FixedSizeArray FfiConverterTypeFixedSizeArray::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFixedSizeArray::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFixedSizeArray::lower(const FixedSizeArray &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFixedSizeArray::write(stream, val);

    return std::move(buf);
}

FixedSizeArray FfiConverterTypeFixedSizeArray::read(RustStream &stream) {
    return {
        FfiConverterSequenceTy::read(stream),
        FfiConverterUInt32::read(stream)
    };
}

void FfiConverterTypeFixedSizeArray::write(RustStream &stream, const FixedSizeArray &val) {
    FfiConverterSequenceTy::write(stream, val.array);
    FfiConverterUInt32::write(stream, val.size);
}

uint64_t FfiConverterTypeFixedSizeArray::allocation_size(const FixedSizeArray &val) {
    
    return 
        FfiConverterSequenceTy::allocation_size(val.array) +
        FfiConverterUInt32::allocation_size(val.size);
    
}


KeysClause FfiConverterTypeKeysClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeKeysClause::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeKeysClause::lower(const KeysClause &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeKeysClause::write(stream, val);

    return std::move(buf);
}

KeysClause FfiConverterTypeKeysClause::read(RustStream &stream) {
    return {
        FfiConverterSequenceOptionalTypeFieldElement::read(stream),
        FfiConverterPatternMatching::read(stream),
        FfiConverterSequenceString::read(stream)
    };
}

void FfiConverterTypeKeysClause::write(RustStream &stream, const KeysClause &val) {
    FfiConverterSequenceOptionalTypeFieldElement::write(stream, val.keys);
    FfiConverterPatternMatching::write(stream, val.pattern_matching);
    FfiConverterSequenceString::write(stream, val.models);
}

uint64_t FfiConverterTypeKeysClause::allocation_size(const KeysClause &val) {
    
    return 
        FfiConverterSequenceOptionalTypeFieldElement::allocation_size(val.keys) +
        FfiConverterPatternMatching::allocation_size(val.pattern_matching) +
        FfiConverterSequenceString::allocation_size(val.models);
    
}


Member FfiConverterTypeMember::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMember::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMember::lower(const Member &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMember::write(stream, val);

    return std::move(buf);
}

Member FfiConverterTypeMember::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        std::make_shared<Ty>(FfiConverterTy::read(stream)),
        FfiConverterBool::read(stream)
    };
}

void FfiConverterTypeMember::write(RustStream &stream, const Member &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterTy::write(stream, *val.ty);
    FfiConverterBool::write(stream, val.key);
}

uint64_t FfiConverterTypeMember::allocation_size(const Member &val) {
    
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterTy::allocation_size(*val.ty) +
        FfiConverterBool::allocation_size(val.key);
    
}


MemberClause FfiConverterTypeMemberClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMemberClause::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMemberClause::lower(const MemberClause &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMemberClause::write(stream, val);

    return std::move(buf);
}

MemberClause FfiConverterTypeMemberClause::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterComparisonOperator::read(stream),
        std::make_shared<MemberValue>(FfiConverterMemberValue::read(stream))
    };
}

void FfiConverterTypeMemberClause::write(RustStream &stream, const MemberClause &val) {
    FfiConverterString::write(stream, val.model);
    FfiConverterString::write(stream, val.member);
    FfiConverterComparisonOperator::write(stream, val.operator_);
    FfiConverterMemberValue::write(stream, *val.value);
}

uint64_t FfiConverterTypeMemberClause::allocation_size(const MemberClause &val) {
    
    return 
        FfiConverterString::allocation_size(val.model) +
        FfiConverterString::allocation_size(val.member) +
        FfiConverterComparisonOperator::allocation_size(val.operator_) +
        FfiConverterMemberValue::allocation_size(*val.value);
    
}


Message FfiConverterTypeMessage::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMessage::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMessage::lower(const Message &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMessage::write(stream, val);

    return std::move(buf);
}

Message FfiConverterTypeMessage::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream)
    };
}

void FfiConverterTypeMessage::write(RustStream &stream, const Message &val) {
    FfiConverterString::write(stream, val.message);
    FfiConverterSequenceTypeFieldElement::write(stream, val.signature);
    FfiConverterTypeFieldElement::write(stream, val.world_address);
}

uint64_t FfiConverterTypeMessage::allocation_size(const Message &val) {
    
    return 
        FfiConverterString::allocation_size(val.message) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.signature) +
        FfiConverterTypeFieldElement::allocation_size(val.world_address);
    
}


Model FfiConverterTypeModel::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeModel::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeModel::lower(const Model &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeModel::write(stream, val);

    return std::move(buf);
}

Model FfiConverterTypeModel::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        std::make_shared<Ty>(FfiConverterTy::read(stream)),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterBool::read(stream)
    };
}

void FfiConverterTypeModel::write(RustStream &stream, const Model &val) {
    FfiConverterTypeFieldElement::write(stream, val.world_address);
    FfiConverterTy::write(stream, *val.schema);
    FfiConverterString::write(stream, val.namespace_);
    FfiConverterString::write(stream, val.name);
    FfiConverterTypeFieldElement::write(stream, val.selector);
    FfiConverterUInt32::write(stream, val.packed_size);
    FfiConverterUInt32::write(stream, val.unpacked_size);
    FfiConverterTypeFieldElement::write(stream, val.class_hash);
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterString::write(stream, val.layout);
    FfiConverterBool::write(stream, val.use_legacy_store);
}

uint64_t FfiConverterTypeModel::allocation_size(const Model &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.world_address) +
        FfiConverterTy::allocation_size(*val.schema) +
        FfiConverterString::allocation_size(val.namespace_) +
        FfiConverterString::allocation_size(val.name) +
        FfiConverterTypeFieldElement::allocation_size(val.selector) +
        FfiConverterUInt32::allocation_size(val.packed_size) +
        FfiConverterUInt32::allocation_size(val.unpacked_size) +
        FfiConverterTypeFieldElement::allocation_size(val.class_hash) +
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterString::allocation_size(val.layout) +
        FfiConverterBool::allocation_size(val.use_legacy_store);
    
}


OrderBy FfiConverterTypeOrderBy::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOrderBy::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOrderBy::lower(const OrderBy &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOrderBy::write(stream, val);

    return std::move(buf);
}

OrderBy FfiConverterTypeOrderBy::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterOrderDirection::read(stream)
    };
}

void FfiConverterTypeOrderBy::write(RustStream &stream, const OrderBy &val) {
    FfiConverterString::write(stream, val.field);
    FfiConverterOrderDirection::write(stream, val.direction);
}

uint64_t FfiConverterTypeOrderBy::allocation_size(const OrderBy &val) {
    
    return 
        FfiConverterString::allocation_size(val.field) +
        FfiConverterOrderDirection::allocation_size(val.direction);
    
}


PageAchievement FfiConverterTypePageAchievement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageAchievement::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageAchievement::lower(const PageAchievement &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageAchievement::write(stream, val);

    return std::move(buf);
}

PageAchievement FfiConverterTypePageAchievement::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeAchievement::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageAchievement::write(RustStream &stream, const PageAchievement &val) {
    FfiConverterSequenceTypeAchievement::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageAchievement::allocation_size(const PageAchievement &val) {
    
    return 
        FfiConverterSequenceTypeAchievement::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageActivity FfiConverterTypePageActivity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageActivity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageActivity::lower(const PageActivity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageActivity::write(stream, val);

    return std::move(buf);
}

PageActivity FfiConverterTypePageActivity::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeActivity::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageActivity::write(RustStream &stream, const PageActivity &val) {
    FfiConverterSequenceTypeActivity::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageActivity::allocation_size(const PageActivity &val) {
    
    return 
        FfiConverterSequenceTypeActivity::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageAggregationEntry FfiConverterTypePageAggregationEntry::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageAggregationEntry::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageAggregationEntry::lower(const PageAggregationEntry &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageAggregationEntry::write(stream, val);

    return std::move(buf);
}

PageAggregationEntry FfiConverterTypePageAggregationEntry::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeAggregationEntry::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageAggregationEntry::write(RustStream &stream, const PageAggregationEntry &val) {
    FfiConverterSequenceTypeAggregationEntry::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageAggregationEntry::allocation_size(const PageAggregationEntry &val) {
    
    return 
        FfiConverterSequenceTypeAggregationEntry::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageController FfiConverterTypePageController::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageController::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageController::lower(const PageController &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageController::write(stream, val);

    return std::move(buf);
}

PageController FfiConverterTypePageController::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeController::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageController::write(RustStream &stream, const PageController &val) {
    FfiConverterSequenceTypeController::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageController::allocation_size(const PageController &val) {
    
    return 
        FfiConverterSequenceTypeController::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageEntity FfiConverterTypePageEntity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageEntity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageEntity::lower(const PageEntity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageEntity::write(stream, val);

    return std::move(buf);
}

PageEntity FfiConverterTypePageEntity::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeEntity::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageEntity::write(RustStream &stream, const PageEntity &val) {
    FfiConverterSequenceTypeEntity::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageEntity::allocation_size(const PageEntity &val) {
    
    return 
        FfiConverterSequenceTypeEntity::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageEvent FfiConverterTypePageEvent::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageEvent::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageEvent::lower(const PageEvent &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageEvent::write(stream, val);

    return std::move(buf);
}

PageEvent FfiConverterTypePageEvent::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeEvent::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageEvent::write(RustStream &stream, const PageEvent &val) {
    FfiConverterSequenceTypeEvent::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageEvent::allocation_size(const PageEvent &val) {
    
    return 
        FfiConverterSequenceTypeEvent::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PagePlayerAchievement FfiConverterTypePagePlayerAchievement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePagePlayerAchievement::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePagePlayerAchievement::lower(const PagePlayerAchievement &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePagePlayerAchievement::write(stream, val);

    return std::move(buf);
}

PagePlayerAchievement FfiConverterTypePagePlayerAchievement::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypePlayerAchievementEntry::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePagePlayerAchievement::write(RustStream &stream, const PagePlayerAchievement &val) {
    FfiConverterSequenceTypePlayerAchievementEntry::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePagePlayerAchievement::allocation_size(const PagePlayerAchievement &val) {
    
    return 
        FfiConverterSequenceTypePlayerAchievementEntry::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageToken FfiConverterTypePageToken::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageToken::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageToken::lower(const PageToken &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageToken::write(stream, val);

    return std::move(buf);
}

PageToken FfiConverterTypePageToken::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeToken::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageToken::write(RustStream &stream, const PageToken &val) {
    FfiConverterSequenceTypeToken::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageToken::allocation_size(const PageToken &val) {
    
    return 
        FfiConverterSequenceTypeToken::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageTokenBalance FfiConverterTypePageTokenBalance::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageTokenBalance::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageTokenBalance::lower(const PageTokenBalance &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageTokenBalance::write(stream, val);

    return std::move(buf);
}

PageTokenBalance FfiConverterTypePageTokenBalance::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeTokenBalance::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageTokenBalance::write(RustStream &stream, const PageTokenBalance &val) {
    FfiConverterSequenceTypeTokenBalance::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageTokenBalance::allocation_size(const PageTokenBalance &val) {
    
    return 
        FfiConverterSequenceTypeTokenBalance::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageTokenContract FfiConverterTypePageTokenContract::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageTokenContract::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageTokenContract::lower(const PageTokenContract &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageTokenContract::write(stream, val);

    return std::move(buf);
}

PageTokenContract FfiConverterTypePageTokenContract::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeTokenContract::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageTokenContract::write(RustStream &stream, const PageTokenContract &val) {
    FfiConverterSequenceTypeTokenContract::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageTokenContract::allocation_size(const PageTokenContract &val) {
    
    return 
        FfiConverterSequenceTypeTokenContract::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageTokenTransfer FfiConverterTypePageTokenTransfer::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageTokenTransfer::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageTokenTransfer::lower(const PageTokenTransfer &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageTokenTransfer::write(stream, val);

    return std::move(buf);
}

PageTokenTransfer FfiConverterTypePageTokenTransfer::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeTokenTransfer::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageTokenTransfer::write(RustStream &stream, const PageTokenTransfer &val) {
    FfiConverterSequenceTypeTokenTransfer::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageTokenTransfer::allocation_size(const PageTokenTransfer &val) {
    
    return 
        FfiConverterSequenceTypeTokenTransfer::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


PageTransaction FfiConverterTypePageTransaction::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePageTransaction::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePageTransaction::lower(const PageTransaction &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePageTransaction::write(stream, val);

    return std::move(buf);
}

PageTransaction FfiConverterTypePageTransaction::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeTransaction::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypePageTransaction::write(RustStream &stream, const PageTransaction &val) {
    FfiConverterSequenceTypeTransaction::write(stream, val.items);
    FfiConverterOptionalString::write(stream, val.next_cursor);
}

uint64_t FfiConverterTypePageTransaction::allocation_size(const PageTransaction &val) {
    
    return 
        FfiConverterSequenceTypeTransaction::allocation_size(val.items) +
        FfiConverterOptionalString::allocation_size(val.next_cursor);
    
}


Pagination FfiConverterTypePagination::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePagination::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePagination::lower(const Pagination &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePagination::write(stream, val);

    return std::move(buf);
}

Pagination FfiConverterTypePagination::read(RustStream &stream) {
    return {
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalUInt32::read(stream),
        FfiConverterPaginationDirection::read(stream),
        FfiConverterSequenceTypeOrderBy::read(stream)
    };
}

void FfiConverterTypePagination::write(RustStream &stream, const Pagination &val) {
    FfiConverterOptionalString::write(stream, val.cursor);
    FfiConverterOptionalUInt32::write(stream, val.limit);
    FfiConverterPaginationDirection::write(stream, val.direction);
    FfiConverterSequenceTypeOrderBy::write(stream, val.order_by);
}

uint64_t FfiConverterTypePagination::allocation_size(const Pagination &val) {
    
    return 
        FfiConverterOptionalString::allocation_size(val.cursor) +
        FfiConverterOptionalUInt32::allocation_size(val.limit) +
        FfiConverterPaginationDirection::allocation_size(val.direction) +
        FfiConverterSequenceTypeOrderBy::allocation_size(val.order_by);
    
}


PlayerAchievementEntry FfiConverterTypePlayerAchievementEntry::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePlayerAchievementEntry::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePlayerAchievementEntry::lower(const PlayerAchievementEntry &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePlayerAchievementEntry::write(stream, val);

    return std::move(buf);
}

PlayerAchievementEntry FfiConverterTypePlayerAchievementEntry::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        std::make_shared<PlayerAchievementStats>(FfiConverterTypePlayerAchievementStats::read(stream)),
        FfiConverterSequenceTypePlayerAchievementProgress::read(stream)
    };
}

void FfiConverterTypePlayerAchievementEntry::write(RustStream &stream, const PlayerAchievementEntry &val) {
    FfiConverterTypeFieldElement::write(stream, val.player_address);
    FfiConverterTypePlayerAchievementStats::write(stream, *val.stats);
    FfiConverterSequenceTypePlayerAchievementProgress::write(stream, val.achievements);
}

uint64_t FfiConverterTypePlayerAchievementEntry::allocation_size(const PlayerAchievementEntry &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.player_address) +
        FfiConverterTypePlayerAchievementStats::allocation_size(*val.stats) +
        FfiConverterSequenceTypePlayerAchievementProgress::allocation_size(val.achievements);
    
}


PlayerAchievementProgress FfiConverterTypePlayerAchievementProgress::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePlayerAchievementProgress::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePlayerAchievementProgress::lower(const PlayerAchievementProgress &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePlayerAchievementProgress::write(stream, val);

    return std::move(buf);
}

PlayerAchievementProgress FfiConverterTypePlayerAchievementProgress::read(RustStream &stream) {
    return {
        std::make_shared<Achievement>(FfiConverterTypeAchievement::read(stream)),
        FfiConverterSequenceTypeTaskProgress::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterDouble::read(stream)
    };
}

void FfiConverterTypePlayerAchievementProgress::write(RustStream &stream, const PlayerAchievementProgress &val) {
    FfiConverterTypeAchievement::write(stream, *val.achievement);
    FfiConverterSequenceTypeTaskProgress::write(stream, val.task_progress);
    FfiConverterBool::write(stream, val.completed);
    FfiConverterDouble::write(stream, val.progress_percentage);
}

uint64_t FfiConverterTypePlayerAchievementProgress::allocation_size(const PlayerAchievementProgress &val) {
    
    return 
        FfiConverterTypeAchievement::allocation_size(*val.achievement) +
        FfiConverterSequenceTypeTaskProgress::allocation_size(val.task_progress) +
        FfiConverterBool::allocation_size(val.completed) +
        FfiConverterDouble::allocation_size(val.progress_percentage);
    
}


PlayerAchievementQuery FfiConverterTypePlayerAchievementQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePlayerAchievementQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePlayerAchievementQuery::lower(const PlayerAchievementQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePlayerAchievementQuery::write(stream, val);

    return std::move(buf);
}

PlayerAchievementQuery FfiConverterTypePlayerAchievementQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceString::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypePlayerAchievementQuery::write(RustStream &stream, const PlayerAchievementQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.world_addresses);
    FfiConverterSequenceString::write(stream, val.namespaces);
    FfiConverterSequenceTypeFieldElement::write(stream, val.player_addresses);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypePlayerAchievementQuery::allocation_size(const PlayerAchievementQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.world_addresses) +
        FfiConverterSequenceString::allocation_size(val.namespaces) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.player_addresses) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


PlayerAchievementStats FfiConverterTypePlayerAchievementStats::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePlayerAchievementStats::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePlayerAchievementStats::lower(const PlayerAchievementStats &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePlayerAchievementStats::write(stream, val);

    return std::move(buf);
}

PlayerAchievementStats FfiConverterTypePlayerAchievementStats::read(RustStream &stream) {
    return {
        FfiConverterUInt32::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterUInt64::read(stream)
    };
}

void FfiConverterTypePlayerAchievementStats::write(RustStream &stream, const PlayerAchievementStats &val) {
    FfiConverterUInt32::write(stream, val.total_points);
    FfiConverterUInt32::write(stream, val.completed_achievements);
    FfiConverterUInt32::write(stream, val.total_achievements);
    FfiConverterDouble::write(stream, val.completion_percentage);
    FfiConverterOptionalUInt64::write(stream, val.last_achievement_at);
    FfiConverterUInt64::write(stream, val.created_at);
    FfiConverterUInt64::write(stream, val.updated_at);
}

uint64_t FfiConverterTypePlayerAchievementStats::allocation_size(const PlayerAchievementStats &val) {
    
    return 
        FfiConverterUInt32::allocation_size(val.total_points) +
        FfiConverterUInt32::allocation_size(val.completed_achievements) +
        FfiConverterUInt32::allocation_size(val.total_achievements) +
        FfiConverterDouble::allocation_size(val.completion_percentage) +
        FfiConverterOptionalUInt64::allocation_size(val.last_achievement_at) +
        FfiConverterUInt64::allocation_size(val.created_at) +
        FfiConverterUInt64::allocation_size(val.updated_at);
    
}


Query FfiConverterTypeQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeQuery::lower(const Query &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeQuery::write(stream, val);

    return std::move(buf);
}

Query FfiConverterTypeQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream)),
        FfiConverterOptionalClause::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterSequenceString::read(stream),
        FfiConverterBool::read(stream)
    };
}

void FfiConverterTypeQuery::write(RustStream &stream, const Query &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.world_addresses);
    FfiConverterTypePagination::write(stream, *val.pagination);
    FfiConverterOptionalClause::write(stream, val.clause);
    FfiConverterBool::write(stream, val.no_hashed_keys);
    FfiConverterSequenceString::write(stream, val.models);
    FfiConverterBool::write(stream, val.historical);
}

uint64_t FfiConverterTypeQuery::allocation_size(const Query &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.world_addresses) +
        FfiConverterTypePagination::allocation_size(*val.pagination) +
        FfiConverterOptionalClause::allocation_size(val.clause) +
        FfiConverterBool::allocation_size(val.no_hashed_keys) +
        FfiConverterSequenceString::allocation_size(val.models) +
        FfiConverterBool::allocation_size(val.historical);
    
}


Signature FfiConverterTypeSignature::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSignature::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSignature::lower(const Signature &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSignature::write(stream, val);

    return std::move(buf);
}

Signature FfiConverterTypeSignature::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream)
    };
}

void FfiConverterTypeSignature::write(RustStream &stream, const Signature &val) {
    FfiConverterTypeFieldElement::write(stream, val.r);
    FfiConverterTypeFieldElement::write(stream, val.s);
}

uint64_t FfiConverterTypeSignature::allocation_size(const Signature &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.r) +
        FfiConverterTypeFieldElement::allocation_size(val.s);
    
}


SqlField FfiConverterTypeSqlField::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSqlField::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSqlField::lower(const SqlField &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSqlField::write(stream, val);

    return std::move(buf);
}

SqlField FfiConverterTypeSqlField::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        std::make_shared<SqlValue>(FfiConverterSqlValue::read(stream))
    };
}

void FfiConverterTypeSqlField::write(RustStream &stream, const SqlField &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterSqlValue::write(stream, *val.value);
}

uint64_t FfiConverterTypeSqlField::allocation_size(const SqlField &val) {
    
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterSqlValue::allocation_size(*val.value);
    
}


SqlRow FfiConverterTypeSqlRow::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSqlRow::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSqlRow::lower(const SqlRow &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSqlRow::write(stream, val);

    return std::move(buf);
}

SqlRow FfiConverterTypeSqlRow::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeSqlField::read(stream)
    };
}

void FfiConverterTypeSqlRow::write(RustStream &stream, const SqlRow &val) {
    FfiConverterSequenceTypeSqlField::write(stream, val.fields);
}

uint64_t FfiConverterTypeSqlRow::allocation_size(const SqlRow &val) {
    
    return 
        FfiConverterSequenceTypeSqlField::allocation_size(val.fields);
    
}


Struct FfiConverterTypeStruct::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStruct::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStruct::lower(const Struct &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStruct::write(stream, val);

    return std::move(buf);
}

Struct FfiConverterTypeStruct::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterSequenceTypeMember::read(stream)
    };
}

void FfiConverterTypeStruct::write(RustStream &stream, const Struct &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterSequenceTypeMember::write(stream, val.children);
}

uint64_t FfiConverterTypeStruct::allocation_size(const Struct &val) {
    
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterSequenceTypeMember::allocation_size(val.children);
    
}


TaskProgress FfiConverterTypeTaskProgress::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTaskProgress::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTaskProgress::lower(const TaskProgress &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTaskProgress::write(stream, val);

    return std::move(buf);
}

TaskProgress FfiConverterTypeTaskProgress::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterBool::read(stream)
    };
}

void FfiConverterTypeTaskProgress::write(RustStream &stream, const TaskProgress &val) {
    FfiConverterString::write(stream, val.task_id);
    FfiConverterUInt32::write(stream, val.count);
    FfiConverterBool::write(stream, val.completed);
}

uint64_t FfiConverterTypeTaskProgress::allocation_size(const TaskProgress &val) {
    
    return 
        FfiConverterString::allocation_size(val.task_id) +
        FfiConverterUInt32::allocation_size(val.count) +
        FfiConverterBool::allocation_size(val.completed);
    
}


Token FfiConverterTypeToken::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeToken::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeToken::lower(const Token &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeToken::write(stream, val);

    return std::move(buf);
}

Token FfiConverterTypeToken::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterOptionalTypeU256::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt8::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalTypeU256::read(stream)
    };
}

void FfiConverterTypeToken::write(RustStream &stream, const Token &val) {
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterOptionalTypeU256::write(stream, val.token_id);
    FfiConverterString::write(stream, val.name);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterUInt8::write(stream, val.decimals);
    FfiConverterString::write(stream, val.metadata);
    FfiConverterOptionalTypeU256::write(stream, val.total_supply);
}

uint64_t FfiConverterTypeToken::allocation_size(const Token &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterOptionalTypeU256::allocation_size(val.token_id) +
        FfiConverterString::allocation_size(val.name) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterUInt8::allocation_size(val.decimals) +
        FfiConverterString::allocation_size(val.metadata) +
        FfiConverterOptionalTypeU256::allocation_size(val.total_supply);
    
}


TokenBalance FfiConverterTypeTokenBalance::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenBalance::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenBalance::lower(const TokenBalance &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenBalance::write(stream, val);

    return std::move(buf);
}

TokenBalance FfiConverterTypeTokenBalance::read(RustStream &stream) {
    return {
        FfiConverterTypeU256::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterOptionalTypeU256::read(stream)
    };
}

void FfiConverterTypeTokenBalance::write(RustStream &stream, const TokenBalance &val) {
    FfiConverterTypeU256::write(stream, val.balance);
    FfiConverterTypeFieldElement::write(stream, val.account_address);
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterOptionalTypeU256::write(stream, val.token_id);
}

uint64_t FfiConverterTypeTokenBalance::allocation_size(const TokenBalance &val) {
    
    return 
        FfiConverterTypeU256::allocation_size(val.balance) +
        FfiConverterTypeFieldElement::allocation_size(val.account_address) +
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterOptionalTypeU256::allocation_size(val.token_id);
    
}


TokenBalanceQuery FfiConverterTypeTokenBalanceQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenBalanceQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenBalanceQuery::lower(const TokenBalanceQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenBalanceQuery::write(stream, val);

    return std::move(buf);
}

TokenBalanceQuery FfiConverterTypeTokenBalanceQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeU256::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeTokenBalanceQuery::write(RustStream &stream, const TokenBalanceQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceTypeFieldElement::write(stream, val.account_addresses);
    FfiConverterSequenceTypeU256::write(stream, val.token_ids);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeTokenBalanceQuery::allocation_size(const TokenBalanceQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.account_addresses) +
        FfiConverterSequenceTypeU256::allocation_size(val.token_ids) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


TokenContract FfiConverterTypeTokenContract::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenContract::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenContract::lower(const TokenContract &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenContract::write(stream, val);

    return std::move(buf);
}

TokenContract FfiConverterTypeTokenContract::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt8::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalTypeU256::read(stream)
    };
}

void FfiConverterTypeTokenContract::write(RustStream &stream, const TokenContract &val) {
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterString::write(stream, val.name);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterUInt8::write(stream, val.decimals);
    FfiConverterString::write(stream, val.metadata);
    FfiConverterString::write(stream, val.token_metadata);
    FfiConverterOptionalTypeU256::write(stream, val.total_supply);
}

uint64_t FfiConverterTypeTokenContract::allocation_size(const TokenContract &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterString::allocation_size(val.name) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterUInt8::allocation_size(val.decimals) +
        FfiConverterString::allocation_size(val.metadata) +
        FfiConverterString::allocation_size(val.token_metadata) +
        FfiConverterOptionalTypeU256::allocation_size(val.total_supply);
    
}


TokenContractQuery FfiConverterTypeTokenContractQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenContractQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenContractQuery::lower(const TokenContractQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenContractQuery::write(stream, val);

    return std::move(buf);
}

TokenContractQuery FfiConverterTypeTokenContractQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceContractType::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeTokenContractQuery::write(RustStream &stream, const TokenContractQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceContractType::write(stream, val.contract_types);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeTokenContractQuery::allocation_size(const TokenContractQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceContractType::allocation_size(val.contract_types) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


TokenQuery FfiConverterTypeTokenQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenQuery::lower(const TokenQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenQuery::write(stream, val);

    return std::move(buf);
}

TokenQuery FfiConverterTypeTokenQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeU256::read(stream),
        FfiConverterSequenceTypeAttributeFilter::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeTokenQuery::write(RustStream &stream, const TokenQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceTypeU256::write(stream, val.token_ids);
    FfiConverterSequenceTypeAttributeFilter::write(stream, val.attribute_filters);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeTokenQuery::allocation_size(const TokenQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceTypeU256::allocation_size(val.token_ids) +
        FfiConverterSequenceTypeAttributeFilter::allocation_size(val.attribute_filters) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


TokenTransfer FfiConverterTypeTokenTransfer::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenTransfer::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenTransfer::lower(const TokenTransfer &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenTransfer::write(stream, val);

    return std::move(buf);
}

TokenTransfer FfiConverterTypeTokenTransfer::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeU256::read(stream),
        FfiConverterOptionalTypeU256::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeTokenTransfer::write(RustStream &stream, const TokenTransfer &val) {
    FfiConverterString::write(stream, val.id);
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterTypeFieldElement::write(stream, val.from_address);
    FfiConverterTypeFieldElement::write(stream, val.to_address);
    FfiConverterTypeU256::write(stream, val.amount);
    FfiConverterOptionalTypeU256::write(stream, val.token_id);
    FfiConverterUInt64::write(stream, val.executed_at);
    FfiConverterOptionalString::write(stream, val.event_id);
}

uint64_t FfiConverterTypeTokenTransfer::allocation_size(const TokenTransfer &val) {
    
    return 
        FfiConverterString::allocation_size(val.id) +
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterTypeFieldElement::allocation_size(val.from_address) +
        FfiConverterTypeFieldElement::allocation_size(val.to_address) +
        FfiConverterTypeU256::allocation_size(val.amount) +
        FfiConverterOptionalTypeU256::allocation_size(val.token_id) +
        FfiConverterUInt64::allocation_size(val.executed_at) +
        FfiConverterOptionalString::allocation_size(val.event_id);
    
}


TokenTransferQuery FfiConverterTypeTokenTransferQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTokenTransferQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTokenTransferQuery::lower(const TokenTransferQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTokenTransferQuery::write(stream, val);

    return std::move(buf);
}

TokenTransferQuery FfiConverterTypeTokenTransferQuery::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeU256::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeTokenTransferQuery::write(RustStream &stream, const TokenTransferQuery &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceTypeFieldElement::write(stream, val.account_addresses);
    FfiConverterSequenceTypeU256::write(stream, val.token_ids);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeTokenTransferQuery::allocation_size(const TokenTransferQuery &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.account_addresses) +
        FfiConverterSequenceTypeU256::allocation_size(val.token_ids) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


Transaction FfiConverterTypeTransaction::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTransaction::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTransaction::lower(const Transaction &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTransaction::write(stream, val);

    return std::move(buf);
}

Transaction FfiConverterTypeTransaction::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterString::read(stream),
        FfiConverterUInt64::read(stream),
        FfiConverterSequenceTypeTransactionCall::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream)
    };
}

void FfiConverterTypeTransaction::write(RustStream &stream, const Transaction &val) {
    FfiConverterTypeFieldElement::write(stream, val.transaction_hash);
    FfiConverterTypeFieldElement::write(stream, val.sender_address);
    FfiConverterSequenceTypeFieldElement::write(stream, val.calldata);
    FfiConverterTypeFieldElement::write(stream, val.max_fee);
    FfiConverterSequenceTypeFieldElement::write(stream, val.signature);
    FfiConverterTypeFieldElement::write(stream, val.nonce);
    FfiConverterUInt64::write(stream, val.block_number);
    FfiConverterString::write(stream, val.transaction_type);
    FfiConverterUInt64::write(stream, val.block_timestamp);
    FfiConverterSequenceTypeTransactionCall::write(stream, val.calls);
    FfiConverterSequenceTypeFieldElement::write(stream, val.unique_models);
}

uint64_t FfiConverterTypeTransaction::allocation_size(const Transaction &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.transaction_hash) +
        FfiConverterTypeFieldElement::allocation_size(val.sender_address) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.calldata) +
        FfiConverterTypeFieldElement::allocation_size(val.max_fee) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.signature) +
        FfiConverterTypeFieldElement::allocation_size(val.nonce) +
        FfiConverterUInt64::allocation_size(val.block_number) +
        FfiConverterString::allocation_size(val.transaction_type) +
        FfiConverterUInt64::allocation_size(val.block_timestamp) +
        FfiConverterSequenceTypeTransactionCall::allocation_size(val.calls) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.unique_models);
    
}


TransactionCall FfiConverterTypeTransactionCall::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTransactionCall::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTransactionCall::lower(const TransactionCall &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTransactionCall::write(stream, val);

    return std::move(buf);
}

TransactionCall FfiConverterTypeTransactionCall::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterCallType::read(stream),
        FfiConverterTypeFieldElement::read(stream)
    };
}

void FfiConverterTypeTransactionCall::write(RustStream &stream, const TransactionCall &val) {
    FfiConverterTypeFieldElement::write(stream, val.contract_address);
    FfiConverterString::write(stream, val.entrypoint);
    FfiConverterSequenceTypeFieldElement::write(stream, val.calldata);
    FfiConverterCallType::write(stream, val.call_type);
    FfiConverterTypeFieldElement::write(stream, val.caller_address);
}

uint64_t FfiConverterTypeTransactionCall::allocation_size(const TransactionCall &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.contract_address) +
        FfiConverterString::allocation_size(val.entrypoint) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.calldata) +
        FfiConverterCallType::allocation_size(val.call_type) +
        FfiConverterTypeFieldElement::allocation_size(val.caller_address);
    
}


TransactionFilter FfiConverterTypeTransactionFilter::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTransactionFilter::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTransactionFilter::lower(const TransactionFilter &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTransactionFilter::write(stream, val);

    return std::move(buf);
}

TransactionFilter FfiConverterTypeTransactionFilter::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterSequenceString::read(stream),
        FfiConverterSequenceTypeFieldElement::read(stream),
        FfiConverterOptionalUInt64::read(stream),
        FfiConverterOptionalUInt64::read(stream)
    };
}

void FfiConverterTypeTransactionFilter::write(RustStream &stream, const TransactionFilter &val) {
    FfiConverterSequenceTypeFieldElement::write(stream, val.transaction_hashes);
    FfiConverterSequenceTypeFieldElement::write(stream, val.caller_addresses);
    FfiConverterSequenceTypeFieldElement::write(stream, val.contract_addresses);
    FfiConverterSequenceString::write(stream, val.entrypoints);
    FfiConverterSequenceTypeFieldElement::write(stream, val.model_selectors);
    FfiConverterOptionalUInt64::write(stream, val.from_block);
    FfiConverterOptionalUInt64::write(stream, val.to_block);
}

uint64_t FfiConverterTypeTransactionFilter::allocation_size(const TransactionFilter &val) {
    
    return 
        FfiConverterSequenceTypeFieldElement::allocation_size(val.transaction_hashes) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.caller_addresses) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.contract_addresses) +
        FfiConverterSequenceString::allocation_size(val.entrypoints) +
        FfiConverterSequenceTypeFieldElement::allocation_size(val.model_selectors) +
        FfiConverterOptionalUInt64::allocation_size(val.from_block) +
        FfiConverterOptionalUInt64::allocation_size(val.to_block);
    
}


TransactionQuery FfiConverterTypeTransactionQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTransactionQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTransactionQuery::lower(const TransactionQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTransactionQuery::write(stream, val);

    return std::move(buf);
}

TransactionQuery FfiConverterTypeTransactionQuery::read(RustStream &stream) {
    return {
        FfiConverterOptionalTypeTransactionFilter::read(stream),
        std::make_shared<Pagination>(FfiConverterTypePagination::read(stream))
    };
}

void FfiConverterTypeTransactionQuery::write(RustStream &stream, const TransactionQuery &val) {
    FfiConverterOptionalTypeTransactionFilter::write(stream, val.filter);
    FfiConverterTypePagination::write(stream, *val.pagination);
}

uint64_t FfiConverterTypeTransactionQuery::allocation_size(const TransactionQuery &val) {
    
    return 
        FfiConverterOptionalTypeTransactionFilter::allocation_size(val.filter) +
        FfiConverterTypePagination::allocation_size(*val.pagination);
    
}


World FfiConverterTypeWorld::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeWorld::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeWorld::lower(const World &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeWorld::write(stream, val);

    return std::move(buf);
}

World FfiConverterTypeWorld::read(RustStream &stream) {
    return {
        FfiConverterTypeFieldElement::read(stream),
        FfiConverterSequenceTypeModel::read(stream)
    };
}

void FfiConverterTypeWorld::write(RustStream &stream, const World &val) {
    FfiConverterTypeFieldElement::write(stream, val.world_address);
    FfiConverterSequenceTypeModel::write(stream, val.models);
}

uint64_t FfiConverterTypeWorld::allocation_size(const World &val) {
    
    return 
        FfiConverterTypeFieldElement::allocation_size(val.world_address) +
        FfiConverterSequenceTypeModel::allocation_size(val.models);
    
}


CallType FfiConverterCallType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterCallType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterCallType::lower(const CallType &val) {
    auto buf = rustbuffer_alloc(FfiConverterCallType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterCallType::write(stream, val);

    return std::move(buf);
}

CallType FfiConverterCallType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return CallType::kExecute;
        
    case 2:
        return CallType::kExecuteFromOutside;
        
    default:
        throw std::runtime_error("No matching CallType variant");
    }
}

void FfiConverterCallType::write(RustStream &stream, const CallType &val) {
    switch (val) {
        
    case CallType::kExecute:
        stream << static_cast<int32_t>(1);
        break;
        
    case CallType::kExecuteFromOutside:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching CallType variant");
    }
}

uint64_t FfiConverterCallType::allocation_size(const CallType &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


Clause FfiConverterClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterClause::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterClause::lower(const Clause &val) {
    auto buf = rustbuffer_alloc(FfiConverterClause::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterClause::write(stream, val);

    return std::move(buf);
}

Clause FfiConverterClause::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {
        
    case 1:
        return Clause::kHashedKeys {
            .keys = FfiConverterSequenceTypeFieldElement::read(stream),
        };
        
    case 2:
        return Clause::kKeys {
            .clause = std::make_shared<KeysClause>(FfiConverterTypeKeysClause::read(stream)),
        };
        
    case 3:
        return Clause::kMember {
            .clause = std::make_shared<MemberClause>(FfiConverterTypeMemberClause::read(stream)),
        };
        
    case 4:
        return Clause::kComposite {
            .clause = std::make_shared<CompositeClause>(FfiConverterTypeCompositeClause::read(stream)),
        };
        
    default:
        throw std::runtime_error("No matching Clause variant");
    }
}

void FfiConverterClause::write(RustStream &stream, const Clause &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, Clause::kHashedKeys>) {
            FfiConverterSequenceTypeFieldElement::write(stream, arg.keys);
        }
        else if constexpr (std::is_same_v<T, Clause::kKeys>) {
            FfiConverterTypeKeysClause::write(stream, *arg.clause);
        }
        else if constexpr (std::is_same_v<T, Clause::kMember>) {
            FfiConverterTypeMemberClause::write(stream, *arg.clause);
        }
        else if constexpr (std::is_same_v<T, Clause::kComposite>) {
            FfiConverterTypeCompositeClause::write(stream, *arg.clause);
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive Clause visitor");
        }
    }, val.variant);
}

uint64_t FfiConverterClause::allocation_size(const Clause &val) {
    uint64_t size = sizeof(int32_t);

    size += std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, Clause::kHashedKeys>) {
            uint64_t size = 0;
            size += FfiConverterSequenceTypeFieldElement::allocation_size(arg.keys);
            return size;
        }
        else if constexpr (std::is_same_v<T, Clause::kKeys>) {
            uint64_t size = 0;
            size += FfiConverterTypeKeysClause::allocation_size(*arg.clause);
            return size;
        }
        else if constexpr (std::is_same_v<T, Clause::kMember>) {
            uint64_t size = 0;
            size += FfiConverterTypeMemberClause::allocation_size(*arg.clause);
            return size;
        }
        else if constexpr (std::is_same_v<T, Clause::kComposite>) {
            uint64_t size = 0;
            size += FfiConverterTypeCompositeClause::allocation_size(*arg.clause);
            return size;
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive Clause visitor");
        }
    }, val.variant);

    return size;
}


ComparisonOperator FfiConverterComparisonOperator::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterComparisonOperator::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterComparisonOperator::lower(const ComparisonOperator &val) {
    auto buf = rustbuffer_alloc(FfiConverterComparisonOperator::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterComparisonOperator::write(stream, val);

    return std::move(buf);
}

ComparisonOperator FfiConverterComparisonOperator::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return ComparisonOperator::kEq;
        
    case 2:
        return ComparisonOperator::kNeq;
        
    case 3:
        return ComparisonOperator::kGt;
        
    case 4:
        return ComparisonOperator::kGte;
        
    case 5:
        return ComparisonOperator::kLt;
        
    case 6:
        return ComparisonOperator::kLte;
        
    case 7:
        return ComparisonOperator::kIn;
        
    case 8:
        return ComparisonOperator::kNotIn;
        
    case 9:
        return ComparisonOperator::kContains;
        
    case 10:
        return ComparisonOperator::kContainsAll;
        
    case 11:
        return ComparisonOperator::kContainsAny;
        
    case 12:
        return ComparisonOperator::kArrayLengthEq;
        
    case 13:
        return ComparisonOperator::kArrayLengthGt;
        
    case 14:
        return ComparisonOperator::kArrayLengthLt;
        
    default:
        throw std::runtime_error("No matching ComparisonOperator variant");
    }
}

void FfiConverterComparisonOperator::write(RustStream &stream, const ComparisonOperator &val) {
    switch (val) {
        
    case ComparisonOperator::kEq:
        stream << static_cast<int32_t>(1);
        break;
        
    case ComparisonOperator::kNeq:
        stream << static_cast<int32_t>(2);
        break;
        
    case ComparisonOperator::kGt:
        stream << static_cast<int32_t>(3);
        break;
        
    case ComparisonOperator::kGte:
        stream << static_cast<int32_t>(4);
        break;
        
    case ComparisonOperator::kLt:
        stream << static_cast<int32_t>(5);
        break;
        
    case ComparisonOperator::kLte:
        stream << static_cast<int32_t>(6);
        break;
        
    case ComparisonOperator::kIn:
        stream << static_cast<int32_t>(7);
        break;
        
    case ComparisonOperator::kNotIn:
        stream << static_cast<int32_t>(8);
        break;
        
    case ComparisonOperator::kContains:
        stream << static_cast<int32_t>(9);
        break;
        
    case ComparisonOperator::kContainsAll:
        stream << static_cast<int32_t>(10);
        break;
        
    case ComparisonOperator::kContainsAny:
        stream << static_cast<int32_t>(11);
        break;
        
    case ComparisonOperator::kArrayLengthEq:
        stream << static_cast<int32_t>(12);
        break;
        
    case ComparisonOperator::kArrayLengthGt:
        stream << static_cast<int32_t>(13);
        break;
        
    case ComparisonOperator::kArrayLengthLt:
        stream << static_cast<int32_t>(14);
        break;
        
    default:
        throw std::runtime_error("No matching ComparisonOperator variant");
    }
}

uint64_t FfiConverterComparisonOperator::allocation_size(const ComparisonOperator &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


ContractType FfiConverterContractType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterContractType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterContractType::lower(const ContractType &val) {
    auto buf = rustbuffer_alloc(FfiConverterContractType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterContractType::write(stream, val);

    return std::move(buf);
}

ContractType FfiConverterContractType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return ContractType::kWorld;
        
    case 2:
        return ContractType::kErc20;
        
    case 3:
        return ContractType::kErc721;
        
    case 4:
        return ContractType::kErc1155;
        
    case 5:
        return ContractType::kUdc;
        
    case 6:
        return ContractType::kOther;
        
    default:
        throw std::runtime_error("No matching ContractType variant");
    }
}

void FfiConverterContractType::write(RustStream &stream, const ContractType &val) {
    switch (val) {
        
    case ContractType::kWorld:
        stream << static_cast<int32_t>(1);
        break;
        
    case ContractType::kErc20:
        stream << static_cast<int32_t>(2);
        break;
        
    case ContractType::kErc721:
        stream << static_cast<int32_t>(3);
        break;
        
    case ContractType::kErc1155:
        stream << static_cast<int32_t>(4);
        break;
        
    case ContractType::kUdc:
        stream << static_cast<int32_t>(5);
        break;
        
    case ContractType::kOther:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching ContractType variant");
    }
}

uint64_t FfiConverterContractType::allocation_size(const ContractType &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


std::shared_ptr<DojoError> FfiConverterDojoError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterDojoError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterDojoError::lower(const DojoError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterDojoError::write(stream, val);

    return std::move(buf);
}

std::shared_ptr<DojoError> FfiConverterDojoError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1:
        return std::make_shared<dojo_error::ClientError>(FfiConverterString::read(stream));
    
    case 2:
        return std::make_shared<dojo_error::SerializationError>(FfiConverterString::read(stream));
    
    case 3:
        return std::make_shared<dojo_error::NetworkError>(FfiConverterString::read(stream));
    
    case 4:
        return std::make_shared<dojo_error::InvalidInput>(FfiConverterString::read(stream));
    
    case 5:
        return std::make_shared<dojo_error::ConnectionError>(FfiConverterString::read(stream));
    
    case 6:
        return std::make_shared<dojo_error::PublishError>(FfiConverterString::read(stream));
    
    case 7:
        return std::make_shared<dojo_error::QueryError>(FfiConverterString::read(stream));
    
    case 8:
        return std::make_shared<dojo_error::SubscriptionError>(FfiConverterString::read(stream));
    
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterDojoError::write(RustStream &stream, const DojoError &val) {
    stream << val.get_variant_idx();
    FfiConverterString::write(stream, val.what());
}

uint64_t FfiConverterDojoError::allocation_size(const DojoError &val) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


LogicalOperator FfiConverterLogicalOperator::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterLogicalOperator::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterLogicalOperator::lower(const LogicalOperator &val) {
    auto buf = rustbuffer_alloc(FfiConverterLogicalOperator::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterLogicalOperator::write(stream, val);

    return std::move(buf);
}

LogicalOperator FfiConverterLogicalOperator::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return LogicalOperator::kAnd;
        
    case 2:
        return LogicalOperator::kOr;
        
    default:
        throw std::runtime_error("No matching LogicalOperator variant");
    }
}

void FfiConverterLogicalOperator::write(RustStream &stream, const LogicalOperator &val) {
    switch (val) {
        
    case LogicalOperator::kAnd:
        stream << static_cast<int32_t>(1);
        break;
        
    case LogicalOperator::kOr:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching LogicalOperator variant");
    }
}

uint64_t FfiConverterLogicalOperator::allocation_size(const LogicalOperator &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


MemberValue FfiConverterMemberValue::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterMemberValue::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterMemberValue::lower(const MemberValue &val) {
    auto buf = rustbuffer_alloc(FfiConverterMemberValue::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterMemberValue::write(stream, val);

    return std::move(buf);
}

MemberValue FfiConverterMemberValue::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {
        
    case 1:
        return MemberValue::kPrimitive {
            .value = std::make_shared<Primitive>(FfiConverterPrimitive::read(stream)),
        };
        
    case 2:
        return MemberValue::kString {
            .value = FfiConverterString::read(stream),
        };
        
    case 3:
        return MemberValue::kList {
            .values = FfiConverterSequenceMemberValue::read(stream),
        };
        
    default:
        throw std::runtime_error("No matching MemberValue variant");
    }
}

void FfiConverterMemberValue::write(RustStream &stream, const MemberValue &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, MemberValue::kPrimitive>) {
            FfiConverterPrimitive::write(stream, *arg.value);
        }
        else if constexpr (std::is_same_v<T, MemberValue::kString>) {
            FfiConverterString::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, MemberValue::kList>) {
            FfiConverterSequenceMemberValue::write(stream, arg.values);
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive MemberValue visitor");
        }
    }, val.variant);
}

uint64_t FfiConverterMemberValue::allocation_size(const MemberValue &val) {
    uint64_t size = sizeof(int32_t);

    size += std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, MemberValue::kPrimitive>) {
            uint64_t size = 0;
            size += FfiConverterPrimitive::allocation_size(*arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, MemberValue::kString>) {
            uint64_t size = 0;
            size += FfiConverterString::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, MemberValue::kList>) {
            uint64_t size = 0;
            size += FfiConverterSequenceMemberValue::allocation_size(arg.values);
            return size;
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive MemberValue visitor");
        }
    }, val.variant);

    return size;
}


OrderDirection FfiConverterOrderDirection::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOrderDirection::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterOrderDirection::lower(const OrderDirection &val) {
    auto buf = rustbuffer_alloc(FfiConverterOrderDirection::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOrderDirection::write(stream, val);

    return std::move(buf);
}

OrderDirection FfiConverterOrderDirection::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return OrderDirection::kAsc;
        
    case 2:
        return OrderDirection::kDesc;
        
    default:
        throw std::runtime_error("No matching OrderDirection variant");
    }
}

void FfiConverterOrderDirection::write(RustStream &stream, const OrderDirection &val) {
    switch (val) {
        
    case OrderDirection::kAsc:
        stream << static_cast<int32_t>(1);
        break;
        
    case OrderDirection::kDesc:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching OrderDirection variant");
    }
}

uint64_t FfiConverterOrderDirection::allocation_size(const OrderDirection &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


PaginationDirection FfiConverterPaginationDirection::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterPaginationDirection::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterPaginationDirection::lower(const PaginationDirection &val) {
    auto buf = rustbuffer_alloc(FfiConverterPaginationDirection::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterPaginationDirection::write(stream, val);

    return std::move(buf);
}

PaginationDirection FfiConverterPaginationDirection::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return PaginationDirection::kForward;
        
    case 2:
        return PaginationDirection::kBackward;
        
    default:
        throw std::runtime_error("No matching PaginationDirection variant");
    }
}

void FfiConverterPaginationDirection::write(RustStream &stream, const PaginationDirection &val) {
    switch (val) {
        
    case PaginationDirection::kForward:
        stream << static_cast<int32_t>(1);
        break;
        
    case PaginationDirection::kBackward:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching PaginationDirection variant");
    }
}

uint64_t FfiConverterPaginationDirection::allocation_size(const PaginationDirection &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


PatternMatching FfiConverterPatternMatching::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterPatternMatching::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterPatternMatching::lower(const PatternMatching &val) {
    auto buf = rustbuffer_alloc(FfiConverterPatternMatching::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterPatternMatching::write(stream, val);

    return std::move(buf);
}

PatternMatching FfiConverterPatternMatching::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return PatternMatching::kFixedLen;
        
    case 2:
        return PatternMatching::kVariableLen;
        
    default:
        throw std::runtime_error("No matching PatternMatching variant");
    }
}

void FfiConverterPatternMatching::write(RustStream &stream, const PatternMatching &val) {
    switch (val) {
        
    case PatternMatching::kFixedLen:
        stream << static_cast<int32_t>(1);
        break;
        
    case PatternMatching::kVariableLen:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching PatternMatching variant");
    }
}

uint64_t FfiConverterPatternMatching::allocation_size(const PatternMatching &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


Primitive FfiConverterPrimitive::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterPrimitive::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterPrimitive::lower(const Primitive &val) {
    auto buf = rustbuffer_alloc(FfiConverterPrimitive::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterPrimitive::write(stream, val);

    return std::move(buf);
}

Primitive FfiConverterPrimitive::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {
        
    case 1:
        return Primitive::kI8 {
            .value = FfiConverterInt8::read(stream),
        };
        
    case 2:
        return Primitive::kI16 {
            .value = FfiConverterInt16::read(stream),
        };
        
    case 3:
        return Primitive::kI32 {
            .value = FfiConverterInt32::read(stream),
        };
        
    case 4:
        return Primitive::kI64 {
            .value = FfiConverterInt64::read(stream),
        };
        
    case 5:
        return Primitive::kI128 {
            .value = FfiConverterSequenceUInt8::read(stream),
        };
        
    case 6:
        return Primitive::kU8 {
            .value = FfiConverterUInt8::read(stream),
        };
        
    case 7:
        return Primitive::kU16 {
            .value = FfiConverterUInt16::read(stream),
        };
        
    case 8:
        return Primitive::kU32 {
            .value = FfiConverterUInt32::read(stream),
        };
        
    case 9:
        return Primitive::kU64 {
            .value = FfiConverterUInt64::read(stream),
        };
        
    case 10:
        return Primitive::kU128 {
            .value = FfiConverterSequenceUInt8::read(stream),
        };
        
    case 11:
        return Primitive::kU256 {
            .value = FfiConverterTypeU256::read(stream),
        };
        
    case 12:
        return Primitive::kBool {
            .value = FfiConverterBool::read(stream),
        };
        
    case 13:
        return Primitive::kFelt252 {
            .value = FfiConverterTypeFieldElement::read(stream),
        };
        
    case 14:
        return Primitive::kClassHash {
            .value = FfiConverterTypeFieldElement::read(stream),
        };
        
    case 15:
        return Primitive::kContractAddress {
            .value = FfiConverterTypeFieldElement::read(stream),
        };
        
    case 16:
        return Primitive::kEthAddress {
            .value = FfiConverterTypeFieldElement::read(stream),
        };
        
    default:
        throw std::runtime_error("No matching Primitive variant");
    }
}

void FfiConverterPrimitive::write(RustStream &stream, const Primitive &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, Primitive::kI8>) {
            FfiConverterInt8::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kI16>) {
            FfiConverterInt16::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kI32>) {
            FfiConverterInt32::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kI64>) {
            FfiConverterInt64::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kI128>) {
            FfiConverterSequenceUInt8::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kU8>) {
            FfiConverterUInt8::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kU16>) {
            FfiConverterUInt16::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kU32>) {
            FfiConverterUInt32::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kU64>) {
            FfiConverterUInt64::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kU128>) {
            FfiConverterSequenceUInt8::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kU256>) {
            FfiConverterTypeU256::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kBool>) {
            FfiConverterBool::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kFelt252>) {
            FfiConverterTypeFieldElement::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kClassHash>) {
            FfiConverterTypeFieldElement::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kContractAddress>) {
            FfiConverterTypeFieldElement::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, Primitive::kEthAddress>) {
            FfiConverterTypeFieldElement::write(stream, arg.value);
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive Primitive visitor");
        }
    }, val.variant);
}

uint64_t FfiConverterPrimitive::allocation_size(const Primitive &val) {
    uint64_t size = sizeof(int32_t);

    size += std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, Primitive::kI8>) {
            uint64_t size = 0;
            size += FfiConverterInt8::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kI16>) {
            uint64_t size = 0;
            size += FfiConverterInt16::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kI32>) {
            uint64_t size = 0;
            size += FfiConverterInt32::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kI64>) {
            uint64_t size = 0;
            size += FfiConverterInt64::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kI128>) {
            uint64_t size = 0;
            size += FfiConverterSequenceUInt8::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kU8>) {
            uint64_t size = 0;
            size += FfiConverterUInt8::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kU16>) {
            uint64_t size = 0;
            size += FfiConverterUInt16::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kU32>) {
            uint64_t size = 0;
            size += FfiConverterUInt32::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kU64>) {
            uint64_t size = 0;
            size += FfiConverterUInt64::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kU128>) {
            uint64_t size = 0;
            size += FfiConverterSequenceUInt8::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kU256>) {
            uint64_t size = 0;
            size += FfiConverterTypeU256::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kBool>) {
            uint64_t size = 0;
            size += FfiConverterBool::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kFelt252>) {
            uint64_t size = 0;
            size += FfiConverterTypeFieldElement::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kClassHash>) {
            uint64_t size = 0;
            size += FfiConverterTypeFieldElement::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kContractAddress>) {
            uint64_t size = 0;
            size += FfiConverterTypeFieldElement::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Primitive::kEthAddress>) {
            uint64_t size = 0;
            size += FfiConverterTypeFieldElement::allocation_size(arg.value);
            return size;
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive Primitive visitor");
        }
    }, val.variant);

    return size;
}


SqlValue FfiConverterSqlValue::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterSqlValue::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterSqlValue::lower(const SqlValue &val) {
    auto buf = rustbuffer_alloc(FfiConverterSqlValue::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterSqlValue::write(stream, val);

    return std::move(buf);
}

SqlValue FfiConverterSqlValue::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {
        
    case 1:
        return SqlValue::kText {
            .value = FfiConverterString::read(stream),
        };
        
    case 2:
        return SqlValue::kInteger {
            .value = FfiConverterInt64::read(stream),
        };
        
    case 3:
        return SqlValue::kReal {
            .value = FfiConverterDouble::read(stream),
        };
        
    case 4:
        return SqlValue::kBlob {
            .value = FfiConverterSequenceUInt8::read(stream),
        };
        
    case 5:
        return SqlValue::kNull {
        };
        
    default:
        throw std::runtime_error("No matching SqlValue variant");
    }
}

void FfiConverterSqlValue::write(RustStream &stream, const SqlValue &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, SqlValue::kText>) {
            FfiConverterString::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, SqlValue::kInteger>) {
            FfiConverterInt64::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, SqlValue::kReal>) {
            FfiConverterDouble::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, SqlValue::kBlob>) {
            FfiConverterSequenceUInt8::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, SqlValue::kNull>) {
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive SqlValue visitor");
        }
    }, val.variant);
}

uint64_t FfiConverterSqlValue::allocation_size(const SqlValue &val) {
    uint64_t size = sizeof(int32_t);

    size += std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, SqlValue::kText>) {
            uint64_t size = 0;
            size += FfiConverterString::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, SqlValue::kInteger>) {
            uint64_t size = 0;
            size += FfiConverterInt64::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, SqlValue::kReal>) {
            uint64_t size = 0;
            size += FfiConverterDouble::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, SqlValue::kBlob>) {
            uint64_t size = 0;
            size += FfiConverterSequenceUInt8::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, SqlValue::kNull>) {
            uint64_t size = 0;
            return size;
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive SqlValue visitor");
        }
    }, val.variant);

    return size;
}


Ty FfiConverterTy::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTy::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTy::lower(const Ty &val) {
    auto buf = rustbuffer_alloc(FfiConverterTy::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTy::write(stream, val);

    return std::move(buf);
}

Ty FfiConverterTy::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {
        
    case 1:
        return Ty::kPrimitive {
            .value = std::make_shared<Primitive>(FfiConverterPrimitive::read(stream)),
        };
        
    case 2:
        return Ty::kStruct {
            .value = std::make_shared<Struct>(FfiConverterTypeStruct::read(stream)),
        };
        
    case 3:
        return Ty::kEnum {
            .value = std::make_shared<EnumType>(FfiConverterTypeEnumType::read(stream)),
        };
        
    case 4:
        return Ty::kTuple {
            .values = FfiConverterSequenceTy::read(stream),
        };
        
    case 5:
        return Ty::kArray {
            .values = FfiConverterSequenceTy::read(stream),
        };
        
    case 6:
        return Ty::kFixedSizeArray {
            .value = std::make_shared<FixedSizeArray>(FfiConverterTypeFixedSizeArray::read(stream)),
        };
        
    case 7:
        return Ty::kByteArray {
            .value = FfiConverterString::read(stream),
        };
        
    default:
        throw std::runtime_error("No matching Ty variant");
    }
}

void FfiConverterTy::write(RustStream &stream, const Ty &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, Ty::kPrimitive>) {
            FfiConverterPrimitive::write(stream, *arg.value);
        }
        else if constexpr (std::is_same_v<T, Ty::kStruct>) {
            FfiConverterTypeStruct::write(stream, *arg.value);
        }
        else if constexpr (std::is_same_v<T, Ty::kEnum>) {
            FfiConverterTypeEnumType::write(stream, *arg.value);
        }
        else if constexpr (std::is_same_v<T, Ty::kTuple>) {
            FfiConverterSequenceTy::write(stream, arg.values);
        }
        else if constexpr (std::is_same_v<T, Ty::kArray>) {
            FfiConverterSequenceTy::write(stream, arg.values);
        }
        else if constexpr (std::is_same_v<T, Ty::kFixedSizeArray>) {
            FfiConverterTypeFixedSizeArray::write(stream, *arg.value);
        }
        else if constexpr (std::is_same_v<T, Ty::kByteArray>) {
            FfiConverterString::write(stream, arg.value);
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive Ty visitor");
        }
    }, val.variant);
}

uint64_t FfiConverterTy::allocation_size(const Ty &val) {
    uint64_t size = sizeof(int32_t);

    size += std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, Ty::kPrimitive>) {
            uint64_t size = 0;
            size += FfiConverterPrimitive::allocation_size(*arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Ty::kStruct>) {
            uint64_t size = 0;
            size += FfiConverterTypeStruct::allocation_size(*arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Ty::kEnum>) {
            uint64_t size = 0;
            size += FfiConverterTypeEnumType::allocation_size(*arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Ty::kTuple>) {
            uint64_t size = 0;
            size += FfiConverterSequenceTy::allocation_size(arg.values);
            return size;
        }
        else if constexpr (std::is_same_v<T, Ty::kArray>) {
            uint64_t size = 0;
            size += FfiConverterSequenceTy::allocation_size(arg.values);
            return size;
        }
        else if constexpr (std::is_same_v<T, Ty::kFixedSizeArray>) {
            uint64_t size = 0;
            size += FfiConverterTypeFixedSizeArray::allocation_size(*arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, Ty::kByteArray>) {
            uint64_t size = 0;
            size += FfiConverterString::allocation_size(arg.value);
            return size;
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive Ty visitor");
        }
    }, val.variant);

    return size;
}


ValueType FfiConverterValueType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterValueType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterValueType::lower(const ValueType &val) {
    auto buf = rustbuffer_alloc(FfiConverterValueType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterValueType::write(stream, val);

    return std::move(buf);
}

ValueType FfiConverterValueType::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {
        
    case 1:
        return ValueType::kString {
            .value = FfiConverterString::read(stream),
        };
        
    case 2:
        return ValueType::kInt {
            .value = FfiConverterInt64::read(stream),
        };
        
    case 3:
        return ValueType::kUInt {
            .value = FfiConverterUInt64::read(stream),
        };
        
    case 4:
        return ValueType::kBool {
            .value = FfiConverterBool::read(stream),
        };
        
    case 5:
        return ValueType::kBytes {
            .value = FfiConverterSequenceUInt8::read(stream),
        };
        
    default:
        throw std::runtime_error("No matching ValueType variant");
    }
}

void FfiConverterValueType::write(RustStream &stream, const ValueType &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, ValueType::kString>) {
            FfiConverterString::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, ValueType::kInt>) {
            FfiConverterInt64::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, ValueType::kUInt>) {
            FfiConverterUInt64::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, ValueType::kBool>) {
            FfiConverterBool::write(stream, arg.value);
        }
        else if constexpr (std::is_same_v<T, ValueType::kBytes>) {
            FfiConverterSequenceUInt8::write(stream, arg.value);
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive ValueType visitor");
        }
    }, val.variant);
}

uint64_t FfiConverterValueType::allocation_size(const ValueType &val) {
    uint64_t size = sizeof(int32_t);

    size += std::visit([&](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, ValueType::kString>) {
            uint64_t size = 0;
            size += FfiConverterString::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, ValueType::kInt>) {
            uint64_t size = 0;
            size += FfiConverterInt64::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, ValueType::kUInt>) {
            uint64_t size = 0;
            size += FfiConverterUInt64::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, ValueType::kBool>) {
            uint64_t size = 0;
            size += FfiConverterBool::allocation_size(arg.value);
            return size;
        }
        else if constexpr (std::is_same_v<T, ValueType::kBytes>) {
            uint64_t size = 0;
            size += FfiConverterSequenceUInt8::allocation_size(arg.value);
            return size;
        }
        else {
            static_assert(always_false_v<T>, "non-exhaustive ValueType visitor");
        }
    }, val.variant);

    return size;
}



std::shared_ptr<EntityUpdateCallback> FfiConverterEntityUpdateCallback::lift(uint64_t handle) {
    return handle_map.at(handle);
}

uint64_t FfiConverterEntityUpdateCallback::lower(const std::shared_ptr<EntityUpdateCallback>& impl) {
    return handle_map.insert(impl);
}

std::shared_ptr<EntityUpdateCallback> uniffi::FfiConverterEntityUpdateCallback::read(RustStream &stream) {
    uint64_t handle;
    stream >> handle;

    return lift(handle);
}

void uniffi::FfiConverterEntityUpdateCallback::write(RustStream &stream, const std::shared_ptr<EntityUpdateCallback> &impl) {
    stream << lower(impl);
}

uint64_t uniffi::FfiConverterEntityUpdateCallback::allocation_size(const std::shared_ptr<EntityUpdateCallback> &impl) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}

 void UniffiCallbackInterfaceEntityUpdateCallback::on_update(uint64_t uniffi_handle,RustBuffer entity,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterEntityUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterTypeEntity::lift(entity);obj->on_update(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}
 void UniffiCallbackInterfaceEntityUpdateCallback::on_error(uint64_t uniffi_handle,RustBuffer error,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterEntityUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterString::lift(error);obj->on_error(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}

void UniffiCallbackInterfaceEntityUpdateCallback::uniffi_free(uint64_t uniffi_handle) {
    FfiConverterEntityUpdateCallback::handle_map.erase(uniffi_handle);
}

void UniffiCallbackInterfaceEntityUpdateCallback::init() {
    uniffi_dojo_uniffi_fn_init_callback_vtable_entityupdatecallback(vtable);
}



std::shared_ptr<EventUpdateCallback> FfiConverterEventUpdateCallback::lift(uint64_t handle) {
    return handle_map.at(handle);
}

uint64_t FfiConverterEventUpdateCallback::lower(const std::shared_ptr<EventUpdateCallback>& impl) {
    return handle_map.insert(impl);
}

std::shared_ptr<EventUpdateCallback> uniffi::FfiConverterEventUpdateCallback::read(RustStream &stream) {
    uint64_t handle;
    stream >> handle;

    return lift(handle);
}

void uniffi::FfiConverterEventUpdateCallback::write(RustStream &stream, const std::shared_ptr<EventUpdateCallback> &impl) {
    stream << lower(impl);
}

uint64_t uniffi::FfiConverterEventUpdateCallback::allocation_size(const std::shared_ptr<EventUpdateCallback> &impl) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}

 void UniffiCallbackInterfaceEventUpdateCallback::on_update(uint64_t uniffi_handle,RustBuffer event,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterEventUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterTypeEvent::lift(event);obj->on_update(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}
 void UniffiCallbackInterfaceEventUpdateCallback::on_error(uint64_t uniffi_handle,RustBuffer error,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterEventUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterString::lift(error);obj->on_error(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}

void UniffiCallbackInterfaceEventUpdateCallback::uniffi_free(uint64_t uniffi_handle) {
    FfiConverterEventUpdateCallback::handle_map.erase(uniffi_handle);
}

void UniffiCallbackInterfaceEventUpdateCallback::init() {
    uniffi_dojo_uniffi_fn_init_callback_vtable_eventupdatecallback(vtable);
}



std::shared_ptr<TokenBalanceUpdateCallback> FfiConverterTokenBalanceUpdateCallback::lift(uint64_t handle) {
    return handle_map.at(handle);
}

uint64_t FfiConverterTokenBalanceUpdateCallback::lower(const std::shared_ptr<TokenBalanceUpdateCallback>& impl) {
    return handle_map.insert(impl);
}

std::shared_ptr<TokenBalanceUpdateCallback> uniffi::FfiConverterTokenBalanceUpdateCallback::read(RustStream &stream) {
    uint64_t handle;
    stream >> handle;

    return lift(handle);
}

void uniffi::FfiConverterTokenBalanceUpdateCallback::write(RustStream &stream, const std::shared_ptr<TokenBalanceUpdateCallback> &impl) {
    stream << lower(impl);
}

uint64_t uniffi::FfiConverterTokenBalanceUpdateCallback::allocation_size(const std::shared_ptr<TokenBalanceUpdateCallback> &impl) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}

 void UniffiCallbackInterfaceTokenBalanceUpdateCallback::on_update(uint64_t uniffi_handle,RustBuffer balance,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterTokenBalanceUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterTypeTokenBalance::lift(balance);obj->on_update(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}
 void UniffiCallbackInterfaceTokenBalanceUpdateCallback::on_error(uint64_t uniffi_handle,RustBuffer error,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterTokenBalanceUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterString::lift(error);obj->on_error(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}

void UniffiCallbackInterfaceTokenBalanceUpdateCallback::uniffi_free(uint64_t uniffi_handle) {
    FfiConverterTokenBalanceUpdateCallback::handle_map.erase(uniffi_handle);
}

void UniffiCallbackInterfaceTokenBalanceUpdateCallback::init() {
    uniffi_dojo_uniffi_fn_init_callback_vtable_tokenbalanceupdatecallback(vtable);
}



std::shared_ptr<TokenUpdateCallback> FfiConverterTokenUpdateCallback::lift(uint64_t handle) {
    return handle_map.at(handle);
}

uint64_t FfiConverterTokenUpdateCallback::lower(const std::shared_ptr<TokenUpdateCallback>& impl) {
    return handle_map.insert(impl);
}

std::shared_ptr<TokenUpdateCallback> uniffi::FfiConverterTokenUpdateCallback::read(RustStream &stream) {
    uint64_t handle;
    stream >> handle;

    return lift(handle);
}

void uniffi::FfiConverterTokenUpdateCallback::write(RustStream &stream, const std::shared_ptr<TokenUpdateCallback> &impl) {
    stream << lower(impl);
}

uint64_t uniffi::FfiConverterTokenUpdateCallback::allocation_size(const std::shared_ptr<TokenUpdateCallback> &impl) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}

 void UniffiCallbackInterfaceTokenUpdateCallback::on_update(uint64_t uniffi_handle,RustBuffer token,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterTokenUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterTypeToken::lift(token);obj->on_update(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}
 void UniffiCallbackInterfaceTokenUpdateCallback::on_error(uint64_t uniffi_handle,RustBuffer error,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterTokenUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterString::lift(error);obj->on_error(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}

void UniffiCallbackInterfaceTokenUpdateCallback::uniffi_free(uint64_t uniffi_handle) {
    FfiConverterTokenUpdateCallback::handle_map.erase(uniffi_handle);
}

void UniffiCallbackInterfaceTokenUpdateCallback::init() {
    uniffi_dojo_uniffi_fn_init_callback_vtable_tokenupdatecallback(vtable);
}



std::shared_ptr<TransactionUpdateCallback> FfiConverterTransactionUpdateCallback::lift(uint64_t handle) {
    return handle_map.at(handle);
}

uint64_t FfiConverterTransactionUpdateCallback::lower(const std::shared_ptr<TransactionUpdateCallback>& impl) {
    return handle_map.insert(impl);
}

std::shared_ptr<TransactionUpdateCallback> uniffi::FfiConverterTransactionUpdateCallback::read(RustStream &stream) {
    uint64_t handle;
    stream >> handle;

    return lift(handle);
}

void uniffi::FfiConverterTransactionUpdateCallback::write(RustStream &stream, const std::shared_ptr<TransactionUpdateCallback> &impl) {
    stream << lower(impl);
}

uint64_t uniffi::FfiConverterTransactionUpdateCallback::allocation_size(const std::shared_ptr<TransactionUpdateCallback> &impl) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}

 void UniffiCallbackInterfaceTransactionUpdateCallback::on_update(uint64_t uniffi_handle,RustBuffer transaction,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterTransactionUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterTypeTransaction::lift(transaction);obj->on_update(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}
 void UniffiCallbackInterfaceTransactionUpdateCallback::on_error(uint64_t uniffi_handle,RustBuffer error,void * uniffi_out_return,RustCallStatus *out_status) {
    auto obj = FfiConverterTransactionUpdateCallback::handle_map.at(uniffi_handle);

    auto make_call = [&]()  {
        auto arg0 =FfiConverterString::lift(error);obj->on_error(
        arg0);
    };

    
    auto write_value = [](){};
    

    
        rust_call_trait_interface(out_status, make_call, write_value);
    
}

void UniffiCallbackInterfaceTransactionUpdateCallback::uniffi_free(uint64_t uniffi_handle) {
    FfiConverterTransactionUpdateCallback::handle_map.erase(uniffi_handle);
}

void UniffiCallbackInterfaceTransactionUpdateCallback::init() {
    uniffi_dojo_uniffi_fn_init_callback_vtable_transactionupdatecallback(vtable);
}

std::optional<uint32_t> FfiConverterOptionalUInt32::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalUInt32::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalUInt32::lower(const std::optional<uint32_t>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalUInt32::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalUInt32::write(stream, val);

    return buf;
}

std::optional<uint32_t> FfiConverterOptionalUInt32::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterUInt32::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalUInt32::write(RustStream &stream, const std::optional<uint32_t>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterUInt32::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalUInt32::allocation_size(const std::optional<uint32_t> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterUInt32::allocation_size(val.value());
    }

    return ret;
}

std::optional<uint64_t> FfiConverterOptionalUInt64::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalUInt64::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalUInt64::lower(const std::optional<uint64_t>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalUInt64::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalUInt64::write(stream, val);

    return buf;
}

std::optional<uint64_t> FfiConverterOptionalUInt64::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterUInt64::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalUInt64::write(RustStream &stream, const std::optional<uint64_t>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterUInt64::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalUInt64::allocation_size(const std::optional<uint64_t> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterUInt64::allocation_size(val.value());
    }

    return ret;
}

std::optional<bool> FfiConverterOptionalBool::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalBool::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalBool::lower(const std::optional<bool>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalBool::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalBool::write(stream, val);

    return buf;
}

std::optional<bool> FfiConverterOptionalBool::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterBool::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalBool::write(RustStream &stream, const std::optional<bool>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterBool::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalBool::allocation_size(const std::optional<bool> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterBool::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::string> FfiConverterOptionalString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalString::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalString::lower(const std::optional<std::string>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalString::write(stream, val);

    return buf;
}

std::optional<std::string> FfiConverterOptionalString::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterString::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalString::write(RustStream &stream, const std::optional<std::string>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterString::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalString::allocation_size(const std::optional<std::string> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterString::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::shared_ptr<KeysClause>> FfiConverterOptionalTypeKeysClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeKeysClause::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeKeysClause::lower(const std::optional<std::shared_ptr<KeysClause>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeKeysClause::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeKeysClause::write(stream, val);

    return buf;
}

std::optional<std::shared_ptr<KeysClause>> FfiConverterOptionalTypeKeysClause::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(std::make_shared<KeysClause>(FfiConverterTypeKeysClause::read(stream)));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeKeysClause::write(RustStream &stream, const std::optional<std::shared_ptr<KeysClause>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeKeysClause::write(stream, *value.value());
    }
}

uint64_t FfiConverterOptionalTypeKeysClause::allocation_size(const std::optional<std::shared_ptr<KeysClause>> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterTypeKeysClause::allocation_size(*val.value());
    }

    return ret;
}

std::optional<std::shared_ptr<TransactionFilter>> FfiConverterOptionalTypeTransactionFilter::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeTransactionFilter::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeTransactionFilter::lower(const std::optional<std::shared_ptr<TransactionFilter>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeTransactionFilter::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeTransactionFilter::write(stream, val);

    return buf;
}

std::optional<std::shared_ptr<TransactionFilter>> FfiConverterOptionalTypeTransactionFilter::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(std::make_shared<TransactionFilter>(FfiConverterTypeTransactionFilter::read(stream)));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeTransactionFilter::write(RustStream &stream, const std::optional<std::shared_ptr<TransactionFilter>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeTransactionFilter::write(stream, *value.value());
    }
}

uint64_t FfiConverterOptionalTypeTransactionFilter::allocation_size(const std::optional<std::shared_ptr<TransactionFilter>> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterTypeTransactionFilter::allocation_size(*val.value());
    }

    return ret;
}

std::optional<std::shared_ptr<Clause>> FfiConverterOptionalClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalClause::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalClause::lower(const std::optional<std::shared_ptr<Clause>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalClause::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalClause::write(stream, val);

    return buf;
}

std::optional<std::shared_ptr<Clause>> FfiConverterOptionalClause::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(std::make_shared<Clause>(FfiConverterClause::read(stream)));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalClause::write(RustStream &stream, const std::optional<std::shared_ptr<Clause>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterClause::write(stream, *value.value());
    }
}

uint64_t FfiConverterOptionalClause::allocation_size(const std::optional<std::shared_ptr<Clause>> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterClause::allocation_size(*val.value());
    }

    return ret;
}

std::optional<FieldElement> FfiConverterOptionalTypeFieldElement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFieldElement::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFieldElement::lower(const std::optional<FieldElement>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFieldElement::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFieldElement::write(stream, val);

    return buf;
}

std::optional<FieldElement> FfiConverterOptionalTypeFieldElement::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFieldElement::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFieldElement::write(RustStream &stream, const std::optional<FieldElement>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFieldElement::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalTypeFieldElement::allocation_size(const std::optional<FieldElement> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFieldElement::allocation_size(val.value());
    }

    return ret;
}

std::optional<U256> FfiConverterOptionalTypeU256::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeU256::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeU256::lower(const std::optional<U256>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeU256::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeU256::write(stream, val);

    return buf;
}

std::optional<U256> FfiConverterOptionalTypeU256::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeU256::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeU256::write(RustStream &stream, const std::optional<U256>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeU256::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalTypeU256::allocation_size(const std::optional<U256> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterTypeU256::allocation_size(val.value());
    }

    return ret;
}


std::vector<uint8_t> FfiConverterSequenceUInt8::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceUInt8::lower(const std::vector<uint8_t> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<uint8_t> FfiConverterSequenceUInt8::read(RustStream &stream) {
    std::vector<uint8_t> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterUInt8::read(stream));
    }

    return ret;
}

void FfiConverterSequenceUInt8::write(RustStream &stream, const std::vector<uint8_t> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterUInt8::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceUInt8::allocation_size(const std::vector<uint8_t> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterUInt8::allocation_size(elem);
    }

    return size;
}


std::vector<std::string> FfiConverterSequenceString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceString::lower(const std::vector<std::string> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::string> FfiConverterSequenceString::read(RustStream &stream) {
    std::vector<std::string> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterString::read(stream));
    }

    return ret;
}

void FfiConverterSequenceString::write(RustStream &stream, const std::vector<std::string> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterString::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceString::allocation_size(const std::vector<std::string> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterString::allocation_size(elem);
    }

    return size;
}


std::vector<std::shared_ptr<Achievement>> FfiConverterSequenceTypeAchievement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeAchievement::lower(const std::vector<std::shared_ptr<Achievement>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Achievement>> FfiConverterSequenceTypeAchievement::read(RustStream &stream) {
    std::vector<std::shared_ptr<Achievement>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Achievement>(FfiConverterTypeAchievement::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeAchievement::write(RustStream &stream, const std::vector<std::shared_ptr<Achievement>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeAchievement::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeAchievement::allocation_size(const std::vector<std::shared_ptr<Achievement>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeAchievement::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<AchievementTask>> FfiConverterSequenceTypeAchievementTask::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeAchievementTask::lower(const std::vector<std::shared_ptr<AchievementTask>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<AchievementTask>> FfiConverterSequenceTypeAchievementTask::read(RustStream &stream) {
    std::vector<std::shared_ptr<AchievementTask>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<AchievementTask>(FfiConverterTypeAchievementTask::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeAchievementTask::write(RustStream &stream, const std::vector<std::shared_ptr<AchievementTask>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeAchievementTask::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeAchievementTask::allocation_size(const std::vector<std::shared_ptr<AchievementTask>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeAchievementTask::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<ActionCount>> FfiConverterSequenceTypeActionCount::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeActionCount::lower(const std::vector<std::shared_ptr<ActionCount>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<ActionCount>> FfiConverterSequenceTypeActionCount::read(RustStream &stream) {
    std::vector<std::shared_ptr<ActionCount>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<ActionCount>(FfiConverterTypeActionCount::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeActionCount::write(RustStream &stream, const std::vector<std::shared_ptr<ActionCount>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeActionCount::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeActionCount::allocation_size(const std::vector<std::shared_ptr<ActionCount>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeActionCount::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Activity>> FfiConverterSequenceTypeActivity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeActivity::lower(const std::vector<std::shared_ptr<Activity>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Activity>> FfiConverterSequenceTypeActivity::read(RustStream &stream) {
    std::vector<std::shared_ptr<Activity>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Activity>(FfiConverterTypeActivity::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeActivity::write(RustStream &stream, const std::vector<std::shared_ptr<Activity>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeActivity::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeActivity::allocation_size(const std::vector<std::shared_ptr<Activity>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeActivity::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<AggregationEntry>> FfiConverterSequenceTypeAggregationEntry::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeAggregationEntry::lower(const std::vector<std::shared_ptr<AggregationEntry>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<AggregationEntry>> FfiConverterSequenceTypeAggregationEntry::read(RustStream &stream) {
    std::vector<std::shared_ptr<AggregationEntry>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<AggregationEntry>(FfiConverterTypeAggregationEntry::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeAggregationEntry::write(RustStream &stream, const std::vector<std::shared_ptr<AggregationEntry>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeAggregationEntry::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeAggregationEntry::allocation_size(const std::vector<std::shared_ptr<AggregationEntry>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeAggregationEntry::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<AttributeFilter>> FfiConverterSequenceTypeAttributeFilter::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeAttributeFilter::lower(const std::vector<std::shared_ptr<AttributeFilter>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<AttributeFilter>> FfiConverterSequenceTypeAttributeFilter::read(RustStream &stream) {
    std::vector<std::shared_ptr<AttributeFilter>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<AttributeFilter>(FfiConverterTypeAttributeFilter::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeAttributeFilter::write(RustStream &stream, const std::vector<std::shared_ptr<AttributeFilter>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeAttributeFilter::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeAttributeFilter::allocation_size(const std::vector<std::shared_ptr<AttributeFilter>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeAttributeFilter::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Contract>> FfiConverterSequenceTypeContract::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeContract::lower(const std::vector<std::shared_ptr<Contract>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Contract>> FfiConverterSequenceTypeContract::read(RustStream &stream) {
    std::vector<std::shared_ptr<Contract>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Contract>(FfiConverterTypeContract::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeContract::write(RustStream &stream, const std::vector<std::shared_ptr<Contract>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeContract::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeContract::allocation_size(const std::vector<std::shared_ptr<Contract>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeContract::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Controller>> FfiConverterSequenceTypeController::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeController::lower(const std::vector<std::shared_ptr<Controller>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Controller>> FfiConverterSequenceTypeController::read(RustStream &stream) {
    std::vector<std::shared_ptr<Controller>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Controller>(FfiConverterTypeController::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeController::write(RustStream &stream, const std::vector<std::shared_ptr<Controller>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeController::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeController::allocation_size(const std::vector<std::shared_ptr<Controller>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeController::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Entity>> FfiConverterSequenceTypeEntity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeEntity::lower(const std::vector<std::shared_ptr<Entity>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Entity>> FfiConverterSequenceTypeEntity::read(RustStream &stream) {
    std::vector<std::shared_ptr<Entity>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Entity>(FfiConverterTypeEntity::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeEntity::write(RustStream &stream, const std::vector<std::shared_ptr<Entity>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeEntity::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeEntity::allocation_size(const std::vector<std::shared_ptr<Entity>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeEntity::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<EnumOption>> FfiConverterSequenceTypeEnumOption::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeEnumOption::lower(const std::vector<std::shared_ptr<EnumOption>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<EnumOption>> FfiConverterSequenceTypeEnumOption::read(RustStream &stream) {
    std::vector<std::shared_ptr<EnumOption>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<EnumOption>(FfiConverterTypeEnumOption::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeEnumOption::write(RustStream &stream, const std::vector<std::shared_ptr<EnumOption>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeEnumOption::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeEnumOption::allocation_size(const std::vector<std::shared_ptr<EnumOption>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeEnumOption::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Event>> FfiConverterSequenceTypeEvent::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeEvent::lower(const std::vector<std::shared_ptr<Event>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Event>> FfiConverterSequenceTypeEvent::read(RustStream &stream) {
    std::vector<std::shared_ptr<Event>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Event>(FfiConverterTypeEvent::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeEvent::write(RustStream &stream, const std::vector<std::shared_ptr<Event>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeEvent::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeEvent::allocation_size(const std::vector<std::shared_ptr<Event>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeEvent::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<KeysClause>> FfiConverterSequenceTypeKeysClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeKeysClause::lower(const std::vector<std::shared_ptr<KeysClause>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<KeysClause>> FfiConverterSequenceTypeKeysClause::read(RustStream &stream) {
    std::vector<std::shared_ptr<KeysClause>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<KeysClause>(FfiConverterTypeKeysClause::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeKeysClause::write(RustStream &stream, const std::vector<std::shared_ptr<KeysClause>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeKeysClause::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeKeysClause::allocation_size(const std::vector<std::shared_ptr<KeysClause>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeKeysClause::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Member>> FfiConverterSequenceTypeMember::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeMember::lower(const std::vector<std::shared_ptr<Member>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Member>> FfiConverterSequenceTypeMember::read(RustStream &stream) {
    std::vector<std::shared_ptr<Member>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Member>(FfiConverterTypeMember::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeMember::write(RustStream &stream, const std::vector<std::shared_ptr<Member>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeMember::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeMember::allocation_size(const std::vector<std::shared_ptr<Member>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeMember::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Message>> FfiConverterSequenceTypeMessage::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeMessage::lower(const std::vector<std::shared_ptr<Message>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Message>> FfiConverterSequenceTypeMessage::read(RustStream &stream) {
    std::vector<std::shared_ptr<Message>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Message>(FfiConverterTypeMessage::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeMessage::write(RustStream &stream, const std::vector<std::shared_ptr<Message>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeMessage::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeMessage::allocation_size(const std::vector<std::shared_ptr<Message>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeMessage::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Model>> FfiConverterSequenceTypeModel::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeModel::lower(const std::vector<std::shared_ptr<Model>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Model>> FfiConverterSequenceTypeModel::read(RustStream &stream) {
    std::vector<std::shared_ptr<Model>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Model>(FfiConverterTypeModel::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeModel::write(RustStream &stream, const std::vector<std::shared_ptr<Model>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeModel::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeModel::allocation_size(const std::vector<std::shared_ptr<Model>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeModel::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<OrderBy>> FfiConverterSequenceTypeOrderBy::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeOrderBy::lower(const std::vector<std::shared_ptr<OrderBy>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<OrderBy>> FfiConverterSequenceTypeOrderBy::read(RustStream &stream) {
    std::vector<std::shared_ptr<OrderBy>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<OrderBy>(FfiConverterTypeOrderBy::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeOrderBy::write(RustStream &stream, const std::vector<std::shared_ptr<OrderBy>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeOrderBy::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeOrderBy::allocation_size(const std::vector<std::shared_ptr<OrderBy>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeOrderBy::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<PlayerAchievementEntry>> FfiConverterSequenceTypePlayerAchievementEntry::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypePlayerAchievementEntry::lower(const std::vector<std::shared_ptr<PlayerAchievementEntry>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<PlayerAchievementEntry>> FfiConverterSequenceTypePlayerAchievementEntry::read(RustStream &stream) {
    std::vector<std::shared_ptr<PlayerAchievementEntry>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<PlayerAchievementEntry>(FfiConverterTypePlayerAchievementEntry::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypePlayerAchievementEntry::write(RustStream &stream, const std::vector<std::shared_ptr<PlayerAchievementEntry>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypePlayerAchievementEntry::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypePlayerAchievementEntry::allocation_size(const std::vector<std::shared_ptr<PlayerAchievementEntry>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypePlayerAchievementEntry::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<PlayerAchievementProgress>> FfiConverterSequenceTypePlayerAchievementProgress::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypePlayerAchievementProgress::lower(const std::vector<std::shared_ptr<PlayerAchievementProgress>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<PlayerAchievementProgress>> FfiConverterSequenceTypePlayerAchievementProgress::read(RustStream &stream) {
    std::vector<std::shared_ptr<PlayerAchievementProgress>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<PlayerAchievementProgress>(FfiConverterTypePlayerAchievementProgress::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypePlayerAchievementProgress::write(RustStream &stream, const std::vector<std::shared_ptr<PlayerAchievementProgress>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypePlayerAchievementProgress::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypePlayerAchievementProgress::allocation_size(const std::vector<std::shared_ptr<PlayerAchievementProgress>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypePlayerAchievementProgress::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<SqlField>> FfiConverterSequenceTypeSqlField::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeSqlField::lower(const std::vector<std::shared_ptr<SqlField>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<SqlField>> FfiConverterSequenceTypeSqlField::read(RustStream &stream) {
    std::vector<std::shared_ptr<SqlField>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<SqlField>(FfiConverterTypeSqlField::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeSqlField::write(RustStream &stream, const std::vector<std::shared_ptr<SqlField>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeSqlField::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeSqlField::allocation_size(const std::vector<std::shared_ptr<SqlField>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeSqlField::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<SqlRow>> FfiConverterSequenceTypeSqlRow::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeSqlRow::lower(const std::vector<std::shared_ptr<SqlRow>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<SqlRow>> FfiConverterSequenceTypeSqlRow::read(RustStream &stream) {
    std::vector<std::shared_ptr<SqlRow>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<SqlRow>(FfiConverterTypeSqlRow::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeSqlRow::write(RustStream &stream, const std::vector<std::shared_ptr<SqlRow>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeSqlRow::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeSqlRow::allocation_size(const std::vector<std::shared_ptr<SqlRow>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeSqlRow::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Struct>> FfiConverterSequenceTypeStruct::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeStruct::lower(const std::vector<std::shared_ptr<Struct>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Struct>> FfiConverterSequenceTypeStruct::read(RustStream &stream) {
    std::vector<std::shared_ptr<Struct>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Struct>(FfiConverterTypeStruct::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeStruct::write(RustStream &stream, const std::vector<std::shared_ptr<Struct>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeStruct::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeStruct::allocation_size(const std::vector<std::shared_ptr<Struct>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeStruct::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<TaskProgress>> FfiConverterSequenceTypeTaskProgress::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeTaskProgress::lower(const std::vector<std::shared_ptr<TaskProgress>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<TaskProgress>> FfiConverterSequenceTypeTaskProgress::read(RustStream &stream) {
    std::vector<std::shared_ptr<TaskProgress>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<TaskProgress>(FfiConverterTypeTaskProgress::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeTaskProgress::write(RustStream &stream, const std::vector<std::shared_ptr<TaskProgress>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeTaskProgress::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeTaskProgress::allocation_size(const std::vector<std::shared_ptr<TaskProgress>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeTaskProgress::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Token>> FfiConverterSequenceTypeToken::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeToken::lower(const std::vector<std::shared_ptr<Token>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Token>> FfiConverterSequenceTypeToken::read(RustStream &stream) {
    std::vector<std::shared_ptr<Token>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Token>(FfiConverterTypeToken::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeToken::write(RustStream &stream, const std::vector<std::shared_ptr<Token>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeToken::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeToken::allocation_size(const std::vector<std::shared_ptr<Token>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeToken::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<TokenBalance>> FfiConverterSequenceTypeTokenBalance::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeTokenBalance::lower(const std::vector<std::shared_ptr<TokenBalance>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<TokenBalance>> FfiConverterSequenceTypeTokenBalance::read(RustStream &stream) {
    std::vector<std::shared_ptr<TokenBalance>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<TokenBalance>(FfiConverterTypeTokenBalance::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeTokenBalance::write(RustStream &stream, const std::vector<std::shared_ptr<TokenBalance>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeTokenBalance::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeTokenBalance::allocation_size(const std::vector<std::shared_ptr<TokenBalance>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeTokenBalance::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<TokenContract>> FfiConverterSequenceTypeTokenContract::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeTokenContract::lower(const std::vector<std::shared_ptr<TokenContract>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<TokenContract>> FfiConverterSequenceTypeTokenContract::read(RustStream &stream) {
    std::vector<std::shared_ptr<TokenContract>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<TokenContract>(FfiConverterTypeTokenContract::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeTokenContract::write(RustStream &stream, const std::vector<std::shared_ptr<TokenContract>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeTokenContract::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeTokenContract::allocation_size(const std::vector<std::shared_ptr<TokenContract>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeTokenContract::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<TokenTransfer>> FfiConverterSequenceTypeTokenTransfer::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeTokenTransfer::lower(const std::vector<std::shared_ptr<TokenTransfer>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<TokenTransfer>> FfiConverterSequenceTypeTokenTransfer::read(RustStream &stream) {
    std::vector<std::shared_ptr<TokenTransfer>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<TokenTransfer>(FfiConverterTypeTokenTransfer::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeTokenTransfer::write(RustStream &stream, const std::vector<std::shared_ptr<TokenTransfer>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeTokenTransfer::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeTokenTransfer::allocation_size(const std::vector<std::shared_ptr<TokenTransfer>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeTokenTransfer::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Transaction>> FfiConverterSequenceTypeTransaction::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeTransaction::lower(const std::vector<std::shared_ptr<Transaction>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Transaction>> FfiConverterSequenceTypeTransaction::read(RustStream &stream) {
    std::vector<std::shared_ptr<Transaction>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Transaction>(FfiConverterTypeTransaction::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeTransaction::write(RustStream &stream, const std::vector<std::shared_ptr<Transaction>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeTransaction::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeTransaction::allocation_size(const std::vector<std::shared_ptr<Transaction>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeTransaction::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<TransactionCall>> FfiConverterSequenceTypeTransactionCall::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeTransactionCall::lower(const std::vector<std::shared_ptr<TransactionCall>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<TransactionCall>> FfiConverterSequenceTypeTransactionCall::read(RustStream &stream) {
    std::vector<std::shared_ptr<TransactionCall>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<TransactionCall>(FfiConverterTypeTransactionCall::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeTransactionCall::write(RustStream &stream, const std::vector<std::shared_ptr<TransactionCall>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeTransactionCall::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeTransactionCall::allocation_size(const std::vector<std::shared_ptr<TransactionCall>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeTransactionCall::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<World>> FfiConverterSequenceTypeWorld::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeWorld::lower(const std::vector<std::shared_ptr<World>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<World>> FfiConverterSequenceTypeWorld::read(RustStream &stream) {
    std::vector<std::shared_ptr<World>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<World>(FfiConverterTypeWorld::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeWorld::write(RustStream &stream, const std::vector<std::shared_ptr<World>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeWorld::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeWorld::allocation_size(const std::vector<std::shared_ptr<World>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeWorld::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Clause>> FfiConverterSequenceClause::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceClause::lower(const std::vector<std::shared_ptr<Clause>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Clause>> FfiConverterSequenceClause::read(RustStream &stream) {
    std::vector<std::shared_ptr<Clause>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Clause>(FfiConverterClause::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceClause::write(RustStream &stream, const std::vector<std::shared_ptr<Clause>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterClause::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceClause::allocation_size(const std::vector<std::shared_ptr<Clause>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterClause::allocation_size(*elem);
    }

    return size;
}


std::vector<ContractType> FfiConverterSequenceContractType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceContractType::lower(const std::vector<ContractType> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<ContractType> FfiConverterSequenceContractType::read(RustStream &stream) {
    std::vector<ContractType> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterContractType::read(stream));
    }

    return ret;
}

void FfiConverterSequenceContractType::write(RustStream &stream, const std::vector<ContractType> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterContractType::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceContractType::allocation_size(const std::vector<ContractType> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterContractType::allocation_size(elem);
    }

    return size;
}


std::vector<std::shared_ptr<MemberValue>> FfiConverterSequenceMemberValue::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceMemberValue::lower(const std::vector<std::shared_ptr<MemberValue>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<MemberValue>> FfiConverterSequenceMemberValue::read(RustStream &stream) {
    std::vector<std::shared_ptr<MemberValue>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<MemberValue>(FfiConverterMemberValue::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceMemberValue::write(RustStream &stream, const std::vector<std::shared_ptr<MemberValue>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterMemberValue::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceMemberValue::allocation_size(const std::vector<std::shared_ptr<MemberValue>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterMemberValue::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<Ty>> FfiConverterSequenceTy::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTy::lower(const std::vector<std::shared_ptr<Ty>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Ty>> FfiConverterSequenceTy::read(RustStream &stream) {
    std::vector<std::shared_ptr<Ty>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Ty>(FfiConverterTy::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTy::write(RustStream &stream, const std::vector<std::shared_ptr<Ty>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTy::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTy::allocation_size(const std::vector<std::shared_ptr<Ty>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTy::allocation_size(*elem);
    }

    return size;
}


std::vector<std::optional<FieldElement>> FfiConverterSequenceOptionalTypeFieldElement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceOptionalTypeFieldElement::lower(const std::vector<std::optional<FieldElement>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::optional<FieldElement>> FfiConverterSequenceOptionalTypeFieldElement::read(RustStream &stream) {
    std::vector<std::optional<FieldElement>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterOptionalTypeFieldElement::read(stream));
    }

    return ret;
}

void FfiConverterSequenceOptionalTypeFieldElement::write(RustStream &stream, const std::vector<std::optional<FieldElement>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterOptionalTypeFieldElement::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceOptionalTypeFieldElement::allocation_size(const std::vector<std::optional<FieldElement>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterOptionalTypeFieldElement::allocation_size(elem);
    }

    return size;
}


std::vector<FieldElement> FfiConverterSequenceTypeFieldElement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFieldElement::lower(const std::vector<FieldElement> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FieldElement> FfiConverterSequenceTypeFieldElement::read(RustStream &stream) {
    std::vector<FieldElement> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFieldElement::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFieldElement::write(RustStream &stream, const std::vector<FieldElement> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFieldElement::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceTypeFieldElement::allocation_size(const std::vector<FieldElement> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFieldElement::allocation_size(elem);
    }

    return size;
}


std::vector<U256> FfiConverterSequenceTypeU256::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeU256::lower(const std::vector<U256> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<U256> FfiConverterSequenceTypeU256::read(RustStream &stream) {
    std::vector<U256> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeU256::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeU256::write(RustStream &stream, const std::vector<U256> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeU256::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceTypeU256::allocation_size(const std::vector<U256> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeU256::allocation_size(elem);
    }

    return size;
}



}} // namespace dojo