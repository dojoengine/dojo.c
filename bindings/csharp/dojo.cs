// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.10.0+v0.29.4
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
namespace uniffi.dojo;
using FfiConverterTypeFieldElement = FfiConverterString;
using FfiConverterTypeU256 = FfiConverterString;
using FieldElement = String;
using U256 = String;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_dojo_uniffi_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_dojo_uniffi_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

internal class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

internal class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

internal class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

internal class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

internal class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

internal class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

internal class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        Dispose(list);
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
   private static void Dispose(Object? obj) {
         if (obj == null) {
             return;
         }

         if (obj is IDisposable disposable) {
             disposable.Dispose();
             return;
         }

         var objType = obj.GetType();
         var typeCode = Type.GetTypeCode(objType);
         if (typeCode != TypeCode.Object) {
             return;
         }

         var genericArguments = objType.GetGenericArguments();
         if (genericArguments.Length == 0 && !objType.IsArray) {
             return;
         }

         if (obj is System.Collections.IDictionary objDictionary) {
             //This extra code tests to not call "Dispose" for a Dictionary<something, double>()
             //for all values as "double" and alike doesn't support interface "IDisposable"
             var valuesType = objType.GetGenericArguments()[1];
             var elementValuesTypeCode = Type.GetTypeCode(valuesType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in objDictionary.Values) {
                 Dispose(value);
             }
         }
         else if (obj is System.Collections.IEnumerable listValues) {
             //This extra code tests to not call "Dispose" for a List<int>()
             //for all keys as "int" and alike doesn't support interface "IDisposable"
             var elementType = objType.IsArray ? objType.GetElementType() : genericArguments[0];
             var elementValuesTypeCode = Type.GetTypeCode(elementType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in listValues) {
                 Dispose(value);
             }
         }
     }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

static class BigEndianStreamExtensions
{
    public static void WriteInt32(this Stream stream, int value, int bytesToWrite = 4)
    {
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
        byte[] buffer = new byte[bytesToWrite];
#endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static void WriteInt64(this Stream stream, long value)
    {
        int bytesToWrite = 8;
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToWrite];
 #else
         byte[] buffer = new byte[bytesToWrite];
 #endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static uint ReadUint32(this Stream stream, int bytesToRead = 4) {
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        uint result = 0;
        uint digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static ulong ReadUInt64(this Stream stream) {
        int bytesToRead = 8;
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        ulong result = 0;
        ulong digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static void CheckRemaining(this Stream stream, int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }

    public static void ForEach<T>(this T[] items, Action<T> action){
        foreach (var item in items) {
            action(item);
        }
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] buffer) {
#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public void WriteByte(byte value) => stream.WriteInt32(value, bytesToWrite: 1);
    public void WriteSByte(sbyte value) => stream.WriteInt32(value, bytesToWrite: 1);

    public void WriteUShort(ushort value) => stream.WriteInt32(value, bytesToWrite: 2);
    public void WriteShort(short value) => stream.WriteInt32(value, bytesToWrite: 2);

    public void WriteUInt(uint value) => stream.WriteInt32((int)value);
    public void WriteInt(int value) => stream.WriteInt32(value);

    public void WriteULong(ulong value) => stream.WriteInt64((long)value);
    public void WriteLong(long value) => stream.WriteInt64(value);

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }
    public void WriteDouble(double value) => stream.WriteInt64(BitConverter.DoubleToInt64Bits(value));

    public byte[] ReadBytes(int length) {
        stream.CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() => (byte)stream.ReadUint32(bytesToRead: 1);
    public ushort ReadUShort() => (ushort)stream.ReadUint32(bytesToRead: 2);
    public uint ReadUInt() => (uint)stream.ReadUint32(bytesToRead: 4);
    public ulong ReadULong() => stream.ReadUInt64();

    public sbyte ReadSByte() => (sbyte)ReadByte();
    public short ReadShort() => (short)ReadUShort();
    public int ReadInt() => (int)ReadUInt();

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() => (long)ReadULong();
    public double ReadDouble() => BitConverter.Int64BitsToDouble(ReadLong());
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceEntityUpdateCallbackMethod0(
        ulong @uniffiHandle,RustBuffer @entity,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceEntityUpdateCallbackMethod1(
        ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceEventUpdateCallbackMethod0(
        ulong @uniffiHandle,RustBuffer @event,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceEventUpdateCallbackMethod1(
        ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTokenBalanceUpdateCallbackMethod0(
        ulong @uniffiHandle,RustBuffer @balance,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTokenBalanceUpdateCallbackMethod1(
        ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTokenUpdateCallbackMethod0(
        ulong @uniffiHandle,RustBuffer @token,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTokenUpdateCallbackMethod1(
        ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTransactionUpdateCallbackMethod0(
        ulong @uniffiHandle,RustBuffer @transaction,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceTransactionUpdateCallbackMethod1(
        ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceEntityUpdateCallback
    {
        public IntPtr @onUpdate;
        public IntPtr @onError;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceEventUpdateCallback
    {
        public IntPtr @onUpdate;
        public IntPtr @onError;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceTokenBalanceUpdateCallback
    {
        public IntPtr @onUpdate;
        public IntPtr @onError;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceTokenUpdateCallback
    {
        public IntPtr @onUpdate;
        public IntPtr @onError;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceTransactionUpdateCallback
    {
        public IntPtr @onUpdate;
        public IntPtr @onError;
        public IntPtr @uniffiFree;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        UniffiCallbackInterfaceEntityUpdateCallback.Register();
        UniffiCallbackInterfaceEventUpdateCallback.Register();
        UniffiCallbackInterfaceTokenBalanceUpdateCallback.Register();
        UniffiCallbackInterfaceTokenUpdateCallback.Register();
        UniffiCallbackInterfaceTransactionUpdateCallback.Register();
        }

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_dojo_uniffi_fn_clone_toriiclient(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_free_toriiclient(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_dojo_uniffi_fn_constructor_toriiclient_new(RustBuffer @toriiUrl,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_dojo_uniffi_fn_constructor_toriiclient_new_with_config(RustBuffer @toriiUrl,ulong @maxMessageSize,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_achievements(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_activities(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_aggregations(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_method_toriiclient_cancel_subscription(IntPtr @ptr,ulong @subscriptionId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_contracts(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_controllers(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_entities(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_event_messages(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_player_achievements(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_publish_message(IntPtr @ptr,RustBuffer @message,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_publish_message_batch(IntPtr @ptr,RustBuffer @messages,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_sql(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_starknet_events(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_entity_updates(IntPtr @ptr,RustBuffer @clause,RustBuffer @worldAddresses,ulong @callback,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_event_updates(IntPtr @ptr,RustBuffer @keys,ulong @callback,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_balance_updates(IntPtr @ptr,RustBuffer @contractAddresses,RustBuffer @accountAddresses,RustBuffer @tokenIds,ulong @callback,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_updates(IntPtr @ptr,RustBuffer @contractAddresses,RustBuffer @tokenIds,ulong @callback,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_transaction_updates(IntPtr @ptr,RustBuffer @filter,ulong @callback,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_token_balances(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_token_contracts(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_token_transfers(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_tokens(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_transactions(IntPtr @ptr,RustBuffer @query,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_dojo_uniffi_fn_method_toriiclient_worlds(IntPtr @ptr,RustBuffer @worldAddresses,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_init_callback_vtable_entityupdatecallback(ref _UniFFILib.UniffiVTableCallbackInterfaceEntityUpdateCallback @vtable
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_init_callback_vtable_eventupdatecallback(ref _UniFFILib.UniffiVTableCallbackInterfaceEventUpdateCallback @vtable
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_init_callback_vtable_tokenbalanceupdatecallback(ref _UniFFILib.UniffiVTableCallbackInterfaceTokenBalanceUpdateCallback @vtable
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_init_callback_vtable_tokenupdatecallback(ref _UniFFILib.UniffiVTableCallbackInterfaceTokenUpdateCallback @vtable
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_dojo_uniffi_fn_init_callback_vtable_transactionupdatecallback(ref _UniFFILib.UniffiVTableCallbackInterfaceTransactionUpdateCallback @vtable
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_dojo_uniffi_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_dojo_uniffi_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_dojo_uniffi_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_dojo_uniffi_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_dojo_uniffi_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_dojo_uniffi_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_dojo_uniffi_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_dojo_uniffi_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_dojo_uniffi_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_dojo_uniffi_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_dojo_uniffi_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_dojo_uniffi_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_dojo_uniffi_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_dojo_uniffi_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_dojo_uniffi_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_free_void(IntPtr @handle
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_dojo_uniffi_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_achievements(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_activities(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_aggregations(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_cancel_subscription(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_contracts(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_controllers(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_entities(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_event_messages(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_player_achievements(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message_batch(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_sql(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_starknet_events(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_entity_updates(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_event_updates(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_balance_updates(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_updates(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_transaction_updates(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_token_balances(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_token_contracts(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_token_transfers(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_tokens(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_transactions(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_toriiclient_worlds(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_constructor_toriiclient_new(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_constructor_toriiclient_new_with_config(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_update(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_error(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_update(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_error(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_update(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_error(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_update(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_error(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_update(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_error(
    );

    [DllImport("dojo_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_dojo_uniffi_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_dojo_uniffi_uniffi_contract_version();
        if (29 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"uniffi.dojo: uniffi bindings expected version `29`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_achievements();
            if (checksum != 22681) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_achievements` checksum `22681`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_activities();
            if (checksum != 30695) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_activities` checksum `30695`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_aggregations();
            if (checksum != 59796) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_aggregations` checksum `59796`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_cancel_subscription();
            if (checksum != 1222) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_cancel_subscription` checksum `1222`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_contracts();
            if (checksum != 1019) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_contracts` checksum `1019`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_controllers();
            if (checksum != 9802) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_controllers` checksum `9802`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_entities();
            if (checksum != 5808) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_entities` checksum `5808`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_event_messages();
            if (checksum != 45410) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_event_messages` checksum `45410`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_player_achievements();
            if (checksum != 12776) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_player_achievements` checksum `12776`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message();
            if (checksum != 44715) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message` checksum `44715`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message_batch();
            if (checksum != 50961) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message_batch` checksum `50961`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_sql();
            if (checksum != 59851) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_sql` checksum `59851`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_starknet_events();
            if (checksum != 22346) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_starknet_events` checksum `22346`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_entity_updates();
            if (checksum != 52753) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_entity_updates` checksum `52753`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_event_updates();
            if (checksum != 33181) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_event_updates` checksum `33181`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_balance_updates();
            if (checksum != 35318) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_balance_updates` checksum `35318`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_updates();
            if (checksum != 16166) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_updates` checksum `16166`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_transaction_updates();
            if (checksum != 56883) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_transaction_updates` checksum `56883`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_token_balances();
            if (checksum != 39956) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_token_balances` checksum `39956`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_token_contracts();
            if (checksum != 14101) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_token_contracts` checksum `14101`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_token_transfers();
            if (checksum != 25342) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_token_transfers` checksum `25342`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_tokens();
            if (checksum != 26560) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_tokens` checksum `26560`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_transactions();
            if (checksum != 20162) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_transactions` checksum `20162`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_toriiclient_worlds();
            if (checksum != 6894) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_toriiclient_worlds` checksum `6894`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_constructor_toriiclient_new();
            if (checksum != 18057) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_constructor_toriiclient_new` checksum `18057`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_constructor_toriiclient_new_with_config();
            if (checksum != 42232) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_constructor_toriiclient_new_with_config` checksum `42232`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_update();
            if (checksum != 25229) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_update` checksum `25229`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_error();
            if (checksum != 55699) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_error` checksum `55699`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_update();
            if (checksum != 3388) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_update` checksum `3388`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_error();
            if (checksum != 50382) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_error` checksum `50382`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_update();
            if (checksum != 64172) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_update` checksum `64172`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_error();
            if (checksum != 1784) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_error` checksum `1784`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_update();
            if (checksum != 51753) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_update` checksum `51753`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_error();
            if (checksum != 35695) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_error` checksum `35695`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_update();
            if (checksum != 6036) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_update` checksum `6036`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_error();
            if (checksum != 4248) {
                throw new UniffiContractChecksumException($"uniffi.dojo: uniffi bindings expected function `uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_error` checksum `4248`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt8: FfiConverter<byte, byte> {
    public static FfiConverterUInt8 INSTANCE = new FfiConverterUInt8();

    public override byte Lift(byte value) {
        return value;
    }

    public override byte Read(BigEndianStream stream) {
        return stream.ReadByte();
    }

    public override byte Lower(byte value) {
        return value;
    }

    public override int AllocationSize(byte value) {
        return 1;
    }

    public override void Write(byte value, BigEndianStream stream) {
        stream.WriteByte(value);
    }
}



class FfiConverterInt8: FfiConverter<sbyte, sbyte> {
    public static FfiConverterInt8 INSTANCE = new FfiConverterInt8();

    public override sbyte Lift(sbyte value) {
        return value;
    }

    public override sbyte Read(BigEndianStream stream) {
        return stream.ReadSByte();
    }

    public override sbyte Lower(sbyte value) {
        return value;
    }

    public override int AllocationSize(sbyte value) {
        return 1;
    }

    public override void Write(sbyte value, BigEndianStream stream) {
        stream.WriteSByte(value);
    }
}



class FfiConverterUInt16: FfiConverter<ushort, ushort> {
    public static FfiConverterUInt16 INSTANCE = new FfiConverterUInt16();

    public override ushort Lift(ushort value) {
        return value;
    }

    public override ushort Read(BigEndianStream stream) {
        return stream.ReadUShort();
    }

    public override ushort Lower(ushort value) {
        return value;
    }

    public override int AllocationSize(ushort value) {
        return 2;
    }

    public override void Write(ushort value, BigEndianStream stream) {
        stream.WriteUShort(value);
    }
}



class FfiConverterInt16: FfiConverter<short, short> {
    public static FfiConverterInt16 INSTANCE = new FfiConverterInt16();

    public override short Lift(short value) {
        return value;
    }

    public override short Read(BigEndianStream stream) {
        return stream.ReadShort();
    }

    public override short Lower(short value) {
        return value;
    }

    public override int AllocationSize(short value) {
        return 2;
    }

    public override void Write(short value, BigEndianStream stream) {
        stream.WriteShort(value);
    }
}



class FfiConverterUInt32: FfiConverter<uint, uint> {
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value) {
        return value;
    }

    public override uint Read(BigEndianStream stream) {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value) {
        return value;
    }

    public override int AllocationSize(uint value) {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream) {
        stream.WriteUInt(value);
    }
}



class FfiConverterInt32: FfiConverter<int, int> {
    public static FfiConverterInt32 INSTANCE = new FfiConverterInt32();

    public override int Lift(int value) {
        return value;
    }

    public override int Read(BigEndianStream stream) {
        return stream.ReadInt();
    }

    public override int Lower(int value) {
        return value;
    }

    public override int AllocationSize(int value) {
        return 4;
    }

    public override void Write(int value, BigEndianStream stream) {
        stream.WriteInt(value);
    }
}



class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterInt64: FfiConverter<long, long> {
    public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

    public override long Lift(long value) {
        return value;
    }

    public override long Read(BigEndianStream stream) {
        return stream.ReadLong();
    }

    public override long Lower(long value) {
        return value;
    }

    public override int AllocationSize(long value) {
        return 8;
    }

    public override void Write(long value, BigEndianStream stream) {
        stream.WriteLong(value);
    }
}



class FfiConverterDouble: FfiConverter<double, double> {
    public static FfiConverterDouble INSTANCE = new FfiConverterDouble();

    public override double Lift(double value) {
        return value;
    }

    public override double Read(BigEndianStream stream) {
        return stream.ReadDouble();
    }

    public override double Lower(double value) {
        return value;
    }

    public override int AllocationSize(double value) {
        return 8;
    }

    public override void Write(double value, BigEndianStream stream) {
        stream.WriteDouble(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}



internal interface IToriiClient {
    /// <exception cref="DojoException"></exception>
    PageAchievement Achievements(AchievementQuery @query);
    /// <exception cref="DojoException"></exception>
    PageActivity Activities(ActivityQuery @query);
    /// <exception cref="DojoException"></exception>
    PageAggregationEntry Aggregations(AggregationQuery @query);
    /// <exception cref="DojoException"></exception>
    void CancelSubscription(ulong @subscriptionId);
    /// <exception cref="DojoException"></exception>
    Contract[] Contracts(ContractQuery @query);
    /// <exception cref="DojoException"></exception>
    PageController Controllers(ControllerQuery @query);
    /// <exception cref="DojoException"></exception>
    PageEntity Entities(Query @query);
    /// <exception cref="DojoException"></exception>
    PageEntity EventMessages(Query @query);
    /// <exception cref="DojoException"></exception>
    PagePlayerAchievement PlayerAchievements(PlayerAchievementQuery @query);
    /// <exception cref="DojoException"></exception>
    string PublishMessage(Message @message);
    /// <exception cref="DojoException"></exception>
    string[] PublishMessageBatch(Message[] @messages);
    /// <exception cref="DojoException"></exception>
    SqlRow[] Sql(string @query);
    /// <exception cref="DojoException"></exception>
    PageEvent StarknetEvents(EventQuery @query);
    /// <exception cref="DojoException"></exception>
    ulong SubscribeEntityUpdates(Clause? @clause, FieldElement[] @worldAddresses, EntityUpdateCallback @callback);
    /// <exception cref="DojoException"></exception>
    ulong SubscribeEventUpdates(KeysClause[] @keys, EventUpdateCallback @callback);
    /// <exception cref="DojoException"></exception>
    ulong SubscribeTokenBalanceUpdates(FieldElement[] @contractAddresses, FieldElement[] @accountAddresses, U256[] @tokenIds, TokenBalanceUpdateCallback @callback);
    /// <exception cref="DojoException"></exception>
    ulong SubscribeTokenUpdates(FieldElement[] @contractAddresses, U256[] @tokenIds, TokenUpdateCallback @callback);
    /// <exception cref="DojoException"></exception>
    ulong SubscribeTransactionUpdates(TransactionFilter? @filter, TransactionUpdateCallback @callback);
    /// <exception cref="DojoException"></exception>
    PageTokenBalance TokenBalances(TokenBalanceQuery @query);
    /// <exception cref="DojoException"></exception>
    PageTokenContract TokenContracts(TokenContractQuery @query);
    /// <exception cref="DojoException"></exception>
    PageTokenTransfer TokenTransfers(TokenTransferQuery @query);
    /// <exception cref="DojoException"></exception>
    PageToken Tokens(TokenQuery @query);
    /// <exception cref="DojoException"></exception>
    PageTransaction Transactions(TransactionQuery @query);
    /// <exception cref="DojoException"></exception>
    World[] Worlds(FieldElement[] @worldAddresses);
}
internal class ToriiClient : IToriiClient, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public ToriiClient(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~ToriiClient() {
        Destroy();
    }
    public ToriiClient(string @toriiUrl) :
        this(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_constructor_toriiclient_new(FfiConverterString.INSTANCE.Lower(@toriiUrl), ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_dojo_uniffi_fn_free_toriiclient(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_dojo_uniffi_fn_clone_toriiclient(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <exception cref="DojoException"></exception>
    public PageAchievement Achievements(AchievementQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageAchievement.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_achievements(thisPtr, FfiConverterTypeAchievementQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageActivity Activities(ActivityQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageActivity.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_activities(thisPtr, FfiConverterTypeActivityQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageAggregationEntry Aggregations(AggregationQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageAggregationEntry.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_aggregations(thisPtr, FfiConverterTypeAggregationQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public void CancelSubscription(ulong @subscriptionId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_cancel_subscription(thisPtr, FfiConverterUInt64.INSTANCE.Lower(@subscriptionId), ref _status)
));
    }
    
    
    
    /// <exception cref="DojoException"></exception>
    public Contract[] Contracts(ContractQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterSequenceTypeContract.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_contracts(thisPtr, FfiConverterTypeContractQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageController Controllers(ControllerQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageController.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_controllers(thisPtr, FfiConverterTypeControllerQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageEntity Entities(Query @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageEntity.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_entities(thisPtr, FfiConverterTypeQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageEntity EventMessages(Query @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageEntity.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_event_messages(thisPtr, FfiConverterTypeQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PagePlayerAchievement PlayerAchievements(PlayerAchievementQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePagePlayerAchievement.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_player_achievements(thisPtr, FfiConverterTypePlayerAchievementQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public string PublishMessage(Message @message) {
        return CallWithPointer(thisPtr => FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_publish_message(thisPtr, FfiConverterTypeMessage.INSTANCE.Lower(@message), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public string[] PublishMessageBatch(Message[] @messages) {
        return CallWithPointer(thisPtr => FfiConverterSequenceString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_publish_message_batch(thisPtr, FfiConverterSequenceTypeMessage.INSTANCE.Lower(@messages), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public SqlRow[] Sql(string @query) {
        return CallWithPointer(thisPtr => FfiConverterSequenceTypeSqlRow.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_sql(thisPtr, FfiConverterString.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageEvent StarknetEvents(EventQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageEvent.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_starknet_events(thisPtr, FfiConverterTypeEventQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public ulong SubscribeEntityUpdates(Clause? @clause, FieldElement[] @worldAddresses, EntityUpdateCallback @callback) {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_entity_updates(thisPtr, FfiConverterOptionalTypeClause.INSTANCE.Lower(@clause), FfiConverterSequenceTypeFieldElement.INSTANCE.Lower(@worldAddresses), FfiConverterTypeEntityUpdateCallback.INSTANCE.Lower(@callback), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public ulong SubscribeEventUpdates(KeysClause[] @keys, EventUpdateCallback @callback) {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_event_updates(thisPtr, FfiConverterSequenceTypeKeysClause.INSTANCE.Lower(@keys), FfiConverterTypeEventUpdateCallback.INSTANCE.Lower(@callback), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public ulong SubscribeTokenBalanceUpdates(FieldElement[] @contractAddresses, FieldElement[] @accountAddresses, U256[] @tokenIds, TokenBalanceUpdateCallback @callback) {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_balance_updates(thisPtr, FfiConverterSequenceTypeFieldElement.INSTANCE.Lower(@contractAddresses), FfiConverterSequenceTypeFieldElement.INSTANCE.Lower(@accountAddresses), FfiConverterSequenceTypeU256.INSTANCE.Lower(@tokenIds), FfiConverterTypeTokenBalanceUpdateCallback.INSTANCE.Lower(@callback), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public ulong SubscribeTokenUpdates(FieldElement[] @contractAddresses, U256[] @tokenIds, TokenUpdateCallback @callback) {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_updates(thisPtr, FfiConverterSequenceTypeFieldElement.INSTANCE.Lower(@contractAddresses), FfiConverterSequenceTypeU256.INSTANCE.Lower(@tokenIds), FfiConverterTypeTokenUpdateCallback.INSTANCE.Lower(@callback), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public ulong SubscribeTransactionUpdates(TransactionFilter? @filter, TransactionUpdateCallback @callback) {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_transaction_updates(thisPtr, FfiConverterOptionalTypeTransactionFilter.INSTANCE.Lower(@filter), FfiConverterTypeTransactionUpdateCallback.INSTANCE.Lower(@callback), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageTokenBalance TokenBalances(TokenBalanceQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageTokenBalance.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_token_balances(thisPtr, FfiConverterTypeTokenBalanceQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageTokenContract TokenContracts(TokenContractQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageTokenContract.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_token_contracts(thisPtr, FfiConverterTypeTokenContractQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageTokenTransfer TokenTransfers(TokenTransferQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageTokenTransfer.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_token_transfers(thisPtr, FfiConverterTypeTokenTransferQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageToken Tokens(TokenQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageToken.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_tokens(thisPtr, FfiConverterTypeTokenQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public PageTransaction Transactions(TransactionQuery @query) {
        return CallWithPointer(thisPtr => FfiConverterTypePageTransaction.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_transactions(thisPtr, FfiConverterTypeTransactionQuery.INSTANCE.Lower(@query), ref _status)
)));
    }
    
    
    /// <exception cref="DojoException"></exception>
    public World[] Worlds(FieldElement[] @worldAddresses) {
        return CallWithPointer(thisPtr => FfiConverterSequenceTypeWorld.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_method_toriiclient_worlds(thisPtr, FfiConverterSequenceTypeFieldElement.INSTANCE.Lower(@worldAddresses), ref _status)
)));
    }
    
    

    
    /// <exception cref="DojoException"></exception>
    public static ToriiClient NewWithConfig(string @toriiUrl, ulong @maxMessageSize) {
        return new ToriiClient(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeDojoError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_dojo_uniffi_fn_constructor_toriiclient_new_with_config(FfiConverterString.INSTANCE.Lower(@toriiUrl), FfiConverterUInt64.INSTANCE.Lower(@maxMessageSize), ref _status)
));
    }
    
    
}
class FfiConverterTypeToriiClient: FfiConverter<ToriiClient, IntPtr> {
    public static FfiConverterTypeToriiClient INSTANCE = new FfiConverterTypeToriiClient();


    public override IntPtr Lower(ToriiClient value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override ToriiClient Lift(IntPtr value) {
        return new ToriiClient(value);
    }

    public override ToriiClient Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(ToriiClient value) {
        return 8;
    }

    public override void Write(ToriiClient value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



internal record Achievement (
    string @id, 
    FieldElement @worldAddress, 
    string @namespace, 
    string @entityId, 
    bool @hidden, 
    uint @index, 
    uint @points, 
    string @start, 
    string @end, 
    string @group, 
    string @icon, 
    string @title, 
    string @description, 
    AchievementTask[] @tasks, 
    string? @data, 
    uint @totalCompletions, 
    double @completionRate, 
    ulong @createdAt, 
    ulong @updatedAt
) {
}

class FfiConverterTypeAchievement: FfiConverterRustBuffer<Achievement> {
    public static FfiConverterTypeAchievement INSTANCE = new FfiConverterTypeAchievement();

    public override Achievement Read(BigEndianStream stream) {
        return new Achievement(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @namespace: FfiConverterString.INSTANCE.Read(stream),
            @entityId: FfiConverterString.INSTANCE.Read(stream),
            @hidden: FfiConverterBoolean.INSTANCE.Read(stream),
            @index: FfiConverterUInt32.INSTANCE.Read(stream),
            @points: FfiConverterUInt32.INSTANCE.Read(stream),
            @start: FfiConverterString.INSTANCE.Read(stream),
            @end: FfiConverterString.INSTANCE.Read(stream),
            @group: FfiConverterString.INSTANCE.Read(stream),
            @icon: FfiConverterString.INSTANCE.Read(stream),
            @title: FfiConverterString.INSTANCE.Read(stream),
            @description: FfiConverterString.INSTANCE.Read(stream),
            @tasks: FfiConverterSequenceTypeAchievementTask.INSTANCE.Read(stream),
            @data: FfiConverterOptionalString.INSTANCE.Read(stream),
            @totalCompletions: FfiConverterUInt32.INSTANCE.Read(stream),
            @completionRate: FfiConverterDouble.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Achievement value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@namespace)
            + FfiConverterString.INSTANCE.AllocationSize(value.@entityId)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@hidden)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@index)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@points)
            + FfiConverterString.INSTANCE.AllocationSize(value.@start)
            + FfiConverterString.INSTANCE.AllocationSize(value.@end)
            + FfiConverterString.INSTANCE.AllocationSize(value.@group)
            + FfiConverterString.INSTANCE.AllocationSize(value.@icon)
            + FfiConverterString.INSTANCE.AllocationSize(value.@title)
            + FfiConverterString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterSequenceTypeAchievementTask.INSTANCE.AllocationSize(value.@tasks)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@data)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@totalCompletions)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@completionRate)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt);
    }

    public override void Write(Achievement value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@namespace, stream);
            FfiConverterString.INSTANCE.Write(value.@entityId, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@hidden, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@index, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@points, stream);
            FfiConverterString.INSTANCE.Write(value.@start, stream);
            FfiConverterString.INSTANCE.Write(value.@end, stream);
            FfiConverterString.INSTANCE.Write(value.@group, stream);
            FfiConverterString.INSTANCE.Write(value.@icon, stream);
            FfiConverterString.INSTANCE.Write(value.@title, stream);
            FfiConverterString.INSTANCE.Write(value.@description, stream);
            FfiConverterSequenceTypeAchievementTask.INSTANCE.Write(value.@tasks, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@data, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@totalCompletions, stream);
            FfiConverterDouble.INSTANCE.Write(value.@completionRate, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
    }
}



internal record AchievementProgression (
    string @id, 
    string @achievementId, 
    string @taskId, 
    FieldElement @worldAddress, 
    string @namespace, 
    FieldElement @playerId, 
    uint @count, 
    bool @completed, 
    ulong? @completedAt, 
    ulong @createdAt, 
    ulong @updatedAt
) {
}

class FfiConverterTypeAchievementProgression: FfiConverterRustBuffer<AchievementProgression> {
    public static FfiConverterTypeAchievementProgression INSTANCE = new FfiConverterTypeAchievementProgression();

    public override AchievementProgression Read(BigEndianStream stream) {
        return new AchievementProgression(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @achievementId: FfiConverterString.INSTANCE.Read(stream),
            @taskId: FfiConverterString.INSTANCE.Read(stream),
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @namespace: FfiConverterString.INSTANCE.Read(stream),
            @playerId: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @count: FfiConverterUInt32.INSTANCE.Read(stream),
            @completed: FfiConverterBoolean.INSTANCE.Read(stream),
            @completedAt: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AchievementProgression value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@achievementId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@taskId)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@namespace)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@playerId)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@count)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@completed)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@completedAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt);
    }

    public override void Write(AchievementProgression value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterString.INSTANCE.Write(value.@achievementId, stream);
            FfiConverterString.INSTANCE.Write(value.@taskId, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@namespace, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@playerId, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@count, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@completed, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@completedAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
    }
}



internal record AchievementQuery (
    FieldElement[] @worldAddresses, 
    string[] @namespaces, 
    bool? @hidden, 
    Pagination @pagination
) {
}

class FfiConverterTypeAchievementQuery: FfiConverterRustBuffer<AchievementQuery> {
    public static FfiConverterTypeAchievementQuery INSTANCE = new FfiConverterTypeAchievementQuery();

    public override AchievementQuery Read(BigEndianStream stream) {
        return new AchievementQuery(
            @worldAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @namespaces: FfiConverterSequenceString.INSTANCE.Read(stream),
            @hidden: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AchievementQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddresses)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@namespaces)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@hidden)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(AchievementQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@worldAddresses, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@namespaces, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@hidden, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record AchievementTask (
    string @taskId, 
    string @description, 
    uint @total, 
    uint @totalCompletions, 
    double @completionRate, 
    ulong @createdAt
) {
}

class FfiConverterTypeAchievementTask: FfiConverterRustBuffer<AchievementTask> {
    public static FfiConverterTypeAchievementTask INSTANCE = new FfiConverterTypeAchievementTask();

    public override AchievementTask Read(BigEndianStream stream) {
        return new AchievementTask(
            @taskId: FfiConverterString.INSTANCE.Read(stream),
            @description: FfiConverterString.INSTANCE.Read(stream),
            @total: FfiConverterUInt32.INSTANCE.Read(stream),
            @totalCompletions: FfiConverterUInt32.INSTANCE.Read(stream),
            @completionRate: FfiConverterDouble.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AchievementTask value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@taskId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@total)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@totalCompletions)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@completionRate)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt);
    }

    public override void Write(AchievementTask value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@taskId, stream);
            FfiConverterString.INSTANCE.Write(value.@description, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@total, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@totalCompletions, stream);
            FfiConverterDouble.INSTANCE.Write(value.@completionRate, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
    }
}



internal record ActionCount (
    string @actionName, 
    uint @count
) {
}

class FfiConverterTypeActionCount: FfiConverterRustBuffer<ActionCount> {
    public static FfiConverterTypeActionCount INSTANCE = new FfiConverterTypeActionCount();

    public override ActionCount Read(BigEndianStream stream) {
        return new ActionCount(
            @actionName: FfiConverterString.INSTANCE.Read(stream),
            @count: FfiConverterUInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ActionCount value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@actionName)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@count);
    }

    public override void Write(ActionCount value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@actionName, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@count, stream);
    }
}



internal record Activity (
    string @id, 
    FieldElement @worldAddress, 
    string @namespace, 
    FieldElement @callerAddress, 
    ulong @sessionStart, 
    ulong @sessionEnd, 
    uint @actionCount, 
    ActionCount[] @actions, 
    ulong @updatedAt
) {
}

class FfiConverterTypeActivity: FfiConverterRustBuffer<Activity> {
    public static FfiConverterTypeActivity INSTANCE = new FfiConverterTypeActivity();

    public override Activity Read(BigEndianStream stream) {
        return new Activity(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @namespace: FfiConverterString.INSTANCE.Read(stream),
            @callerAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @sessionStart: FfiConverterUInt64.INSTANCE.Read(stream),
            @sessionEnd: FfiConverterUInt64.INSTANCE.Read(stream),
            @actionCount: FfiConverterUInt32.INSTANCE.Read(stream),
            @actions: FfiConverterSequenceTypeActionCount.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Activity value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@namespace)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@callerAddress)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@sessionStart)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@sessionEnd)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@actionCount)
            + FfiConverterSequenceTypeActionCount.INSTANCE.AllocationSize(value.@actions)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt);
    }

    public override void Write(Activity value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@namespace, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@callerAddress, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@sessionStart, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@sessionEnd, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@actionCount, stream);
            FfiConverterSequenceTypeActionCount.INSTANCE.Write(value.@actions, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
    }
}



internal record ActivityQuery (
    FieldElement[] @worldAddresses, 
    string[] @namespaces, 
    FieldElement[] @callerAddresses, 
    ulong? @fromTime, 
    ulong? @toTime, 
    Pagination @pagination
) {
}

class FfiConverterTypeActivityQuery: FfiConverterRustBuffer<ActivityQuery> {
    public static FfiConverterTypeActivityQuery INSTANCE = new FfiConverterTypeActivityQuery();

    public override ActivityQuery Read(BigEndianStream stream) {
        return new ActivityQuery(
            @worldAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @namespaces: FfiConverterSequenceString.INSTANCE.Read(stream),
            @callerAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @fromTime: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @toTime: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ActivityQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddresses)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@namespaces)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@callerAddresses)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@fromTime)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@toTime)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(ActivityQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@worldAddresses, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@namespaces, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@callerAddresses, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@fromTime, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@toTime, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record AggregationEntry (
    string @id, 
    string @aggregatorId, 
    string @entityId, 
    U256 @value, 
    string @displayValue, 
    ulong @position, 
    string @modelId, 
    ulong @createdAt, 
    ulong @updatedAt
) {
}

class FfiConverterTypeAggregationEntry: FfiConverterRustBuffer<AggregationEntry> {
    public static FfiConverterTypeAggregationEntry INSTANCE = new FfiConverterTypeAggregationEntry();

    public override AggregationEntry Read(BigEndianStream stream) {
        return new AggregationEntry(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @aggregatorId: FfiConverterString.INSTANCE.Read(stream),
            @entityId: FfiConverterString.INSTANCE.Read(stream),
            @value: FfiConverterTypeU256.INSTANCE.Read(stream),
            @displayValue: FfiConverterString.INSTANCE.Read(stream),
            @position: FfiConverterUInt64.INSTANCE.Read(stream),
            @modelId: FfiConverterString.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AggregationEntry value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@aggregatorId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@entityId)
            + FfiConverterTypeU256.INSTANCE.AllocationSize(value.@value)
            + FfiConverterString.INSTANCE.AllocationSize(value.@displayValue)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@position)
            + FfiConverterString.INSTANCE.AllocationSize(value.@modelId)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt);
    }

    public override void Write(AggregationEntry value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterString.INSTANCE.Write(value.@aggregatorId, stream);
            FfiConverterString.INSTANCE.Write(value.@entityId, stream);
            FfiConverterTypeU256.INSTANCE.Write(value.@value, stream);
            FfiConverterString.INSTANCE.Write(value.@displayValue, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@position, stream);
            FfiConverterString.INSTANCE.Write(value.@modelId, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
    }
}



internal record AggregationQuery (
    string[] @aggregatorIds, 
    string[] @entityIds, 
    Pagination @pagination
) {
}

class FfiConverterTypeAggregationQuery: FfiConverterRustBuffer<AggregationQuery> {
    public static FfiConverterTypeAggregationQuery INSTANCE = new FfiConverterTypeAggregationQuery();

    public override AggregationQuery Read(BigEndianStream stream) {
        return new AggregationQuery(
            @aggregatorIds: FfiConverterSequenceString.INSTANCE.Read(stream),
            @entityIds: FfiConverterSequenceString.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AggregationQuery value) {
        return 0
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@aggregatorIds)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@entityIds)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(AggregationQuery value, BigEndianStream stream) {
            FfiConverterSequenceString.INSTANCE.Write(value.@aggregatorIds, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@entityIds, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record AttributeFilter (
    string @traitName, 
    string @traitValue
) {
}

class FfiConverterTypeAttributeFilter: FfiConverterRustBuffer<AttributeFilter> {
    public static FfiConverterTypeAttributeFilter INSTANCE = new FfiConverterTypeAttributeFilter();

    public override AttributeFilter Read(BigEndianStream stream) {
        return new AttributeFilter(
            @traitName: FfiConverterString.INSTANCE.Read(stream),
            @traitValue: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AttributeFilter value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@traitName)
            + FfiConverterString.INSTANCE.AllocationSize(value.@traitValue);
    }

    public override void Write(AttributeFilter value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@traitName, stream);
            FfiConverterString.INSTANCE.Write(value.@traitValue, stream);
    }
}



internal record CompositeClause (
    LogicalOperator @operator, 
    Clause[] @clauses
) {
}

class FfiConverterTypeCompositeClause: FfiConverterRustBuffer<CompositeClause> {
    public static FfiConverterTypeCompositeClause INSTANCE = new FfiConverterTypeCompositeClause();

    public override CompositeClause Read(BigEndianStream stream) {
        return new CompositeClause(
            @operator: FfiConverterTypeLogicalOperator.INSTANCE.Read(stream),
            @clauses: FfiConverterSequenceTypeClause.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CompositeClause value) {
        return 0
            + FfiConverterTypeLogicalOperator.INSTANCE.AllocationSize(value.@operator)
            + FfiConverterSequenceTypeClause.INSTANCE.AllocationSize(value.@clauses);
    }

    public override void Write(CompositeClause value, BigEndianStream stream) {
            FfiConverterTypeLogicalOperator.INSTANCE.Write(value.@operator, stream);
            FfiConverterSequenceTypeClause.INSTANCE.Write(value.@clauses, stream);
    }
}



internal record Contract (
    FieldElement @contractAddress, 
    ContractType @contractType, 
    ulong? @head, 
    ulong? @tps, 
    ulong? @lastBlockTimestamp, 
    FieldElement? @lastPendingBlockTx, 
    ulong @updatedAt, 
    ulong @createdAt
) {
}

class FfiConverterTypeContract: FfiConverterRustBuffer<Contract> {
    public static FfiConverterTypeContract INSTANCE = new FfiConverterTypeContract();

    public override Contract Read(BigEndianStream stream) {
        return new Contract(
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @contractType: FfiConverterTypeContractType.INSTANCE.Read(stream),
            @head: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @tps: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @lastBlockTimestamp: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @lastPendingBlockTx: FfiConverterOptionalTypeFieldElement.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Contract value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterTypeContractType.INSTANCE.AllocationSize(value.@contractType)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@head)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@tps)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@lastBlockTimestamp)
            + FfiConverterOptionalTypeFieldElement.INSTANCE.AllocationSize(value.@lastPendingBlockTx)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt);
    }

    public override void Write(Contract value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterTypeContractType.INSTANCE.Write(value.@contractType, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@head, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@tps, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@lastBlockTimestamp, stream);
            FfiConverterOptionalTypeFieldElement.INSTANCE.Write(value.@lastPendingBlockTx, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
    }
}



internal record ContractQuery (
    FieldElement[] @contractAddresses, 
    ContractType[] @contractTypes
) {
}

class FfiConverterTypeContractQuery: FfiConverterRustBuffer<ContractQuery> {
    public static FfiConverterTypeContractQuery INSTANCE = new FfiConverterTypeContractQuery();

    public override ContractQuery Read(BigEndianStream stream) {
        return new ContractQuery(
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @contractTypes: FfiConverterSequenceTypeContractType.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ContractQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceTypeContractType.INSTANCE.AllocationSize(value.@contractTypes);
    }

    public override void Write(ContractQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceTypeContractType.INSTANCE.Write(value.@contractTypes, stream);
    }
}



internal record Controller (
    FieldElement @address, 
    string @username, 
    ulong @deployedAtTimestamp
) {
}

class FfiConverterTypeController: FfiConverterRustBuffer<Controller> {
    public static FfiConverterTypeController INSTANCE = new FfiConverterTypeController();

    public override Controller Read(BigEndianStream stream) {
        return new Controller(
            @address: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @username: FfiConverterString.INSTANCE.Read(stream),
            @deployedAtTimestamp: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Controller value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@address)
            + FfiConverterString.INSTANCE.AllocationSize(value.@username)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@deployedAtTimestamp);
    }

    public override void Write(Controller value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@address, stream);
            FfiConverterString.INSTANCE.Write(value.@username, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@deployedAtTimestamp, stream);
    }
}



internal record ControllerQuery (
    Pagination @pagination, 
    FieldElement[] @contractAddresses, 
    string[] @usernames
) {
}

class FfiConverterTypeControllerQuery: FfiConverterRustBuffer<ControllerQuery> {
    public static FfiConverterTypeControllerQuery INSTANCE = new FfiConverterTypeControllerQuery();

    public override ControllerQuery Read(BigEndianStream stream) {
        return new ControllerQuery(
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream),
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @usernames: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ControllerQuery value) {
        return 0
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@usernames);
    }

    public override void Write(ControllerQuery value, BigEndianStream stream) {
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@usernames, stream);
    }
}



internal record Entity (
    FieldElement @worldAddress, 
    FieldElement @hashedKeys, 
    Struct[] @models, 
    ulong @createdAt, 
    ulong @updatedAt, 
    ulong @executedAt
) {
}

class FfiConverterTypeEntity: FfiConverterRustBuffer<Entity> {
    public static FfiConverterTypeEntity INSTANCE = new FfiConverterTypeEntity();

    public override Entity Read(BigEndianStream stream) {
        return new Entity(
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @hashedKeys: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @models: FfiConverterSequenceTypeStruct.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @executedAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Entity value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@hashedKeys)
            + FfiConverterSequenceTypeStruct.INSTANCE.AllocationSize(value.@models)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@executedAt);
    }

    public override void Write(Entity value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@hashedKeys, stream);
            FfiConverterSequenceTypeStruct.INSTANCE.Write(value.@models, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@executedAt, stream);
    }
}



internal record EnumOption (
    string @name, 
    Ty @ty
) {
}

class FfiConverterTypeEnumOption: FfiConverterRustBuffer<EnumOption> {
    public static FfiConverterTypeEnumOption INSTANCE = new FfiConverterTypeEnumOption();

    public override EnumOption Read(BigEndianStream stream) {
        return new EnumOption(
            @name: FfiConverterString.INSTANCE.Read(stream),
            @ty: FfiConverterTypeTy.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(EnumOption value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterTypeTy.INSTANCE.AllocationSize(value.@ty);
    }

    public override void Write(EnumOption value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterTypeTy.INSTANCE.Write(value.@ty, stream);
    }
}



internal record EnumType (
    string @name, 
    byte @option, 
    EnumOption[] @options
) {
}

class FfiConverterTypeEnumType: FfiConverterRustBuffer<EnumType> {
    public static FfiConverterTypeEnumType INSTANCE = new FfiConverterTypeEnumType();

    public override EnumType Read(BigEndianStream stream) {
        return new EnumType(
            @name: FfiConverterString.INSTANCE.Read(stream),
            @option: FfiConverterUInt8.INSTANCE.Read(stream),
            @options: FfiConverterSequenceTypeEnumOption.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(EnumType value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterUInt8.INSTANCE.AllocationSize(value.@option)
            + FfiConverterSequenceTypeEnumOption.INSTANCE.AllocationSize(value.@options);
    }

    public override void Write(EnumType value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterUInt8.INSTANCE.Write(value.@option, stream);
            FfiConverterSequenceTypeEnumOption.INSTANCE.Write(value.@options, stream);
    }
}



internal record Event (
    FieldElement[] @keys, 
    FieldElement[] @data, 
    FieldElement @transactionHash
) {
}

class FfiConverterTypeEvent: FfiConverterRustBuffer<Event> {
    public static FfiConverterTypeEvent INSTANCE = new FfiConverterTypeEvent();

    public override Event Read(BigEndianStream stream) {
        return new Event(
            @keys: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @data: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @transactionHash: FfiConverterTypeFieldElement.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Event value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@keys)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@data)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@transactionHash);
    }

    public override void Write(Event value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@keys, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@data, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@transactionHash, stream);
    }
}



internal record EventQuery (
    KeysClause? @keys, 
    Pagination @pagination
) {
}

class FfiConverterTypeEventQuery: FfiConverterRustBuffer<EventQuery> {
    public static FfiConverterTypeEventQuery INSTANCE = new FfiConverterTypeEventQuery();

    public override EventQuery Read(BigEndianStream stream) {
        return new EventQuery(
            @keys: FfiConverterOptionalTypeKeysClause.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(EventQuery value) {
        return 0
            + FfiConverterOptionalTypeKeysClause.INSTANCE.AllocationSize(value.@keys)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(EventQuery value, BigEndianStream stream) {
            FfiConverterOptionalTypeKeysClause.INSTANCE.Write(value.@keys, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record FixedSizeArray (
    Ty[] @array, 
    uint @size
) {
}

class FfiConverterTypeFixedSizeArray: FfiConverterRustBuffer<FixedSizeArray> {
    public static FfiConverterTypeFixedSizeArray INSTANCE = new FfiConverterTypeFixedSizeArray();

    public override FixedSizeArray Read(BigEndianStream stream) {
        return new FixedSizeArray(
            @array: FfiConverterSequenceTypeTy.INSTANCE.Read(stream),
            @size: FfiConverterUInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(FixedSizeArray value) {
        return 0
            + FfiConverterSequenceTypeTy.INSTANCE.AllocationSize(value.@array)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@size);
    }

    public override void Write(FixedSizeArray value, BigEndianStream stream) {
            FfiConverterSequenceTypeTy.INSTANCE.Write(value.@array, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@size, stream);
    }
}



internal record KeysClause (
    FieldElement?[] @keys, 
    PatternMatching @patternMatching, 
    string[] @models
) {
}

class FfiConverterTypeKeysClause: FfiConverterRustBuffer<KeysClause> {
    public static FfiConverterTypeKeysClause INSTANCE = new FfiConverterTypeKeysClause();

    public override KeysClause Read(BigEndianStream stream) {
        return new KeysClause(
            @keys: FfiConverterSequenceOptionalTypeFieldElement.INSTANCE.Read(stream),
            @patternMatching: FfiConverterTypePatternMatching.INSTANCE.Read(stream),
            @models: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(KeysClause value) {
        return 0
            + FfiConverterSequenceOptionalTypeFieldElement.INSTANCE.AllocationSize(value.@keys)
            + FfiConverterTypePatternMatching.INSTANCE.AllocationSize(value.@patternMatching)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@models);
    }

    public override void Write(KeysClause value, BigEndianStream stream) {
            FfiConverterSequenceOptionalTypeFieldElement.INSTANCE.Write(value.@keys, stream);
            FfiConverterTypePatternMatching.INSTANCE.Write(value.@patternMatching, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@models, stream);
    }
}



internal record Member (
    string @name, 
    Ty @ty, 
    bool @key
) {
}

class FfiConverterTypeMember: FfiConverterRustBuffer<Member> {
    public static FfiConverterTypeMember INSTANCE = new FfiConverterTypeMember();

    public override Member Read(BigEndianStream stream) {
        return new Member(
            @name: FfiConverterString.INSTANCE.Read(stream),
            @ty: FfiConverterTypeTy.INSTANCE.Read(stream),
            @key: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Member value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterTypeTy.INSTANCE.AllocationSize(value.@ty)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@key);
    }

    public override void Write(Member value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterTypeTy.INSTANCE.Write(value.@ty, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@key, stream);
    }
}



internal record MemberClause (
    string @model, 
    string @member, 
    ComparisonOperator @operator, 
    MemberValue @value
) {
}

class FfiConverterTypeMemberClause: FfiConverterRustBuffer<MemberClause> {
    public static FfiConverterTypeMemberClause INSTANCE = new FfiConverterTypeMemberClause();

    public override MemberClause Read(BigEndianStream stream) {
        return new MemberClause(
            @model: FfiConverterString.INSTANCE.Read(stream),
            @member: FfiConverterString.INSTANCE.Read(stream),
            @operator: FfiConverterTypeComparisonOperator.INSTANCE.Read(stream),
            @value: FfiConverterTypeMemberValue.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(MemberClause value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@model)
            + FfiConverterString.INSTANCE.AllocationSize(value.@member)
            + FfiConverterTypeComparisonOperator.INSTANCE.AllocationSize(value.@operator)
            + FfiConverterTypeMemberValue.INSTANCE.AllocationSize(value.@value);
    }

    public override void Write(MemberClause value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@model, stream);
            FfiConverterString.INSTANCE.Write(value.@member, stream);
            FfiConverterTypeComparisonOperator.INSTANCE.Write(value.@operator, stream);
            FfiConverterTypeMemberValue.INSTANCE.Write(value.@value, stream);
    }
}



internal record Message (
    string @message, 
    FieldElement[] @signature, 
    FieldElement @worldAddress
) {
}

class FfiConverterTypeMessage: FfiConverterRustBuffer<Message> {
    public static FfiConverterTypeMessage INSTANCE = new FfiConverterTypeMessage();

    public override Message Read(BigEndianStream stream) {
        return new Message(
            @message: FfiConverterString.INSTANCE.Read(stream),
            @signature: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Message value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@message)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@signature)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress);
    }

    public override void Write(Message value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@message, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@signature, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
    }
}



internal record Model (
    FieldElement @worldAddress, 
    Ty @schema, 
    string @namespace, 
    string @name, 
    FieldElement @selector, 
    uint @packedSize, 
    uint @unpackedSize, 
    FieldElement @classHash, 
    FieldElement @contractAddress, 
    string @layout, 
    bool @useLegacyStore
) {
}

class FfiConverterTypeModel: FfiConverterRustBuffer<Model> {
    public static FfiConverterTypeModel INSTANCE = new FfiConverterTypeModel();

    public override Model Read(BigEndianStream stream) {
        return new Model(
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @schema: FfiConverterTypeTy.INSTANCE.Read(stream),
            @namespace: FfiConverterString.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @selector: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @packedSize: FfiConverterUInt32.INSTANCE.Read(stream),
            @unpackedSize: FfiConverterUInt32.INSTANCE.Read(stream),
            @classHash: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @layout: FfiConverterString.INSTANCE.Read(stream),
            @useLegacyStore: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Model value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress)
            + FfiConverterTypeTy.INSTANCE.AllocationSize(value.@schema)
            + FfiConverterString.INSTANCE.AllocationSize(value.@namespace)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@selector)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@packedSize)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@unpackedSize)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@classHash)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@layout)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@useLegacyStore);
    }

    public override void Write(Model value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
            FfiConverterTypeTy.INSTANCE.Write(value.@schema, stream);
            FfiConverterString.INSTANCE.Write(value.@namespace, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@selector, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@packedSize, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@unpackedSize, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@classHash, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@layout, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@useLegacyStore, stream);
    }
}



internal record OrderBy (
    string @field, 
    OrderDirection @direction
) {
}

class FfiConverterTypeOrderBy: FfiConverterRustBuffer<OrderBy> {
    public static FfiConverterTypeOrderBy INSTANCE = new FfiConverterTypeOrderBy();

    public override OrderBy Read(BigEndianStream stream) {
        return new OrderBy(
            @field: FfiConverterString.INSTANCE.Read(stream),
            @direction: FfiConverterTypeOrderDirection.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(OrderBy value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@field)
            + FfiConverterTypeOrderDirection.INSTANCE.AllocationSize(value.@direction);
    }

    public override void Write(OrderBy value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@field, stream);
            FfiConverterTypeOrderDirection.INSTANCE.Write(value.@direction, stream);
    }
}



internal record PageAchievement (
    Achievement[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageAchievement: FfiConverterRustBuffer<PageAchievement> {
    public static FfiConverterTypePageAchievement INSTANCE = new FfiConverterTypePageAchievement();

    public override PageAchievement Read(BigEndianStream stream) {
        return new PageAchievement(
            @items: FfiConverterSequenceTypeAchievement.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageAchievement value) {
        return 0
            + FfiConverterSequenceTypeAchievement.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageAchievement value, BigEndianStream stream) {
            FfiConverterSequenceTypeAchievement.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageActivity (
    Activity[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageActivity: FfiConverterRustBuffer<PageActivity> {
    public static FfiConverterTypePageActivity INSTANCE = new FfiConverterTypePageActivity();

    public override PageActivity Read(BigEndianStream stream) {
        return new PageActivity(
            @items: FfiConverterSequenceTypeActivity.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageActivity value) {
        return 0
            + FfiConverterSequenceTypeActivity.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageActivity value, BigEndianStream stream) {
            FfiConverterSequenceTypeActivity.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageAggregationEntry (
    AggregationEntry[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageAggregationEntry: FfiConverterRustBuffer<PageAggregationEntry> {
    public static FfiConverterTypePageAggregationEntry INSTANCE = new FfiConverterTypePageAggregationEntry();

    public override PageAggregationEntry Read(BigEndianStream stream) {
        return new PageAggregationEntry(
            @items: FfiConverterSequenceTypeAggregationEntry.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageAggregationEntry value) {
        return 0
            + FfiConverterSequenceTypeAggregationEntry.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageAggregationEntry value, BigEndianStream stream) {
            FfiConverterSequenceTypeAggregationEntry.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageController (
    Controller[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageController: FfiConverterRustBuffer<PageController> {
    public static FfiConverterTypePageController INSTANCE = new FfiConverterTypePageController();

    public override PageController Read(BigEndianStream stream) {
        return new PageController(
            @items: FfiConverterSequenceTypeController.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageController value) {
        return 0
            + FfiConverterSequenceTypeController.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageController value, BigEndianStream stream) {
            FfiConverterSequenceTypeController.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageEntity (
    Entity[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageEntity: FfiConverterRustBuffer<PageEntity> {
    public static FfiConverterTypePageEntity INSTANCE = new FfiConverterTypePageEntity();

    public override PageEntity Read(BigEndianStream stream) {
        return new PageEntity(
            @items: FfiConverterSequenceTypeEntity.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageEntity value) {
        return 0
            + FfiConverterSequenceTypeEntity.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageEntity value, BigEndianStream stream) {
            FfiConverterSequenceTypeEntity.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageEvent (
    Event[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageEvent: FfiConverterRustBuffer<PageEvent> {
    public static FfiConverterTypePageEvent INSTANCE = new FfiConverterTypePageEvent();

    public override PageEvent Read(BigEndianStream stream) {
        return new PageEvent(
            @items: FfiConverterSequenceTypeEvent.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageEvent value) {
        return 0
            + FfiConverterSequenceTypeEvent.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageEvent value, BigEndianStream stream) {
            FfiConverterSequenceTypeEvent.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PagePlayerAchievement (
    PlayerAchievementEntry[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePagePlayerAchievement: FfiConverterRustBuffer<PagePlayerAchievement> {
    public static FfiConverterTypePagePlayerAchievement INSTANCE = new FfiConverterTypePagePlayerAchievement();

    public override PagePlayerAchievement Read(BigEndianStream stream) {
        return new PagePlayerAchievement(
            @items: FfiConverterSequenceTypePlayerAchievementEntry.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PagePlayerAchievement value) {
        return 0
            + FfiConverterSequenceTypePlayerAchievementEntry.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PagePlayerAchievement value, BigEndianStream stream) {
            FfiConverterSequenceTypePlayerAchievementEntry.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageToken (
    Token[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageToken: FfiConverterRustBuffer<PageToken> {
    public static FfiConverterTypePageToken INSTANCE = new FfiConverterTypePageToken();

    public override PageToken Read(BigEndianStream stream) {
        return new PageToken(
            @items: FfiConverterSequenceTypeToken.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageToken value) {
        return 0
            + FfiConverterSequenceTypeToken.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageToken value, BigEndianStream stream) {
            FfiConverterSequenceTypeToken.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageTokenBalance (
    TokenBalance[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageTokenBalance: FfiConverterRustBuffer<PageTokenBalance> {
    public static FfiConverterTypePageTokenBalance INSTANCE = new FfiConverterTypePageTokenBalance();

    public override PageTokenBalance Read(BigEndianStream stream) {
        return new PageTokenBalance(
            @items: FfiConverterSequenceTypeTokenBalance.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageTokenBalance value) {
        return 0
            + FfiConverterSequenceTypeTokenBalance.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageTokenBalance value, BigEndianStream stream) {
            FfiConverterSequenceTypeTokenBalance.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageTokenContract (
    TokenContract[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageTokenContract: FfiConverterRustBuffer<PageTokenContract> {
    public static FfiConverterTypePageTokenContract INSTANCE = new FfiConverterTypePageTokenContract();

    public override PageTokenContract Read(BigEndianStream stream) {
        return new PageTokenContract(
            @items: FfiConverterSequenceTypeTokenContract.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageTokenContract value) {
        return 0
            + FfiConverterSequenceTypeTokenContract.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageTokenContract value, BigEndianStream stream) {
            FfiConverterSequenceTypeTokenContract.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageTokenTransfer (
    TokenTransfer[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageTokenTransfer: FfiConverterRustBuffer<PageTokenTransfer> {
    public static FfiConverterTypePageTokenTransfer INSTANCE = new FfiConverterTypePageTokenTransfer();

    public override PageTokenTransfer Read(BigEndianStream stream) {
        return new PageTokenTransfer(
            @items: FfiConverterSequenceTypeTokenTransfer.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageTokenTransfer value) {
        return 0
            + FfiConverterSequenceTypeTokenTransfer.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageTokenTransfer value, BigEndianStream stream) {
            FfiConverterSequenceTypeTokenTransfer.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record PageTransaction (
    Transaction[] @items, 
    string? @nextCursor
) {
}

class FfiConverterTypePageTransaction: FfiConverterRustBuffer<PageTransaction> {
    public static FfiConverterTypePageTransaction INSTANCE = new FfiConverterTypePageTransaction();

    public override PageTransaction Read(BigEndianStream stream) {
        return new PageTransaction(
            @items: FfiConverterSequenceTypeTransaction.INSTANCE.Read(stream),
            @nextCursor: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PageTransaction value) {
        return 0
            + FfiConverterSequenceTypeTransaction.INSTANCE.AllocationSize(value.@items)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nextCursor);
    }

    public override void Write(PageTransaction value, BigEndianStream stream) {
            FfiConverterSequenceTypeTransaction.INSTANCE.Write(value.@items, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nextCursor, stream);
    }
}



internal record Pagination (
    string? @cursor, 
    uint? @limit, 
    PaginationDirection @direction, 
    OrderBy[] @orderBy
) {
}

class FfiConverterTypePagination: FfiConverterRustBuffer<Pagination> {
    public static FfiConverterTypePagination INSTANCE = new FfiConverterTypePagination();

    public override Pagination Read(BigEndianStream stream) {
        return new Pagination(
            @cursor: FfiConverterOptionalString.INSTANCE.Read(stream),
            @limit: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @direction: FfiConverterTypePaginationDirection.INSTANCE.Read(stream),
            @orderBy: FfiConverterSequenceTypeOrderBy.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Pagination value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@cursor)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@limit)
            + FfiConverterTypePaginationDirection.INSTANCE.AllocationSize(value.@direction)
            + FfiConverterSequenceTypeOrderBy.INSTANCE.AllocationSize(value.@orderBy);
    }

    public override void Write(Pagination value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@cursor, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@limit, stream);
            FfiConverterTypePaginationDirection.INSTANCE.Write(value.@direction, stream);
            FfiConverterSequenceTypeOrderBy.INSTANCE.Write(value.@orderBy, stream);
    }
}



internal record PlayerAchievementEntry (
    FieldElement @playerAddress, 
    PlayerAchievementStats @stats, 
    PlayerAchievementProgress[] @achievements
) {
}

class FfiConverterTypePlayerAchievementEntry: FfiConverterRustBuffer<PlayerAchievementEntry> {
    public static FfiConverterTypePlayerAchievementEntry INSTANCE = new FfiConverterTypePlayerAchievementEntry();

    public override PlayerAchievementEntry Read(BigEndianStream stream) {
        return new PlayerAchievementEntry(
            @playerAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @stats: FfiConverterTypePlayerAchievementStats.INSTANCE.Read(stream),
            @achievements: FfiConverterSequenceTypePlayerAchievementProgress.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PlayerAchievementEntry value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@playerAddress)
            + FfiConverterTypePlayerAchievementStats.INSTANCE.AllocationSize(value.@stats)
            + FfiConverterSequenceTypePlayerAchievementProgress.INSTANCE.AllocationSize(value.@achievements);
    }

    public override void Write(PlayerAchievementEntry value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@playerAddress, stream);
            FfiConverterTypePlayerAchievementStats.INSTANCE.Write(value.@stats, stream);
            FfiConverterSequenceTypePlayerAchievementProgress.INSTANCE.Write(value.@achievements, stream);
    }
}



internal record PlayerAchievementProgress (
    Achievement @achievement, 
    TaskProgress[] @taskProgress, 
    bool @completed, 
    double @progressPercentage
) {
}

class FfiConverterTypePlayerAchievementProgress: FfiConverterRustBuffer<PlayerAchievementProgress> {
    public static FfiConverterTypePlayerAchievementProgress INSTANCE = new FfiConverterTypePlayerAchievementProgress();

    public override PlayerAchievementProgress Read(BigEndianStream stream) {
        return new PlayerAchievementProgress(
            @achievement: FfiConverterTypeAchievement.INSTANCE.Read(stream),
            @taskProgress: FfiConverterSequenceTypeTaskProgress.INSTANCE.Read(stream),
            @completed: FfiConverterBoolean.INSTANCE.Read(stream),
            @progressPercentage: FfiConverterDouble.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PlayerAchievementProgress value) {
        return 0
            + FfiConverterTypeAchievement.INSTANCE.AllocationSize(value.@achievement)
            + FfiConverterSequenceTypeTaskProgress.INSTANCE.AllocationSize(value.@taskProgress)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@completed)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@progressPercentage);
    }

    public override void Write(PlayerAchievementProgress value, BigEndianStream stream) {
            FfiConverterTypeAchievement.INSTANCE.Write(value.@achievement, stream);
            FfiConverterSequenceTypeTaskProgress.INSTANCE.Write(value.@taskProgress, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@completed, stream);
            FfiConverterDouble.INSTANCE.Write(value.@progressPercentage, stream);
    }
}



internal record PlayerAchievementQuery (
    FieldElement[] @worldAddresses, 
    string[] @namespaces, 
    FieldElement[] @playerAddresses, 
    Pagination @pagination
) {
}

class FfiConverterTypePlayerAchievementQuery: FfiConverterRustBuffer<PlayerAchievementQuery> {
    public static FfiConverterTypePlayerAchievementQuery INSTANCE = new FfiConverterTypePlayerAchievementQuery();

    public override PlayerAchievementQuery Read(BigEndianStream stream) {
        return new PlayerAchievementQuery(
            @worldAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @namespaces: FfiConverterSequenceString.INSTANCE.Read(stream),
            @playerAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PlayerAchievementQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddresses)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@namespaces)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@playerAddresses)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(PlayerAchievementQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@worldAddresses, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@namespaces, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@playerAddresses, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record PlayerAchievementStats (
    uint @totalPoints, 
    uint @completedAchievements, 
    uint @totalAchievements, 
    double @completionPercentage, 
    ulong? @lastAchievementAt, 
    ulong @createdAt, 
    ulong @updatedAt
) {
}

class FfiConverterTypePlayerAchievementStats: FfiConverterRustBuffer<PlayerAchievementStats> {
    public static FfiConverterTypePlayerAchievementStats INSTANCE = new FfiConverterTypePlayerAchievementStats();

    public override PlayerAchievementStats Read(BigEndianStream stream) {
        return new PlayerAchievementStats(
            @totalPoints: FfiConverterUInt32.INSTANCE.Read(stream),
            @completedAchievements: FfiConverterUInt32.INSTANCE.Read(stream),
            @totalAchievements: FfiConverterUInt32.INSTANCE.Read(stream),
            @completionPercentage: FfiConverterDouble.INSTANCE.Read(stream),
            @lastAchievementAt: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @createdAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @updatedAt: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PlayerAchievementStats value) {
        return 0
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@totalPoints)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@completedAchievements)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@totalAchievements)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@completionPercentage)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@lastAchievementAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@createdAt)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@updatedAt);
    }

    public override void Write(PlayerAchievementStats value, BigEndianStream stream) {
            FfiConverterUInt32.INSTANCE.Write(value.@totalPoints, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@completedAchievements, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@totalAchievements, stream);
            FfiConverterDouble.INSTANCE.Write(value.@completionPercentage, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@lastAchievementAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@createdAt, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@updatedAt, stream);
    }
}



internal record Query (
    FieldElement[] @worldAddresses, 
    Pagination @pagination, 
    Clause? @clause, 
    bool @noHashedKeys, 
    string[] @models, 
    bool @historical
) {
}

class FfiConverterTypeQuery: FfiConverterRustBuffer<Query> {
    public static FfiConverterTypeQuery INSTANCE = new FfiConverterTypeQuery();

    public override Query Read(BigEndianStream stream) {
        return new Query(
            @worldAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream),
            @clause: FfiConverterOptionalTypeClause.INSTANCE.Read(stream),
            @noHashedKeys: FfiConverterBoolean.INSTANCE.Read(stream),
            @models: FfiConverterSequenceString.INSTANCE.Read(stream),
            @historical: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Query value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddresses)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination)
            + FfiConverterOptionalTypeClause.INSTANCE.AllocationSize(value.@clause)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@noHashedKeys)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@models)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@historical);
    }

    public override void Write(Query value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@worldAddresses, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
            FfiConverterOptionalTypeClause.INSTANCE.Write(value.@clause, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@noHashedKeys, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@models, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@historical, stream);
    }
}



internal record Signature (
    FieldElement @r, 
    FieldElement @s
) {
}

class FfiConverterTypeSignature: FfiConverterRustBuffer<Signature> {
    public static FfiConverterTypeSignature INSTANCE = new FfiConverterTypeSignature();

    public override Signature Read(BigEndianStream stream) {
        return new Signature(
            @r: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @s: FfiConverterTypeFieldElement.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Signature value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@r)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@s);
    }

    public override void Write(Signature value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@r, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@s, stream);
    }
}



internal record SqlField (
    string @name, 
    SqlValue @value
) {
}

class FfiConverterTypeSqlField: FfiConverterRustBuffer<SqlField> {
    public static FfiConverterTypeSqlField INSTANCE = new FfiConverterTypeSqlField();

    public override SqlField Read(BigEndianStream stream) {
        return new SqlField(
            @name: FfiConverterString.INSTANCE.Read(stream),
            @value: FfiConverterTypeSqlValue.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SqlField value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterTypeSqlValue.INSTANCE.AllocationSize(value.@value);
    }

    public override void Write(SqlField value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterTypeSqlValue.INSTANCE.Write(value.@value, stream);
    }
}



internal record SqlRow (
    SqlField[] @fields
) {
}

class FfiConverterTypeSqlRow: FfiConverterRustBuffer<SqlRow> {
    public static FfiConverterTypeSqlRow INSTANCE = new FfiConverterTypeSqlRow();

    public override SqlRow Read(BigEndianStream stream) {
        return new SqlRow(
            @fields: FfiConverterSequenceTypeSqlField.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SqlRow value) {
        return 0
            + FfiConverterSequenceTypeSqlField.INSTANCE.AllocationSize(value.@fields);
    }

    public override void Write(SqlRow value, BigEndianStream stream) {
            FfiConverterSequenceTypeSqlField.INSTANCE.Write(value.@fields, stream);
    }
}



internal record Struct (
    string @name, 
    Member[] @children
) {
}

class FfiConverterTypeStruct: FfiConverterRustBuffer<Struct> {
    public static FfiConverterTypeStruct INSTANCE = new FfiConverterTypeStruct();

    public override Struct Read(BigEndianStream stream) {
        return new Struct(
            @name: FfiConverterString.INSTANCE.Read(stream),
            @children: FfiConverterSequenceTypeMember.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Struct value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterSequenceTypeMember.INSTANCE.AllocationSize(value.@children);
    }

    public override void Write(Struct value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterSequenceTypeMember.INSTANCE.Write(value.@children, stream);
    }
}



internal record TaskProgress (
    string @taskId, 
    uint @count, 
    bool @completed
) {
}

class FfiConverterTypeTaskProgress: FfiConverterRustBuffer<TaskProgress> {
    public static FfiConverterTypeTaskProgress INSTANCE = new FfiConverterTypeTaskProgress();

    public override TaskProgress Read(BigEndianStream stream) {
        return new TaskProgress(
            @taskId: FfiConverterString.INSTANCE.Read(stream),
            @count: FfiConverterUInt32.INSTANCE.Read(stream),
            @completed: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TaskProgress value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@taskId)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@count)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@completed);
    }

    public override void Write(TaskProgress value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@taskId, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@count, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@completed, stream);
    }
}



internal record Token (
    FieldElement @contractAddress, 
    U256? @tokenId, 
    string @name, 
    string @symbol, 
    byte @decimals, 
    string @metadata, 
    U256? @totalSupply
) {
}

class FfiConverterTypeToken: FfiConverterRustBuffer<Token> {
    public static FfiConverterTypeToken INSTANCE = new FfiConverterTypeToken();

    public override Token Read(BigEndianStream stream) {
        return new Token(
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @tokenId: FfiConverterOptionalTypeU256.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @symbol: FfiConverterString.INSTANCE.Read(stream),
            @decimals: FfiConverterUInt8.INSTANCE.Read(stream),
            @metadata: FfiConverterString.INSTANCE.Read(stream),
            @totalSupply: FfiConverterOptionalTypeU256.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Token value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterOptionalTypeU256.INSTANCE.AllocationSize(value.@tokenId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterString.INSTANCE.AllocationSize(value.@symbol)
            + FfiConverterUInt8.INSTANCE.AllocationSize(value.@decimals)
            + FfiConverterString.INSTANCE.AllocationSize(value.@metadata)
            + FfiConverterOptionalTypeU256.INSTANCE.AllocationSize(value.@totalSupply);
    }

    public override void Write(Token value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterOptionalTypeU256.INSTANCE.Write(value.@tokenId, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterString.INSTANCE.Write(value.@symbol, stream);
            FfiConverterUInt8.INSTANCE.Write(value.@decimals, stream);
            FfiConverterString.INSTANCE.Write(value.@metadata, stream);
            FfiConverterOptionalTypeU256.INSTANCE.Write(value.@totalSupply, stream);
    }
}



internal record TokenBalance (
    U256 @balance, 
    FieldElement @accountAddress, 
    FieldElement @contractAddress, 
    U256? @tokenId
) {
}

class FfiConverterTypeTokenBalance: FfiConverterRustBuffer<TokenBalance> {
    public static FfiConverterTypeTokenBalance INSTANCE = new FfiConverterTypeTokenBalance();

    public override TokenBalance Read(BigEndianStream stream) {
        return new TokenBalance(
            @balance: FfiConverterTypeU256.INSTANCE.Read(stream),
            @accountAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @tokenId: FfiConverterOptionalTypeU256.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenBalance value) {
        return 0
            + FfiConverterTypeU256.INSTANCE.AllocationSize(value.@balance)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@accountAddress)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterOptionalTypeU256.INSTANCE.AllocationSize(value.@tokenId);
    }

    public override void Write(TokenBalance value, BigEndianStream stream) {
            FfiConverterTypeU256.INSTANCE.Write(value.@balance, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@accountAddress, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterOptionalTypeU256.INSTANCE.Write(value.@tokenId, stream);
    }
}



internal record TokenBalanceQuery (
    FieldElement[] @contractAddresses, 
    FieldElement[] @accountAddresses, 
    U256[] @tokenIds, 
    Pagination @pagination
) {
}

class FfiConverterTypeTokenBalanceQuery: FfiConverterRustBuffer<TokenBalanceQuery> {
    public static FfiConverterTypeTokenBalanceQuery INSTANCE = new FfiConverterTypeTokenBalanceQuery();

    public override TokenBalanceQuery Read(BigEndianStream stream) {
        return new TokenBalanceQuery(
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @accountAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @tokenIds: FfiConverterSequenceTypeU256.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenBalanceQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@accountAddresses)
            + FfiConverterSequenceTypeU256.INSTANCE.AllocationSize(value.@tokenIds)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(TokenBalanceQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@accountAddresses, stream);
            FfiConverterSequenceTypeU256.INSTANCE.Write(value.@tokenIds, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record TokenContract (
    FieldElement @contractAddress, 
    string @name, 
    string @symbol, 
    byte @decimals, 
    string @metadata, 
    string @tokenMetadata, 
    U256? @totalSupply
) {
}

class FfiConverterTypeTokenContract: FfiConverterRustBuffer<TokenContract> {
    public static FfiConverterTypeTokenContract INSTANCE = new FfiConverterTypeTokenContract();

    public override TokenContract Read(BigEndianStream stream) {
        return new TokenContract(
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @symbol: FfiConverterString.INSTANCE.Read(stream),
            @decimals: FfiConverterUInt8.INSTANCE.Read(stream),
            @metadata: FfiConverterString.INSTANCE.Read(stream),
            @tokenMetadata: FfiConverterString.INSTANCE.Read(stream),
            @totalSupply: FfiConverterOptionalTypeU256.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenContract value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterString.INSTANCE.AllocationSize(value.@symbol)
            + FfiConverterUInt8.INSTANCE.AllocationSize(value.@decimals)
            + FfiConverterString.INSTANCE.AllocationSize(value.@metadata)
            + FfiConverterString.INSTANCE.AllocationSize(value.@tokenMetadata)
            + FfiConverterOptionalTypeU256.INSTANCE.AllocationSize(value.@totalSupply);
    }

    public override void Write(TokenContract value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterString.INSTANCE.Write(value.@symbol, stream);
            FfiConverterUInt8.INSTANCE.Write(value.@decimals, stream);
            FfiConverterString.INSTANCE.Write(value.@metadata, stream);
            FfiConverterString.INSTANCE.Write(value.@tokenMetadata, stream);
            FfiConverterOptionalTypeU256.INSTANCE.Write(value.@totalSupply, stream);
    }
}



internal record TokenContractQuery (
    FieldElement[] @contractAddresses, 
    ContractType[] @contractTypes, 
    Pagination @pagination
) {
}

class FfiConverterTypeTokenContractQuery: FfiConverterRustBuffer<TokenContractQuery> {
    public static FfiConverterTypeTokenContractQuery INSTANCE = new FfiConverterTypeTokenContractQuery();

    public override TokenContractQuery Read(BigEndianStream stream) {
        return new TokenContractQuery(
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @contractTypes: FfiConverterSequenceTypeContractType.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenContractQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceTypeContractType.INSTANCE.AllocationSize(value.@contractTypes)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(TokenContractQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceTypeContractType.INSTANCE.Write(value.@contractTypes, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record TokenQuery (
    FieldElement[] @contractAddresses, 
    U256[] @tokenIds, 
    AttributeFilter[] @attributeFilters, 
    Pagination @pagination
) {
}

class FfiConverterTypeTokenQuery: FfiConverterRustBuffer<TokenQuery> {
    public static FfiConverterTypeTokenQuery INSTANCE = new FfiConverterTypeTokenQuery();

    public override TokenQuery Read(BigEndianStream stream) {
        return new TokenQuery(
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @tokenIds: FfiConverterSequenceTypeU256.INSTANCE.Read(stream),
            @attributeFilters: FfiConverterSequenceTypeAttributeFilter.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceTypeU256.INSTANCE.AllocationSize(value.@tokenIds)
            + FfiConverterSequenceTypeAttributeFilter.INSTANCE.AllocationSize(value.@attributeFilters)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(TokenQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceTypeU256.INSTANCE.Write(value.@tokenIds, stream);
            FfiConverterSequenceTypeAttributeFilter.INSTANCE.Write(value.@attributeFilters, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record TokenTransfer (
    string @id, 
    FieldElement @contractAddress, 
    FieldElement @fromAddress, 
    FieldElement @toAddress, 
    U256 @amount, 
    U256? @tokenId, 
    ulong @executedAt, 
    string? @eventId
) {
}

class FfiConverterTypeTokenTransfer: FfiConverterRustBuffer<TokenTransfer> {
    public static FfiConverterTypeTokenTransfer INSTANCE = new FfiConverterTypeTokenTransfer();

    public override TokenTransfer Read(BigEndianStream stream) {
        return new TokenTransfer(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @fromAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @toAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @amount: FfiConverterTypeU256.INSTANCE.Read(stream),
            @tokenId: FfiConverterOptionalTypeU256.INSTANCE.Read(stream),
            @executedAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @eventId: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenTransfer value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@fromAddress)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@toAddress)
            + FfiConverterTypeU256.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterOptionalTypeU256.INSTANCE.AllocationSize(value.@tokenId)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@executedAt)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@eventId);
    }

    public override void Write(TokenTransfer value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@fromAddress, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@toAddress, stream);
            FfiConverterTypeU256.INSTANCE.Write(value.@amount, stream);
            FfiConverterOptionalTypeU256.INSTANCE.Write(value.@tokenId, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@executedAt, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@eventId, stream);
    }
}



internal record TokenTransferQuery (
    FieldElement[] @contractAddresses, 
    FieldElement[] @accountAddresses, 
    U256[] @tokenIds, 
    Pagination @pagination
) {
}

class FfiConverterTypeTokenTransferQuery: FfiConverterRustBuffer<TokenTransferQuery> {
    public static FfiConverterTypeTokenTransferQuery INSTANCE = new FfiConverterTypeTokenTransferQuery();

    public override TokenTransferQuery Read(BigEndianStream stream) {
        return new TokenTransferQuery(
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @accountAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @tokenIds: FfiConverterSequenceTypeU256.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenTransferQuery value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@accountAddresses)
            + FfiConverterSequenceTypeU256.INSTANCE.AllocationSize(value.@tokenIds)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(TokenTransferQuery value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@accountAddresses, stream);
            FfiConverterSequenceTypeU256.INSTANCE.Write(value.@tokenIds, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record Transaction (
    FieldElement @transactionHash, 
    FieldElement @senderAddress, 
    FieldElement[] @calldata, 
    FieldElement @maxFee, 
    FieldElement[] @signature, 
    FieldElement @nonce, 
    ulong @blockNumber, 
    string @transactionType, 
    ulong @blockTimestamp, 
    TransactionCall[] @calls, 
    FieldElement[] @uniqueModels
) {
}

class FfiConverterTypeTransaction: FfiConverterRustBuffer<Transaction> {
    public static FfiConverterTypeTransaction INSTANCE = new FfiConverterTypeTransaction();

    public override Transaction Read(BigEndianStream stream) {
        return new Transaction(
            @transactionHash: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @senderAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @calldata: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @maxFee: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @signature: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @nonce: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @blockNumber: FfiConverterUInt64.INSTANCE.Read(stream),
            @transactionType: FfiConverterString.INSTANCE.Read(stream),
            @blockTimestamp: FfiConverterUInt64.INSTANCE.Read(stream),
            @calls: FfiConverterSequenceTypeTransactionCall.INSTANCE.Read(stream),
            @uniqueModels: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Transaction value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@transactionHash)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@senderAddress)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@calldata)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@maxFee)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@signature)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@nonce)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@blockNumber)
            + FfiConverterString.INSTANCE.AllocationSize(value.@transactionType)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@blockTimestamp)
            + FfiConverterSequenceTypeTransactionCall.INSTANCE.AllocationSize(value.@calls)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@uniqueModels);
    }

    public override void Write(Transaction value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@transactionHash, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@senderAddress, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@calldata, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@maxFee, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@signature, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@nonce, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@blockNumber, stream);
            FfiConverterString.INSTANCE.Write(value.@transactionType, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@blockTimestamp, stream);
            FfiConverterSequenceTypeTransactionCall.INSTANCE.Write(value.@calls, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@uniqueModels, stream);
    }
}



internal record TransactionCall (
    FieldElement @contractAddress, 
    string @entrypoint, 
    FieldElement[] @calldata, 
    CallType @callType, 
    FieldElement @callerAddress
) {
}

class FfiConverterTypeTransactionCall: FfiConverterRustBuffer<TransactionCall> {
    public static FfiConverterTypeTransactionCall INSTANCE = new FfiConverterTypeTransactionCall();

    public override TransactionCall Read(BigEndianStream stream) {
        return new TransactionCall(
            @contractAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @entrypoint: FfiConverterString.INSTANCE.Read(stream),
            @calldata: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @callType: FfiConverterTypeCallType.INSTANCE.Read(stream),
            @callerAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TransactionCall value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@entrypoint)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@calldata)
            + FfiConverterTypeCallType.INSTANCE.AllocationSize(value.@callType)
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@callerAddress);
    }

    public override void Write(TransactionCall value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@contractAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@entrypoint, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@calldata, stream);
            FfiConverterTypeCallType.INSTANCE.Write(value.@callType, stream);
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@callerAddress, stream);
    }
}



internal record TransactionFilter (
    FieldElement[] @transactionHashes, 
    FieldElement[] @callerAddresses, 
    FieldElement[] @contractAddresses, 
    string[] @entrypoints, 
    FieldElement[] @modelSelectors, 
    ulong? @fromBlock, 
    ulong? @toBlock
) {
}

class FfiConverterTypeTransactionFilter: FfiConverterRustBuffer<TransactionFilter> {
    public static FfiConverterTypeTransactionFilter INSTANCE = new FfiConverterTypeTransactionFilter();

    public override TransactionFilter Read(BigEndianStream stream) {
        return new TransactionFilter(
            @transactionHashes: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @callerAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @contractAddresses: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @entrypoints: FfiConverterSequenceString.INSTANCE.Read(stream),
            @modelSelectors: FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream),
            @fromBlock: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @toBlock: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TransactionFilter value) {
        return 0
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@transactionHashes)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@callerAddresses)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@contractAddresses)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@entrypoints)
            + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(value.@modelSelectors)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@fromBlock)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@toBlock);
    }

    public override void Write(TransactionFilter value, BigEndianStream stream) {
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@transactionHashes, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@callerAddresses, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@contractAddresses, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@entrypoints, stream);
            FfiConverterSequenceTypeFieldElement.INSTANCE.Write(value.@modelSelectors, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@fromBlock, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@toBlock, stream);
    }
}



internal record TransactionQuery (
    TransactionFilter? @filter, 
    Pagination @pagination
) {
}

class FfiConverterTypeTransactionQuery: FfiConverterRustBuffer<TransactionQuery> {
    public static FfiConverterTypeTransactionQuery INSTANCE = new FfiConverterTypeTransactionQuery();

    public override TransactionQuery Read(BigEndianStream stream) {
        return new TransactionQuery(
            @filter: FfiConverterOptionalTypeTransactionFilter.INSTANCE.Read(stream),
            @pagination: FfiConverterTypePagination.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TransactionQuery value) {
        return 0
            + FfiConverterOptionalTypeTransactionFilter.INSTANCE.AllocationSize(value.@filter)
            + FfiConverterTypePagination.INSTANCE.AllocationSize(value.@pagination);
    }

    public override void Write(TransactionQuery value, BigEndianStream stream) {
            FfiConverterOptionalTypeTransactionFilter.INSTANCE.Write(value.@filter, stream);
            FfiConverterTypePagination.INSTANCE.Write(value.@pagination, stream);
    }
}



internal record World (
    FieldElement @worldAddress, 
    Model[] @models
) {
}

class FfiConverterTypeWorld: FfiConverterRustBuffer<World> {
    public static FfiConverterTypeWorld INSTANCE = new FfiConverterTypeWorld();

    public override World Read(BigEndianStream stream) {
        return new World(
            @worldAddress: FfiConverterTypeFieldElement.INSTANCE.Read(stream),
            @models: FfiConverterSequenceTypeModel.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(World value) {
        return 0
            + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(value.@worldAddress)
            + FfiConverterSequenceTypeModel.INSTANCE.AllocationSize(value.@models);
    }

    public override void Write(World value, BigEndianStream stream) {
            FfiConverterTypeFieldElement.INSTANCE.Write(value.@worldAddress, stream);
            FfiConverterSequenceTypeModel.INSTANCE.Write(value.@models, stream);
    }
}





internal enum CallType: int {
    
    Execute,
    ExecuteFromOutside
}

class FfiConverterTypeCallType: FfiConverterRustBuffer<CallType> {
    public static FfiConverterTypeCallType INSTANCE = new FfiConverterTypeCallType();

    public override CallType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(CallType), value)) {
            return (CallType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeCallType.Read()", value));
        }
    }

    public override int AllocationSize(CallType value) {
        return 4;
    }

    public override void Write(CallType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal record Clause {
    
    public record HashedKeys (
        FieldElement[] @keys
    ) : Clause {}
    
    public record Keys (
        KeysClause @clause
    ) : Clause {}
    
    public record Member (
        MemberClause @clause
    ) : Clause {}
    
    public record Composite (
        CompositeClause @clause
    ) : Clause {}
    

    
}

class FfiConverterTypeClause : FfiConverterRustBuffer<Clause>{
    public static FfiConverterRustBuffer<Clause> INSTANCE = new FfiConverterTypeClause();

    public override Clause Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new Clause.HashedKeys(
                    FfiConverterSequenceTypeFieldElement.INSTANCE.Read(stream)
                );
            case 2:
                return new Clause.Keys(
                    FfiConverterTypeKeysClause.INSTANCE.Read(stream)
                );
            case 3:
                return new Clause.Member(
                    FfiConverterTypeMemberClause.INSTANCE.Read(stream)
                );
            case 4:
                return new Clause.Composite(
                    FfiConverterTypeCompositeClause.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeClause.Read()", value));
        }
    }

    public override int AllocationSize(Clause value) {
        switch (value) {
            case Clause.HashedKeys variant_value:
                return 4
                    + FfiConverterSequenceTypeFieldElement.INSTANCE.AllocationSize(variant_value.@keys);
            case Clause.Keys variant_value:
                return 4
                    + FfiConverterTypeKeysClause.INSTANCE.AllocationSize(variant_value.@clause);
            case Clause.Member variant_value:
                return 4
                    + FfiConverterTypeMemberClause.INSTANCE.AllocationSize(variant_value.@clause);
            case Clause.Composite variant_value:
                return 4
                    + FfiConverterTypeCompositeClause.INSTANCE.AllocationSize(variant_value.@clause);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeClause.AllocationSize()", value));
        }
    }

    public override void Write(Clause value, BigEndianStream stream) {
        switch (value) {
            case Clause.HashedKeys variant_value:
                stream.WriteInt(1);
                FfiConverterSequenceTypeFieldElement.INSTANCE.Write(variant_value.@keys, stream);
                break;
            case Clause.Keys variant_value:
                stream.WriteInt(2);
                FfiConverterTypeKeysClause.INSTANCE.Write(variant_value.@clause, stream);
                break;
            case Clause.Member variant_value:
                stream.WriteInt(3);
                FfiConverterTypeMemberClause.INSTANCE.Write(variant_value.@clause, stream);
                break;
            case Clause.Composite variant_value:
                stream.WriteInt(4);
                FfiConverterTypeCompositeClause.INSTANCE.Write(variant_value.@clause, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeClause.Write()", value));
        }
    }
}







internal enum ComparisonOperator: int {
    
    Eq,
    Neq,
    Gt,
    Gte,
    Lt,
    Lte,
    In,
    NotIn,
    Contains,
    ContainsAll,
    ContainsAny,
    ArrayLengthEq,
    ArrayLengthGt,
    ArrayLengthLt
}

class FfiConverterTypeComparisonOperator: FfiConverterRustBuffer<ComparisonOperator> {
    public static FfiConverterTypeComparisonOperator INSTANCE = new FfiConverterTypeComparisonOperator();

    public override ComparisonOperator Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(ComparisonOperator), value)) {
            return (ComparisonOperator)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeComparisonOperator.Read()", value));
        }
    }

    public override int AllocationSize(ComparisonOperator value) {
        return 4;
    }

    public override void Write(ComparisonOperator value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal enum ContractType: int {
    
    World,
    Erc20,
    Erc721,
    Erc1155,
    Udc,
    Other
}

class FfiConverterTypeContractType: FfiConverterRustBuffer<ContractType> {
    public static FfiConverterTypeContractType INSTANCE = new FfiConverterTypeContractType();

    public override ContractType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(ContractType), value)) {
            return (ContractType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeContractType.Read()", value));
        }
    }

    public override int AllocationSize(ContractType value) {
        return 4;
    }

    public override void Write(ContractType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal class DojoException: UniffiException {
    DojoException(string message): base(message) {}

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.
    
    public class ClientException: DojoException {
        public ClientException(string message): base(message) {}
    }
    
    public class SerializationException: DojoException {
        public SerializationException(string message): base(message) {}
    }
    
    public class NetworkException: DojoException {
        public NetworkException(string message): base(message) {}
    }
    
    public class InvalidInput: DojoException {
        public InvalidInput(string message): base(message) {}
    }
    
    public class ConnectionException: DojoException {
        public ConnectionException(string message): base(message) {}
    }
    
    public class PublishException: DojoException {
        public PublishException(string message): base(message) {}
    }
    
    public class QueryException: DojoException {
        public QueryException(string message): base(message) {}
    }
    
    public class SubscriptionException: DojoException {
        public SubscriptionException(string message): base(message) {}
    }
    
}

class FfiConverterTypeDojoError : FfiConverterRustBuffer<DojoException>, CallStatusErrorHandler<DojoException> {
    public static FfiConverterTypeDojoError INSTANCE = new FfiConverterTypeDojoError();

    public override DojoException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1: return new DojoException.ClientException(FfiConverterString.INSTANCE.Read(stream));
            case 2: return new DojoException.SerializationException(FfiConverterString.INSTANCE.Read(stream));
            case 3: return new DojoException.NetworkException(FfiConverterString.INSTANCE.Read(stream));
            case 4: return new DojoException.InvalidInput(FfiConverterString.INSTANCE.Read(stream));
            case 5: return new DojoException.ConnectionException(FfiConverterString.INSTANCE.Read(stream));
            case 6: return new DojoException.PublishException(FfiConverterString.INSTANCE.Read(stream));
            case 7: return new DojoException.QueryException(FfiConverterString.INSTANCE.Read(stream));
            case 8: return new DojoException.SubscriptionException(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeDojoError.Read()", value));
        }
    }

    public override int AllocationSize(DojoException value) {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(DojoException value, BigEndianStream stream) {
        switch (value) {
            case DojoException.ClientException:
                stream.WriteInt(1);
                break;
            case DojoException.SerializationException:
                stream.WriteInt(2);
                break;
            case DojoException.NetworkException:
                stream.WriteInt(3);
                break;
            case DojoException.InvalidInput:
                stream.WriteInt(4);
                break;
            case DojoException.ConnectionException:
                stream.WriteInt(5);
                break;
            case DojoException.PublishException:
                stream.WriteInt(6);
                break;
            case DojoException.QueryException:
                stream.WriteInt(7);
                break;
            case DojoException.SubscriptionException:
                stream.WriteInt(8);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeDojoError.Write()", value));
        }
    }
}





internal enum LogicalOperator: int {
    
    And,
    Or
}

class FfiConverterTypeLogicalOperator: FfiConverterRustBuffer<LogicalOperator> {
    public static FfiConverterTypeLogicalOperator INSTANCE = new FfiConverterTypeLogicalOperator();

    public override LogicalOperator Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(LogicalOperator), value)) {
            return (LogicalOperator)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeLogicalOperator.Read()", value));
        }
    }

    public override int AllocationSize(LogicalOperator value) {
        return 4;
    }

    public override void Write(LogicalOperator value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal record MemberValue {
    
    public record Primitive (
        uniffi.dojo.Primitive @value
    ) : MemberValue {}
    
    public record String (
        string @value
    ) : MemberValue {}
    
    public record List (
        MemberValue[] @values
    ) : MemberValue {}
    

    
}

class FfiConverterTypeMemberValue : FfiConverterRustBuffer<MemberValue>{
    public static FfiConverterRustBuffer<MemberValue> INSTANCE = new FfiConverterTypeMemberValue();

    public override MemberValue Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new MemberValue.Primitive(
                    FfiConverterTypePrimitive.INSTANCE.Read(stream)
                );
            case 2:
                return new MemberValue.String(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new MemberValue.List(
                    FfiConverterSequenceTypeMemberValue.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeMemberValue.Read()", value));
        }
    }

    public override int AllocationSize(MemberValue value) {
        switch (value) {
            case MemberValue.Primitive variant_value:
                return 4
                    + FfiConverterTypePrimitive.INSTANCE.AllocationSize(variant_value.@value);
            case MemberValue.String variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            case MemberValue.List variant_value:
                return 4
                    + FfiConverterSequenceTypeMemberValue.INSTANCE.AllocationSize(variant_value.@values);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeMemberValue.AllocationSize()", value));
        }
    }

    public override void Write(MemberValue value, BigEndianStream stream) {
        switch (value) {
            case MemberValue.Primitive variant_value:
                stream.WriteInt(1);
                FfiConverterTypePrimitive.INSTANCE.Write(variant_value.@value, stream);
                break;
            case MemberValue.String variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            case MemberValue.List variant_value:
                stream.WriteInt(3);
                FfiConverterSequenceTypeMemberValue.INSTANCE.Write(variant_value.@values, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeMemberValue.Write()", value));
        }
    }
}







internal enum OrderDirection: int {
    
    Asc,
    Desc
}

class FfiConverterTypeOrderDirection: FfiConverterRustBuffer<OrderDirection> {
    public static FfiConverterTypeOrderDirection INSTANCE = new FfiConverterTypeOrderDirection();

    public override OrderDirection Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(OrderDirection), value)) {
            return (OrderDirection)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeOrderDirection.Read()", value));
        }
    }

    public override int AllocationSize(OrderDirection value) {
        return 4;
    }

    public override void Write(OrderDirection value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal enum PaginationDirection: int {
    
    Forward,
    Backward
}

class FfiConverterTypePaginationDirection: FfiConverterRustBuffer<PaginationDirection> {
    public static FfiConverterTypePaginationDirection INSTANCE = new FfiConverterTypePaginationDirection();

    public override PaginationDirection Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PaginationDirection), value)) {
            return (PaginationDirection)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaginationDirection.Read()", value));
        }
    }

    public override int AllocationSize(PaginationDirection value) {
        return 4;
    }

    public override void Write(PaginationDirection value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal enum PatternMatching: int {
    
    FixedLen,
    VariableLen
}

class FfiConverterTypePatternMatching: FfiConverterRustBuffer<PatternMatching> {
    public static FfiConverterTypePatternMatching INSTANCE = new FfiConverterTypePatternMatching();

    public override PatternMatching Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PatternMatching), value)) {
            return (PatternMatching)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePatternMatching.Read()", value));
        }
    }

    public override int AllocationSize(PatternMatching value) {
        return 4;
    }

    public override void Write(PatternMatching value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal record Primitive {
    
    public record I8 (
        sbyte @value
    ) : Primitive {}
    
    public record I16 (
        short @value
    ) : Primitive {}
    
    public record I32 (
        int @value
    ) : Primitive {}
    
    public record I64 (
        long @value
    ) : Primitive {}
    
    public record I128 (
        byte[] @value
    ) : Primitive {}
    
    public record U8 (
        byte @value
    ) : Primitive {}
    
    public record U16 (
        ushort @value
    ) : Primitive {}
    
    public record U32 (
        uint @value
    ) : Primitive {}
    
    public record U64 (
        ulong @value
    ) : Primitive {}
    
    public record U128 (
        byte[] @value
    ) : Primitive {}
    
    public record U256 (
        uniffi.dojo.U256 @value
    ) : Primitive {}
    
    public record Bool (
        bool @value
    ) : Primitive {}
    
    public record Felt252 (
        FieldElement @value
    ) : Primitive {}
    
    public record ClassHash (
        FieldElement @value
    ) : Primitive {}
    
    public record ContractAddress (
        FieldElement @value
    ) : Primitive {}
    
    public record EthAddress (
        FieldElement @value
    ) : Primitive {}
    

    
}

class FfiConverterTypePrimitive : FfiConverterRustBuffer<Primitive>{
    public static FfiConverterRustBuffer<Primitive> INSTANCE = new FfiConverterTypePrimitive();

    public override Primitive Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new Primitive.I8(
                    FfiConverterInt8.INSTANCE.Read(stream)
                );
            case 2:
                return new Primitive.I16(
                    FfiConverterInt16.INSTANCE.Read(stream)
                );
            case 3:
                return new Primitive.I32(
                    FfiConverterInt32.INSTANCE.Read(stream)
                );
            case 4:
                return new Primitive.I64(
                    FfiConverterInt64.INSTANCE.Read(stream)
                );
            case 5:
                return new Primitive.I128(
                    FfiConverterSequenceUInt8.INSTANCE.Read(stream)
                );
            case 6:
                return new Primitive.U8(
                    FfiConverterUInt8.INSTANCE.Read(stream)
                );
            case 7:
                return new Primitive.U16(
                    FfiConverterUInt16.INSTANCE.Read(stream)
                );
            case 8:
                return new Primitive.U32(
                    FfiConverterUInt32.INSTANCE.Read(stream)
                );
            case 9:
                return new Primitive.U64(
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 10:
                return new Primitive.U128(
                    FfiConverterSequenceUInt8.INSTANCE.Read(stream)
                );
            case 11:
                return new Primitive.U256(
                    FfiConverterTypeU256.INSTANCE.Read(stream)
                );
            case 12:
                return new Primitive.Bool(
                    FfiConverterBoolean.INSTANCE.Read(stream)
                );
            case 13:
                return new Primitive.Felt252(
                    FfiConverterTypeFieldElement.INSTANCE.Read(stream)
                );
            case 14:
                return new Primitive.ClassHash(
                    FfiConverterTypeFieldElement.INSTANCE.Read(stream)
                );
            case 15:
                return new Primitive.ContractAddress(
                    FfiConverterTypeFieldElement.INSTANCE.Read(stream)
                );
            case 16:
                return new Primitive.EthAddress(
                    FfiConverterTypeFieldElement.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePrimitive.Read()", value));
        }
    }

    public override int AllocationSize(Primitive value) {
        switch (value) {
            case Primitive.I8 variant_value:
                return 4
                    + FfiConverterInt8.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.I16 variant_value:
                return 4
                    + FfiConverterInt16.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.I32 variant_value:
                return 4
                    + FfiConverterInt32.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.I64 variant_value:
                return 4
                    + FfiConverterInt64.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.I128 variant_value:
                return 4
                    + FfiConverterSequenceUInt8.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.U8 variant_value:
                return 4
                    + FfiConverterUInt8.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.U16 variant_value:
                return 4
                    + FfiConverterUInt16.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.U32 variant_value:
                return 4
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.U64 variant_value:
                return 4
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.U128 variant_value:
                return 4
                    + FfiConverterSequenceUInt8.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.U256 variant_value:
                return 4
                    + FfiConverterTypeU256.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.Bool variant_value:
                return 4
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.Felt252 variant_value:
                return 4
                    + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.ClassHash variant_value:
                return 4
                    + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.ContractAddress variant_value:
                return 4
                    + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(variant_value.@value);
            case Primitive.EthAddress variant_value:
                return 4
                    + FfiConverterTypeFieldElement.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePrimitive.AllocationSize()", value));
        }
    }

    public override void Write(Primitive value, BigEndianStream stream) {
        switch (value) {
            case Primitive.I8 variant_value:
                stream.WriteInt(1);
                FfiConverterInt8.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.I16 variant_value:
                stream.WriteInt(2);
                FfiConverterInt16.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.I32 variant_value:
                stream.WriteInt(3);
                FfiConverterInt32.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.I64 variant_value:
                stream.WriteInt(4);
                FfiConverterInt64.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.I128 variant_value:
                stream.WriteInt(5);
                FfiConverterSequenceUInt8.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.U8 variant_value:
                stream.WriteInt(6);
                FfiConverterUInt8.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.U16 variant_value:
                stream.WriteInt(7);
                FfiConverterUInt16.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.U32 variant_value:
                stream.WriteInt(8);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.U64 variant_value:
                stream.WriteInt(9);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.U128 variant_value:
                stream.WriteInt(10);
                FfiConverterSequenceUInt8.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.U256 variant_value:
                stream.WriteInt(11);
                FfiConverterTypeU256.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.Bool variant_value:
                stream.WriteInt(12);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.Felt252 variant_value:
                stream.WriteInt(13);
                FfiConverterTypeFieldElement.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.ClassHash variant_value:
                stream.WriteInt(14);
                FfiConverterTypeFieldElement.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.ContractAddress variant_value:
                stream.WriteInt(15);
                FfiConverterTypeFieldElement.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Primitive.EthAddress variant_value:
                stream.WriteInt(16);
                FfiConverterTypeFieldElement.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePrimitive.Write()", value));
        }
    }
}







internal record SqlValue {
    
    public record Text (
        string @value
    ) : SqlValue {}
    
    public record Integer (
        long @value
    ) : SqlValue {}
    
    public record Real (
        double @value
    ) : SqlValue {}
    
    public record Blob (
        byte[] @value
    ) : SqlValue {}
    
    public record Null: SqlValue {}
    
    

    
}

class FfiConverterTypeSqlValue : FfiConverterRustBuffer<SqlValue>{
    public static FfiConverterRustBuffer<SqlValue> INSTANCE = new FfiConverterTypeSqlValue();

    public override SqlValue Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SqlValue.Text(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new SqlValue.Integer(
                    FfiConverterInt64.INSTANCE.Read(stream)
                );
            case 3:
                return new SqlValue.Real(
                    FfiConverterDouble.INSTANCE.Read(stream)
                );
            case 4:
                return new SqlValue.Blob(
                    FfiConverterSequenceUInt8.INSTANCE.Read(stream)
                );
            case 5:
                return new SqlValue.Null(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSqlValue.Read()", value));
        }
    }

    public override int AllocationSize(SqlValue value) {
        switch (value) {
            case SqlValue.Text variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            case SqlValue.Integer variant_value:
                return 4
                    + FfiConverterInt64.INSTANCE.AllocationSize(variant_value.@value);
            case SqlValue.Real variant_value:
                return 4
                    + FfiConverterDouble.INSTANCE.AllocationSize(variant_value.@value);
            case SqlValue.Blob variant_value:
                return 4
                    + FfiConverterSequenceUInt8.INSTANCE.AllocationSize(variant_value.@value);
            case SqlValue.Null variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSqlValue.AllocationSize()", value));
        }
    }

    public override void Write(SqlValue value, BigEndianStream stream) {
        switch (value) {
            case SqlValue.Text variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            case SqlValue.Integer variant_value:
                stream.WriteInt(2);
                FfiConverterInt64.INSTANCE.Write(variant_value.@value, stream);
                break;
            case SqlValue.Real variant_value:
                stream.WriteInt(3);
                FfiConverterDouble.INSTANCE.Write(variant_value.@value, stream);
                break;
            case SqlValue.Blob variant_value:
                stream.WriteInt(4);
                FfiConverterSequenceUInt8.INSTANCE.Write(variant_value.@value, stream);
                break;
            case SqlValue.Null variant_value:
                stream.WriteInt(5);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSqlValue.Write()", value));
        }
    }
}







internal record Ty {
    
    public record Primitive (
        uniffi.dojo.Primitive @value
    ) : Ty {}
    
    public record Struct (
        uniffi.dojo.Struct @value
    ) : Ty {}
    
    public record Enum (
        EnumType @value
    ) : Ty {}
    
    public record Tuple (
        Ty[] @values
    ) : Ty {}
    
    public record Array (
        Ty[] @values
    ) : Ty {}
    
    public record FixedSizeArray (
        uniffi.dojo.FixedSizeArray @value
    ) : Ty {}
    
    public record ByteArray (
        string @value
    ) : Ty {}
    

    
}

class FfiConverterTypeTy : FfiConverterRustBuffer<Ty>{
    public static FfiConverterRustBuffer<Ty> INSTANCE = new FfiConverterTypeTy();

    public override Ty Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new Ty.Primitive(
                    FfiConverterTypePrimitive.INSTANCE.Read(stream)
                );
            case 2:
                return new Ty.Struct(
                    FfiConverterTypeStruct.INSTANCE.Read(stream)
                );
            case 3:
                return new Ty.Enum(
                    FfiConverterTypeEnumType.INSTANCE.Read(stream)
                );
            case 4:
                return new Ty.Tuple(
                    FfiConverterSequenceTypeTy.INSTANCE.Read(stream)
                );
            case 5:
                return new Ty.Array(
                    FfiConverterSequenceTypeTy.INSTANCE.Read(stream)
                );
            case 6:
                return new Ty.FixedSizeArray(
                    FfiConverterTypeFixedSizeArray.INSTANCE.Read(stream)
                );
            case 7:
                return new Ty.ByteArray(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeTy.Read()", value));
        }
    }

    public override int AllocationSize(Ty value) {
        switch (value) {
            case Ty.Primitive variant_value:
                return 4
                    + FfiConverterTypePrimitive.INSTANCE.AllocationSize(variant_value.@value);
            case Ty.Struct variant_value:
                return 4
                    + FfiConverterTypeStruct.INSTANCE.AllocationSize(variant_value.@value);
            case Ty.Enum variant_value:
                return 4
                    + FfiConverterTypeEnumType.INSTANCE.AllocationSize(variant_value.@value);
            case Ty.Tuple variant_value:
                return 4
                    + FfiConverterSequenceTypeTy.INSTANCE.AllocationSize(variant_value.@values);
            case Ty.Array variant_value:
                return 4
                    + FfiConverterSequenceTypeTy.INSTANCE.AllocationSize(variant_value.@values);
            case Ty.FixedSizeArray variant_value:
                return 4
                    + FfiConverterTypeFixedSizeArray.INSTANCE.AllocationSize(variant_value.@value);
            case Ty.ByteArray variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeTy.AllocationSize()", value));
        }
    }

    public override void Write(Ty value, BigEndianStream stream) {
        switch (value) {
            case Ty.Primitive variant_value:
                stream.WriteInt(1);
                FfiConverterTypePrimitive.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Ty.Struct variant_value:
                stream.WriteInt(2);
                FfiConverterTypeStruct.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Ty.Enum variant_value:
                stream.WriteInt(3);
                FfiConverterTypeEnumType.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Ty.Tuple variant_value:
                stream.WriteInt(4);
                FfiConverterSequenceTypeTy.INSTANCE.Write(variant_value.@values, stream);
                break;
            case Ty.Array variant_value:
                stream.WriteInt(5);
                FfiConverterSequenceTypeTy.INSTANCE.Write(variant_value.@values, stream);
                break;
            case Ty.FixedSizeArray variant_value:
                stream.WriteInt(6);
                FfiConverterTypeFixedSizeArray.INSTANCE.Write(variant_value.@value, stream);
                break;
            case Ty.ByteArray variant_value:
                stream.WriteInt(7);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeTy.Write()", value));
        }
    }
}







internal record ValueType {
    
    public record String (
        string @value
    ) : ValueType {}
    
    public record Int (
        long @value
    ) : ValueType {}
    
    public record UInt (
        ulong @value
    ) : ValueType {}
    
    public record Bool (
        bool @value
    ) : ValueType {}
    
    public record Bytes (
        byte[] @value
    ) : ValueType {}
    

    
}

class FfiConverterTypeValueType : FfiConverterRustBuffer<ValueType>{
    public static FfiConverterRustBuffer<ValueType> INSTANCE = new FfiConverterTypeValueType();

    public override ValueType Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ValueType.String(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new ValueType.Int(
                    FfiConverterInt64.INSTANCE.Read(stream)
                );
            case 3:
                return new ValueType.UInt(
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 4:
                return new ValueType.Bool(
                    FfiConverterBoolean.INSTANCE.Read(stream)
                );
            case 5:
                return new ValueType.Bytes(
                    FfiConverterSequenceUInt8.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeValueType.Read()", value));
        }
    }

    public override int AllocationSize(ValueType value) {
        switch (value) {
            case ValueType.String variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            case ValueType.Int variant_value:
                return 4
                    + FfiConverterInt64.INSTANCE.AllocationSize(variant_value.@value);
            case ValueType.UInt variant_value:
                return 4
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@value);
            case ValueType.Bool variant_value:
                return 4
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@value);
            case ValueType.Bytes variant_value:
                return 4
                    + FfiConverterSequenceUInt8.INSTANCE.AllocationSize(variant_value.@value);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeValueType.AllocationSize()", value));
        }
    }

    public override void Write(ValueType value, BigEndianStream stream) {
        switch (value) {
            case ValueType.String variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            case ValueType.Int variant_value:
                stream.WriteInt(2);
                FfiConverterInt64.INSTANCE.Write(variant_value.@value, stream);
                break;
            case ValueType.UInt variant_value:
                stream.WriteInt(3);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@value, stream);
                break;
            case ValueType.Bool variant_value:
                stream.WriteInt(4);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@value, stream);
                break;
            case ValueType.Bytes variant_value:
                stream.WriteInt(5);
                FfiConverterSequenceUInt8.INSTANCE.Write(variant_value.@value, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeValueType.Write()", value));
        }
    }
}





internal interface EntityUpdateCallback {
    void OnUpdate(Entity @entity);
    void OnError(string @error);
}

class UniffiCallbackInterfaceEntityUpdateCallback {
    static void OnUpdate(ulong @uniffiHandle,RustBuffer @entity,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeEntityUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnUpdate(
                FfiConverterTypeEntity.INSTANCE.Lift(@entity));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnError(ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeEntityUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@error));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeEntityUpdateCallback.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceEntityUpdateCallbackMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceEntityUpdateCallbackMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceEntityUpdateCallbackMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceEntityUpdateCallbackMethod1(OnError);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static _UniFFILib.UniffiVTableCallbackInterfaceEntityUpdateCallback _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceEntityUpdateCallback {
        @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
        @onError = Marshal.GetFunctionPointerForDelegate(_m1),
        @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
    };

    public static void Register() {
        _UniFFILib.uniffi_dojo_uniffi_fn_init_callback_vtable_entityupdatecallback(ref UniffiCallbackInterfaceEntityUpdateCallback._vtable);
    }
}

class ConcurrentHandleMap<T> where T: notnull {
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj) {
        lock (lock_) {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result) {
        lock (lock_) {
            #pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
            #pragma warning restore 8601
        }
    }

    public T Get(ulong handle) {
        if (TryGet(handle, out var result)) {
            return result;
        } else {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle) {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result) {
        lock (lock_) {
            // Possible null reference assignment
            #pragma warning disable 8601
            if (map.TryGetValue(handle, out result)) {
            #pragma warning restore 8601
                map.Remove(handle);
                return true;
            } else {
                return false;
            }
        }
    }
}
static class UniffiCallbackResponseStatus {
    public static sbyte SUCCESS = 0;
    public static sbyte ERROR = 1;
    public static sbyte UNEXPECTED_ERROR = 2;
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeEntityUpdateCallback: FfiConverter<EntityUpdateCallback, ulong> {
    public static FfiConverterTypeEntityUpdateCallback INSTANCE = new FfiConverterTypeEntityUpdateCallback();

    public ConcurrentHandleMap<EntityUpdateCallback> handleMap = new ConcurrentHandleMap<EntityUpdateCallback>();

    public override ulong Lower(EntityUpdateCallback value) {
        return handleMap.Insert(value);
    }

    public override EntityUpdateCallback Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override EntityUpdateCallback Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(EntityUpdateCallback value) {
        return 8;
    }

    public override void Write(EntityUpdateCallback value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}



internal interface EventUpdateCallback {
    void OnUpdate(Event @event);
    void OnError(string @error);
}

class UniffiCallbackInterfaceEventUpdateCallback {
    static void OnUpdate(ulong @uniffiHandle,RustBuffer @event,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeEventUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnUpdate(
                FfiConverterTypeEvent.INSTANCE.Lift(@event));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnError(ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeEventUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@error));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeEventUpdateCallback.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceEventUpdateCallbackMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceEventUpdateCallbackMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceEventUpdateCallbackMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceEventUpdateCallbackMethod1(OnError);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static _UniFFILib.UniffiVTableCallbackInterfaceEventUpdateCallback _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceEventUpdateCallback {
        @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
        @onError = Marshal.GetFunctionPointerForDelegate(_m1),
        @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
    };

    public static void Register() {
        _UniFFILib.uniffi_dojo_uniffi_fn_init_callback_vtable_eventupdatecallback(ref UniffiCallbackInterfaceEventUpdateCallback._vtable);
    }
}




// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeEventUpdateCallback: FfiConverter<EventUpdateCallback, ulong> {
    public static FfiConverterTypeEventUpdateCallback INSTANCE = new FfiConverterTypeEventUpdateCallback();

    public ConcurrentHandleMap<EventUpdateCallback> handleMap = new ConcurrentHandleMap<EventUpdateCallback>();

    public override ulong Lower(EventUpdateCallback value) {
        return handleMap.Insert(value);
    }

    public override EventUpdateCallback Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override EventUpdateCallback Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(EventUpdateCallback value) {
        return 8;
    }

    public override void Write(EventUpdateCallback value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}



internal interface TokenBalanceUpdateCallback {
    void OnUpdate(TokenBalance @balance);
    void OnError(string @error);
}

class UniffiCallbackInterfaceTokenBalanceUpdateCallback {
    static void OnUpdate(ulong @uniffiHandle,RustBuffer @balance,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTokenBalanceUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnUpdate(
                FfiConverterTypeTokenBalance.INSTANCE.Lift(@balance));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnError(ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTokenBalanceUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@error));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeTokenBalanceUpdateCallback.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceTokenBalanceUpdateCallbackMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceTokenBalanceUpdateCallbackMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceTokenBalanceUpdateCallbackMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceTokenBalanceUpdateCallbackMethod1(OnError);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static _UniFFILib.UniffiVTableCallbackInterfaceTokenBalanceUpdateCallback _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceTokenBalanceUpdateCallback {
        @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
        @onError = Marshal.GetFunctionPointerForDelegate(_m1),
        @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
    };

    public static void Register() {
        _UniFFILib.uniffi_dojo_uniffi_fn_init_callback_vtable_tokenbalanceupdatecallback(ref UniffiCallbackInterfaceTokenBalanceUpdateCallback._vtable);
    }
}




// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeTokenBalanceUpdateCallback: FfiConverter<TokenBalanceUpdateCallback, ulong> {
    public static FfiConverterTypeTokenBalanceUpdateCallback INSTANCE = new FfiConverterTypeTokenBalanceUpdateCallback();

    public ConcurrentHandleMap<TokenBalanceUpdateCallback> handleMap = new ConcurrentHandleMap<TokenBalanceUpdateCallback>();

    public override ulong Lower(TokenBalanceUpdateCallback value) {
        return handleMap.Insert(value);
    }

    public override TokenBalanceUpdateCallback Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override TokenBalanceUpdateCallback Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(TokenBalanceUpdateCallback value) {
        return 8;
    }

    public override void Write(TokenBalanceUpdateCallback value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}



internal interface TokenUpdateCallback {
    void OnUpdate(Token @token);
    void OnError(string @error);
}

class UniffiCallbackInterfaceTokenUpdateCallback {
    static void OnUpdate(ulong @uniffiHandle,RustBuffer @token,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTokenUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnUpdate(
                FfiConverterTypeToken.INSTANCE.Lift(@token));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnError(ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTokenUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@error));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeTokenUpdateCallback.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceTokenUpdateCallbackMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceTokenUpdateCallbackMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceTokenUpdateCallbackMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceTokenUpdateCallbackMethod1(OnError);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static _UniFFILib.UniffiVTableCallbackInterfaceTokenUpdateCallback _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceTokenUpdateCallback {
        @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
        @onError = Marshal.GetFunctionPointerForDelegate(_m1),
        @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
    };

    public static void Register() {
        _UniFFILib.uniffi_dojo_uniffi_fn_init_callback_vtable_tokenupdatecallback(ref UniffiCallbackInterfaceTokenUpdateCallback._vtable);
    }
}




// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeTokenUpdateCallback: FfiConverter<TokenUpdateCallback, ulong> {
    public static FfiConverterTypeTokenUpdateCallback INSTANCE = new FfiConverterTypeTokenUpdateCallback();

    public ConcurrentHandleMap<TokenUpdateCallback> handleMap = new ConcurrentHandleMap<TokenUpdateCallback>();

    public override ulong Lower(TokenUpdateCallback value) {
        return handleMap.Insert(value);
    }

    public override TokenUpdateCallback Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override TokenUpdateCallback Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(TokenUpdateCallback value) {
        return 8;
    }

    public override void Write(TokenUpdateCallback value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}



internal interface TransactionUpdateCallback {
    void OnUpdate(Transaction @transaction);
    void OnError(string @error);
}

class UniffiCallbackInterfaceTransactionUpdateCallback {
    static void OnUpdate(ulong @uniffiHandle,RustBuffer @transaction,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTransactionUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnUpdate(
                FfiConverterTypeTransaction.INSTANCE.Lift(@transaction));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void OnError(ulong @uniffiHandle,RustBuffer @error,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeTransactionUpdateCallback.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.OnError(
                FfiConverterString.INSTANCE.Lift(@error));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeTransactionUpdateCallback.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceTransactionUpdateCallbackMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceTransactionUpdateCallbackMethod0(OnUpdate);
    static _UniFFILib.UniffiCallbackInterfaceTransactionUpdateCallbackMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceTransactionUpdateCallbackMethod1(OnError);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static _UniFFILib.UniffiVTableCallbackInterfaceTransactionUpdateCallback _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceTransactionUpdateCallback {
        @onUpdate = Marshal.GetFunctionPointerForDelegate(_m0),
        @onError = Marshal.GetFunctionPointerForDelegate(_m1),
        @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
    };

    public static void Register() {
        _UniFFILib.uniffi_dojo_uniffi_fn_init_callback_vtable_transactionupdatecallback(ref UniffiCallbackInterfaceTransactionUpdateCallback._vtable);
    }
}




// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeTransactionUpdateCallback: FfiConverter<TransactionUpdateCallback, ulong> {
    public static FfiConverterTypeTransactionUpdateCallback INSTANCE = new FfiConverterTypeTransactionUpdateCallback();

    public ConcurrentHandleMap<TransactionUpdateCallback> handleMap = new ConcurrentHandleMap<TransactionUpdateCallback>();

    public override ulong Lower(TransactionUpdateCallback value) {
        return handleMap.Insert(value);
    }

    public override TransactionUpdateCallback Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override TransactionUpdateCallback Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(TransactionUpdateCallback value) {
        return 8;
    }

    public override void Write(TransactionUpdateCallback value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}




class FfiConverterOptionalUInt32: FfiConverterRustBuffer<uint?> {
    public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

    public override uint? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(uint? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
        }
    }

    public override void Write(uint? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
        }
    }
}




class FfiConverterOptionalUInt64: FfiConverterRustBuffer<ulong?> {
    public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

    public override ulong? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ulong? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
        }
    }

    public override void Write(ulong? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
        }
    }
}




class FfiConverterOptionalBoolean: FfiConverterRustBuffer<bool?> {
    public static FfiConverterOptionalBoolean INSTANCE = new FfiConverterOptionalBoolean();

    public override bool? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterBoolean.INSTANCE.Read(stream);
    }

    public override int AllocationSize(bool? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterBoolean.INSTANCE.AllocationSize((bool)value);
        }
    }

    public override void Write(bool? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterBoolean.INSTANCE.Write((bool)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<string?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}




class FfiConverterOptionalTypeKeysClause: FfiConverterRustBuffer<KeysClause?> {
    public static FfiConverterOptionalTypeKeysClause INSTANCE = new FfiConverterOptionalTypeKeysClause();

    public override KeysClause? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeKeysClause.INSTANCE.Read(stream);
    }

    public override int AllocationSize(KeysClause? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeKeysClause.INSTANCE.AllocationSize((KeysClause)value);
        }
    }

    public override void Write(KeysClause? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeKeysClause.INSTANCE.Write((KeysClause)value, stream);
        }
    }
}




class FfiConverterOptionalTypeTransactionFilter: FfiConverterRustBuffer<TransactionFilter?> {
    public static FfiConverterOptionalTypeTransactionFilter INSTANCE = new FfiConverterOptionalTypeTransactionFilter();

    public override TransactionFilter? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeTransactionFilter.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TransactionFilter? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeTransactionFilter.INSTANCE.AllocationSize((TransactionFilter)value);
        }
    }

    public override void Write(TransactionFilter? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeTransactionFilter.INSTANCE.Write((TransactionFilter)value, stream);
        }
    }
}




class FfiConverterOptionalTypeClause: FfiConverterRustBuffer<Clause?> {
    public static FfiConverterOptionalTypeClause INSTANCE = new FfiConverterOptionalTypeClause();

    public override Clause? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeClause.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Clause? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeClause.INSTANCE.AllocationSize((Clause)value);
        }
    }

    public override void Write(Clause? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeClause.INSTANCE.Write((Clause)value, stream);
        }
    }
}




class FfiConverterOptionalTypeFieldElement: FfiConverterRustBuffer<FieldElement?> {
    public static FfiConverterOptionalTypeFieldElement INSTANCE = new FfiConverterOptionalTypeFieldElement();

    public override FieldElement? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeFieldElement.INSTANCE.Read(stream);
    }

    public override int AllocationSize(FieldElement? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeFieldElement.INSTANCE.AllocationSize((FieldElement)value);
        }
    }

    public override void Write(FieldElement? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeFieldElement.INSTANCE.Write((FieldElement)value, stream);
        }
    }
}




class FfiConverterOptionalTypeU256: FfiConverterRustBuffer<U256?> {
    public static FfiConverterOptionalTypeU256 INSTANCE = new FfiConverterOptionalTypeU256();

    public override U256? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeU256.INSTANCE.Read(stream);
    }

    public override int AllocationSize(U256? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeU256.INSTANCE.AllocationSize((U256)value);
        }
    }

    public override void Write(U256? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeU256.INSTANCE.Write((U256)value, stream);
        }
    }
}




class FfiConverterSequenceUInt8: FfiConverterRustBuffer<byte[]> {
    public static FfiConverterSequenceUInt8 INSTANCE = new FfiConverterSequenceUInt8();

    public override byte[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new byte[(length)];
        var readFn = FfiConverterUInt8.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(byte[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterUInt8.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(byte[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterUInt8.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceString: FfiConverterRustBuffer<string[]> {
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override string[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new string[(length)];
        var readFn = FfiConverterString.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(string[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(string[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterString.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeAchievement: FfiConverterRustBuffer<Achievement[]> {
    public static FfiConverterSequenceTypeAchievement INSTANCE = new FfiConverterSequenceTypeAchievement();

    public override Achievement[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Achievement[(length)];
        var readFn = FfiConverterTypeAchievement.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Achievement[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeAchievement.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Achievement[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeAchievement.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeAchievementTask: FfiConverterRustBuffer<AchievementTask[]> {
    public static FfiConverterSequenceTypeAchievementTask INSTANCE = new FfiConverterSequenceTypeAchievementTask();

    public override AchievementTask[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new AchievementTask[(length)];
        var readFn = FfiConverterTypeAchievementTask.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(AchievementTask[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeAchievementTask.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(AchievementTask[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeAchievementTask.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeActionCount: FfiConverterRustBuffer<ActionCount[]> {
    public static FfiConverterSequenceTypeActionCount INSTANCE = new FfiConverterSequenceTypeActionCount();

    public override ActionCount[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new ActionCount[(length)];
        var readFn = FfiConverterTypeActionCount.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(ActionCount[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeActionCount.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(ActionCount[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeActionCount.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeActivity: FfiConverterRustBuffer<Activity[]> {
    public static FfiConverterSequenceTypeActivity INSTANCE = new FfiConverterSequenceTypeActivity();

    public override Activity[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Activity[(length)];
        var readFn = FfiConverterTypeActivity.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Activity[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeActivity.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Activity[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeActivity.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeAggregationEntry: FfiConverterRustBuffer<AggregationEntry[]> {
    public static FfiConverterSequenceTypeAggregationEntry INSTANCE = new FfiConverterSequenceTypeAggregationEntry();

    public override AggregationEntry[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new AggregationEntry[(length)];
        var readFn = FfiConverterTypeAggregationEntry.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(AggregationEntry[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeAggregationEntry.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(AggregationEntry[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeAggregationEntry.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeAttributeFilter: FfiConverterRustBuffer<AttributeFilter[]> {
    public static FfiConverterSequenceTypeAttributeFilter INSTANCE = new FfiConverterSequenceTypeAttributeFilter();

    public override AttributeFilter[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new AttributeFilter[(length)];
        var readFn = FfiConverterTypeAttributeFilter.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(AttributeFilter[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeAttributeFilter.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(AttributeFilter[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeAttributeFilter.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeContract: FfiConverterRustBuffer<Contract[]> {
    public static FfiConverterSequenceTypeContract INSTANCE = new FfiConverterSequenceTypeContract();

    public override Contract[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Contract[(length)];
        var readFn = FfiConverterTypeContract.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Contract[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeContract.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Contract[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeContract.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeController: FfiConverterRustBuffer<Controller[]> {
    public static FfiConverterSequenceTypeController INSTANCE = new FfiConverterSequenceTypeController();

    public override Controller[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Controller[(length)];
        var readFn = FfiConverterTypeController.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Controller[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeController.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Controller[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeController.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeEntity: FfiConverterRustBuffer<Entity[]> {
    public static FfiConverterSequenceTypeEntity INSTANCE = new FfiConverterSequenceTypeEntity();

    public override Entity[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Entity[(length)];
        var readFn = FfiConverterTypeEntity.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Entity[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeEntity.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Entity[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeEntity.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeEnumOption: FfiConverterRustBuffer<EnumOption[]> {
    public static FfiConverterSequenceTypeEnumOption INSTANCE = new FfiConverterSequenceTypeEnumOption();

    public override EnumOption[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new EnumOption[(length)];
        var readFn = FfiConverterTypeEnumOption.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(EnumOption[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeEnumOption.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(EnumOption[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeEnumOption.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeEvent: FfiConverterRustBuffer<Event[]> {
    public static FfiConverterSequenceTypeEvent INSTANCE = new FfiConverterSequenceTypeEvent();

    public override Event[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Event[(length)];
        var readFn = FfiConverterTypeEvent.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Event[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeEvent.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Event[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeEvent.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeKeysClause: FfiConverterRustBuffer<KeysClause[]> {
    public static FfiConverterSequenceTypeKeysClause INSTANCE = new FfiConverterSequenceTypeKeysClause();

    public override KeysClause[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new KeysClause[(length)];
        var readFn = FfiConverterTypeKeysClause.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(KeysClause[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeKeysClause.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(KeysClause[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeKeysClause.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeMember: FfiConverterRustBuffer<Member[]> {
    public static FfiConverterSequenceTypeMember INSTANCE = new FfiConverterSequenceTypeMember();

    public override Member[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Member[(length)];
        var readFn = FfiConverterTypeMember.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Member[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeMember.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Member[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeMember.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeMessage: FfiConverterRustBuffer<Message[]> {
    public static FfiConverterSequenceTypeMessage INSTANCE = new FfiConverterSequenceTypeMessage();

    public override Message[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Message[(length)];
        var readFn = FfiConverterTypeMessage.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Message[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeMessage.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Message[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeMessage.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeModel: FfiConverterRustBuffer<Model[]> {
    public static FfiConverterSequenceTypeModel INSTANCE = new FfiConverterSequenceTypeModel();

    public override Model[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Model[(length)];
        var readFn = FfiConverterTypeModel.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Model[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeModel.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Model[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeModel.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeOrderBy: FfiConverterRustBuffer<OrderBy[]> {
    public static FfiConverterSequenceTypeOrderBy INSTANCE = new FfiConverterSequenceTypeOrderBy();

    public override OrderBy[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new OrderBy[(length)];
        var readFn = FfiConverterTypeOrderBy.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(OrderBy[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeOrderBy.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(OrderBy[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeOrderBy.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypePlayerAchievementEntry: FfiConverterRustBuffer<PlayerAchievementEntry[]> {
    public static FfiConverterSequenceTypePlayerAchievementEntry INSTANCE = new FfiConverterSequenceTypePlayerAchievementEntry();

    public override PlayerAchievementEntry[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new PlayerAchievementEntry[(length)];
        var readFn = FfiConverterTypePlayerAchievementEntry.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(PlayerAchievementEntry[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypePlayerAchievementEntry.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(PlayerAchievementEntry[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypePlayerAchievementEntry.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypePlayerAchievementProgress: FfiConverterRustBuffer<PlayerAchievementProgress[]> {
    public static FfiConverterSequenceTypePlayerAchievementProgress INSTANCE = new FfiConverterSequenceTypePlayerAchievementProgress();

    public override PlayerAchievementProgress[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new PlayerAchievementProgress[(length)];
        var readFn = FfiConverterTypePlayerAchievementProgress.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(PlayerAchievementProgress[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypePlayerAchievementProgress.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(PlayerAchievementProgress[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypePlayerAchievementProgress.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeSqlField: FfiConverterRustBuffer<SqlField[]> {
    public static FfiConverterSequenceTypeSqlField INSTANCE = new FfiConverterSequenceTypeSqlField();

    public override SqlField[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new SqlField[(length)];
        var readFn = FfiConverterTypeSqlField.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(SqlField[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeSqlField.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(SqlField[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeSqlField.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeSqlRow: FfiConverterRustBuffer<SqlRow[]> {
    public static FfiConverterSequenceTypeSqlRow INSTANCE = new FfiConverterSequenceTypeSqlRow();

    public override SqlRow[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new SqlRow[(length)];
        var readFn = FfiConverterTypeSqlRow.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(SqlRow[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeSqlRow.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(SqlRow[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeSqlRow.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeStruct: FfiConverterRustBuffer<Struct[]> {
    public static FfiConverterSequenceTypeStruct INSTANCE = new FfiConverterSequenceTypeStruct();

    public override Struct[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Struct[(length)];
        var readFn = FfiConverterTypeStruct.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Struct[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeStruct.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Struct[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeStruct.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTaskProgress: FfiConverterRustBuffer<TaskProgress[]> {
    public static FfiConverterSequenceTypeTaskProgress INSTANCE = new FfiConverterSequenceTypeTaskProgress();

    public override TaskProgress[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new TaskProgress[(length)];
        var readFn = FfiConverterTypeTaskProgress.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(TaskProgress[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTaskProgress.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(TaskProgress[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTaskProgress.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeToken: FfiConverterRustBuffer<Token[]> {
    public static FfiConverterSequenceTypeToken INSTANCE = new FfiConverterSequenceTypeToken();

    public override Token[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Token[(length)];
        var readFn = FfiConverterTypeToken.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Token[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeToken.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Token[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeToken.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTokenBalance: FfiConverterRustBuffer<TokenBalance[]> {
    public static FfiConverterSequenceTypeTokenBalance INSTANCE = new FfiConverterSequenceTypeTokenBalance();

    public override TokenBalance[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new TokenBalance[(length)];
        var readFn = FfiConverterTypeTokenBalance.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(TokenBalance[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTokenBalance.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(TokenBalance[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTokenBalance.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTokenContract: FfiConverterRustBuffer<TokenContract[]> {
    public static FfiConverterSequenceTypeTokenContract INSTANCE = new FfiConverterSequenceTypeTokenContract();

    public override TokenContract[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new TokenContract[(length)];
        var readFn = FfiConverterTypeTokenContract.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(TokenContract[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTokenContract.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(TokenContract[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTokenContract.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTokenTransfer: FfiConverterRustBuffer<TokenTransfer[]> {
    public static FfiConverterSequenceTypeTokenTransfer INSTANCE = new FfiConverterSequenceTypeTokenTransfer();

    public override TokenTransfer[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new TokenTransfer[(length)];
        var readFn = FfiConverterTypeTokenTransfer.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(TokenTransfer[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTokenTransfer.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(TokenTransfer[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTokenTransfer.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer<Transaction[]> {
    public static FfiConverterSequenceTypeTransaction INSTANCE = new FfiConverterSequenceTypeTransaction();

    public override Transaction[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Transaction[(length)];
        var readFn = FfiConverterTypeTransaction.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Transaction[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTransaction.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Transaction[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTransaction.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTransactionCall: FfiConverterRustBuffer<TransactionCall[]> {
    public static FfiConverterSequenceTypeTransactionCall INSTANCE = new FfiConverterSequenceTypeTransactionCall();

    public override TransactionCall[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new TransactionCall[(length)];
        var readFn = FfiConverterTypeTransactionCall.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(TransactionCall[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTransactionCall.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(TransactionCall[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTransactionCall.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeWorld: FfiConverterRustBuffer<World[]> {
    public static FfiConverterSequenceTypeWorld INSTANCE = new FfiConverterSequenceTypeWorld();

    public override World[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new World[(length)];
        var readFn = FfiConverterTypeWorld.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(World[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeWorld.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(World[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeWorld.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeClause: FfiConverterRustBuffer<Clause[]> {
    public static FfiConverterSequenceTypeClause INSTANCE = new FfiConverterSequenceTypeClause();

    public override Clause[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Clause[(length)];
        var readFn = FfiConverterTypeClause.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Clause[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeClause.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Clause[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeClause.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeContractType: FfiConverterRustBuffer<ContractType[]> {
    public static FfiConverterSequenceTypeContractType INSTANCE = new FfiConverterSequenceTypeContractType();

    public override ContractType[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new ContractType[(length)];
        var readFn = FfiConverterTypeContractType.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(ContractType[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeContractType.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(ContractType[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeContractType.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeMemberValue: FfiConverterRustBuffer<MemberValue[]> {
    public static FfiConverterSequenceTypeMemberValue INSTANCE = new FfiConverterSequenceTypeMemberValue();

    public override MemberValue[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new MemberValue[(length)];
        var readFn = FfiConverterTypeMemberValue.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(MemberValue[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeMemberValue.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(MemberValue[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeMemberValue.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTy: FfiConverterRustBuffer<Ty[]> {
    public static FfiConverterSequenceTypeTy INSTANCE = new FfiConverterSequenceTypeTy();

    public override Ty[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new Ty[(length)];
        var readFn = FfiConverterTypeTy.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(Ty[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTy.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Ty[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeTy.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceOptionalTypeFieldElement: FfiConverterRustBuffer<FieldElement?[]> {
    public static FfiConverterSequenceOptionalTypeFieldElement INSTANCE = new FfiConverterSequenceOptionalTypeFieldElement();

    public override FieldElement?[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new FieldElement?[(length)];
        var readFn = FfiConverterOptionalTypeFieldElement.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(FieldElement?[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterOptionalTypeFieldElement.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(FieldElement?[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterOptionalTypeFieldElement.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeFieldElement: FfiConverterRustBuffer<FieldElement[]> {
    public static FfiConverterSequenceTypeFieldElement INSTANCE = new FfiConverterSequenceTypeFieldElement();

    public override FieldElement[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new FieldElement[(length)];
        var readFn = FfiConverterTypeFieldElement.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(FieldElement[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeFieldElement.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(FieldElement[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeFieldElement.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeU256: FfiConverterRustBuffer<U256[]> {
    public static FfiConverterSequenceTypeU256 INSTANCE = new FfiConverterSequenceTypeU256();

    public override U256[]  Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        if (length == 0) {
            return [];
        }

        var result = new U256[(length)];
        var readFn = FfiConverterTypeU256.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(U256[]  value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeU256.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(U256[] value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterTypeU256.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */





/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */


#pragma warning restore 8625
internal static class DojoMethods {
}

