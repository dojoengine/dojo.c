// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFutureDroppedCallback,
  type UniffiForeignFutureDroppedCallbackStruct,
  type UniffiForeignFutureResultU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureResultI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureResultU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureResultI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureResultU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureResultI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureResultU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureResultI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureResultF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureResultF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureResultRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureResultVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceEntityUpdateCallback,
  type UniffiVTableCallbackInterfaceEventUpdateCallback,
  type UniffiVTableCallbackInterfaceTokenBalanceUpdateCallback,
  type UniffiVTableCallbackInterfaceTokenUpdateCallback,
  type UniffiVTableCallbackInterfaceTransactionUpdateCallback,
} from "./dojo-ffi";
import {
  type FfiConverter, 
  type UniffiByteArray, 
  type UniffiHandle, 
  type UniffiObjectFactory, 
  type UniffiReferenceHolder, 
  type UniffiRustArcPtr, 
  type UniffiRustCallStatus, 
  type UnsafeMutableRawPointer, 
  AbstractFfiConverterByteArray, 
  FfiConverterArray, 
  FfiConverterBool, 
  FfiConverterCallback, 
  FfiConverterFloat64, 
  FfiConverterInt16, 
  FfiConverterInt32, 
  FfiConverterInt64, 
  FfiConverterInt8, 
  FfiConverterObject, 
  FfiConverterOptional, 
  FfiConverterUInt16, 
  FfiConverterUInt32, 
  FfiConverterUInt64, 
  FfiConverterUInt8, 
  RustBuffer, 
  UniffiAbstractObject, 
  UniffiEnum, 
  UniffiError, 
  UniffiInternalError, 
  UniffiResult, 
  UniffiRustCaller, 
  destructorGuardSymbol, 
  pointerLiteralSymbol, 
  uniffiCreateFfiConverterString, 
  uniffiCreateRecord, 
  uniffiTraitInterfaceCall, 
  uniffiTypeNameSymbol, 
  variantOrdinalSymbol } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.






export interface EntityUpdateCallback {
    
    onUpdate(entity: Entity) : void;
    onError(error: string) : void;
}


// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEntityUpdateCallback: { vtable: UniffiVTableCallbackInterfaceEntityUpdateCallback; register: () => void; } = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (
            uniffiHandle: bigint,
            entity: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeEntityUpdateCallback.lift(uniffiHandle);
                return jsCallback.onUpdate(
                    FfiConverterTypeEntity.lift(entity)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        onError: (
            uniffiHandle: bigint,
            error: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeEntityUpdateCallback.lift(uniffiHandle);
                return jsCallback.onError(
                    FfiConverterString.lift(error)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle: UniffiHandle): void => {
            // EntityUpdateCallback: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeEntityUpdateCallback.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_dojo_uniffi_fn_init_callback_vtable_entityupdatecallback(
            uniffiCallbackInterfaceEntityUpdateCallback.vtable
        );
    },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEntityUpdateCallback = new FfiConverterCallback<EntityUpdateCallback>();



export interface EventUpdateCallback {
    
    onUpdate(event: Event) : void;
    onError(error: string) : void;
}


// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEventUpdateCallback: { vtable: UniffiVTableCallbackInterfaceEventUpdateCallback; register: () => void; } = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (
            uniffiHandle: bigint,
            event: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeEventUpdateCallback.lift(uniffiHandle);
                return jsCallback.onUpdate(
                    FfiConverterTypeEvent.lift(event)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        onError: (
            uniffiHandle: bigint,
            error: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeEventUpdateCallback.lift(uniffiHandle);
                return jsCallback.onError(
                    FfiConverterString.lift(error)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle: UniffiHandle): void => {
            // EventUpdateCallback: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeEventUpdateCallback.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_dojo_uniffi_fn_init_callback_vtable_eventupdatecallback(
            uniffiCallbackInterfaceEventUpdateCallback.vtable
        );
    },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEventUpdateCallback = new FfiConverterCallback<EventUpdateCallback>();



export interface TokenBalanceUpdateCallback {
    
    onUpdate(balance: TokenBalance) : void;
    onError(error: string) : void;
}


// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTokenBalanceUpdateCallback: { vtable: UniffiVTableCallbackInterfaceTokenBalanceUpdateCallback; register: () => void; } = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (
            uniffiHandle: bigint,
            balance: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeTokenBalanceUpdateCallback.lift(uniffiHandle);
                return jsCallback.onUpdate(
                    FfiConverterTypeTokenBalance.lift(balance)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        onError: (
            uniffiHandle: bigint,
            error: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeTokenBalanceUpdateCallback.lift(uniffiHandle);
                return jsCallback.onError(
                    FfiConverterString.lift(error)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle: UniffiHandle): void => {
            // TokenBalanceUpdateCallback: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeTokenBalanceUpdateCallback.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_dojo_uniffi_fn_init_callback_vtable_tokenbalanceupdatecallback(
            uniffiCallbackInterfaceTokenBalanceUpdateCallback.vtable
        );
    },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTokenBalanceUpdateCallback = new FfiConverterCallback<TokenBalanceUpdateCallback>();



export interface TokenUpdateCallback {
    
    onUpdate(token: Token) : void;
    onError(error: string) : void;
}


// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTokenUpdateCallback: { vtable: UniffiVTableCallbackInterfaceTokenUpdateCallback; register: () => void; } = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (
            uniffiHandle: bigint,
            token: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeTokenUpdateCallback.lift(uniffiHandle);
                return jsCallback.onUpdate(
                    FfiConverterTypeToken.lift(token)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        onError: (
            uniffiHandle: bigint,
            error: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeTokenUpdateCallback.lift(uniffiHandle);
                return jsCallback.onError(
                    FfiConverterString.lift(error)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle: UniffiHandle): void => {
            // TokenUpdateCallback: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeTokenUpdateCallback.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_dojo_uniffi_fn_init_callback_vtable_tokenupdatecallback(
            uniffiCallbackInterfaceTokenUpdateCallback.vtable
        );
    },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTokenUpdateCallback = new FfiConverterCallback<TokenUpdateCallback>();



export interface TransactionUpdateCallback {
    
    onUpdate(transaction: Transaction) : void;
    onError(error: string) : void;
}


// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTransactionUpdateCallback: { vtable: UniffiVTableCallbackInterfaceTransactionUpdateCallback; register: () => void; } = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (
            uniffiHandle: bigint,
            transaction: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeTransactionUpdateCallback.lift(uniffiHandle);
                return jsCallback.onUpdate(
                    FfiConverterTypeTransaction.lift(transaction)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        onError: (
            uniffiHandle: bigint,
            error: Uint8Array,) => {
            const uniffiMakeCall = 
            ()
            : void => {
                const jsCallback = FfiConverterTypeTransactionUpdateCallback.lift(uniffiHandle);
                return jsCallback.onError(
                    FfiConverterString.lift(error)
                )
            };
            const uniffiResult = UniffiResult.ready<void>();
            const uniffiHandleSuccess = (obj: any) => {};
            const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
                /*makeCall:*/ uniffiMakeCall,
                /*handleSuccess:*/ uniffiHandleSuccess,
                /*handleError:*/ uniffiHandleError,
                /*lowerString:*/ FfiConverterString.lower
            )
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle: UniffiHandle): void => {
            // TransactionUpdateCallback: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeTransactionUpdateCallback.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_dojo_uniffi_fn_init_callback_vtable_transactionupdatecallback(
            uniffiCallbackInterfaceTransactionUpdateCallback.vtable
        );
    },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTransactionUpdateCallback = new FfiConverterCallback<TransactionUpdateCallback>();












export type Achievement = {
    id: string,
    worldAddress: FieldElement,
    namespace: string,
    entityId: string,
    hidden: boolean,
    index: /*u32*/number,
    points: /*u32*/number,
    start: string,
    end: string,
    group: string,
    icon: string,
    title: string,
    description: string,
    tasks: Array<AchievementTask>,
    data: string | undefined,
    totalCompletions: /*u32*/number,
    completionRate: /*f64*/number,
    createdAt: /*u64*/bigint,
    updatedAt: /*u64*/bigint
}

/**
 * Generated factory for {@link Achievement} record objects.
 */
export const Achievement = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Achievement, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Achievement}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Achievement}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Achievement>,
    });
})();

const FfiConverterTypeAchievement = (() => {
    type TypeName = Achievement;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterString.read(from), 
                worldAddress: FfiConverterTypeFieldElement.read(from), 
                namespace: FfiConverterString.read(from), 
                entityId: FfiConverterString.read(from), 
                hidden: FfiConverterBool.read(from), 
                index: FfiConverterUInt32.read(from), 
                points: FfiConverterUInt32.read(from), 
                start: FfiConverterString.read(from), 
                end: FfiConverterString.read(from), 
                group: FfiConverterString.read(from), 
                icon: FfiConverterString.read(from), 
                title: FfiConverterString.read(from), 
                description: FfiConverterString.read(from), 
                tasks: FfiConverterArrayTypeAchievementTask.read(from), 
                data: FfiConverterOptionalString.read(from), 
                totalCompletions: FfiConverterUInt32.read(from), 
                completionRate: FfiConverterFloat64.read(from), 
                createdAt: FfiConverterUInt64.read(from), 
                updatedAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.id, into);
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
            FfiConverterString.write(value.namespace, into);
            FfiConverterString.write(value.entityId, into);
            FfiConverterBool.write(value.hidden, into);
            FfiConverterUInt32.write(value.index, into);
            FfiConverterUInt32.write(value.points, into);
            FfiConverterString.write(value.start, into);
            FfiConverterString.write(value.end, into);
            FfiConverterString.write(value.group, into);
            FfiConverterString.write(value.icon, into);
            FfiConverterString.write(value.title, into);
            FfiConverterString.write(value.description, into);
            FfiConverterArrayTypeAchievementTask.write(value.tasks, into);
            FfiConverterOptionalString.write(value.data, into);
            FfiConverterUInt32.write(value.totalCompletions, into);
            FfiConverterFloat64.write(value.completionRate, into);
            FfiConverterUInt64.write(value.createdAt, into);
            FfiConverterUInt64.write(value.updatedAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.id) + 
            FfiConverterTypeFieldElement.allocationSize(value.worldAddress) + 
            FfiConverterString.allocationSize(value.namespace) + 
            FfiConverterString.allocationSize(value.entityId) + 
            FfiConverterBool.allocationSize(value.hidden) + 
            FfiConverterUInt32.allocationSize(value.index) + 
            FfiConverterUInt32.allocationSize(value.points) + 
            FfiConverterString.allocationSize(value.start) + 
            FfiConverterString.allocationSize(value.end) + 
            FfiConverterString.allocationSize(value.group) + 
            FfiConverterString.allocationSize(value.icon) + 
            FfiConverterString.allocationSize(value.title) + 
            FfiConverterString.allocationSize(value.description) + 
            FfiConverterArrayTypeAchievementTask.allocationSize(value.tasks) + 
            FfiConverterOptionalString.allocationSize(value.data) + 
            FfiConverterUInt32.allocationSize(value.totalCompletions) + 
            FfiConverterFloat64.allocationSize(value.completionRate) + 
            FfiConverterUInt64.allocationSize(value.createdAt) + 
            FfiConverterUInt64.allocationSize(value.updatedAt);
            
        }
    };
    return new FFIConverter();
})();


export type AchievementProgression = {
    id: string,
    achievementId: string,
    taskId: string,
    worldAddress: FieldElement,
    namespace: string,
    playerId: FieldElement,
    count: /*u32*/number,
    completed: boolean,
    completedAt: /*u64*/bigint | undefined,
    createdAt: /*u64*/bigint,
    updatedAt: /*u64*/bigint
}

/**
 * Generated factory for {@link AchievementProgression} record objects.
 */
export const AchievementProgression = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<AchievementProgression, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AchievementProgression}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link AchievementProgression}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<AchievementProgression>,
    });
})();

const FfiConverterTypeAchievementProgression = (() => {
    type TypeName = AchievementProgression;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterString.read(from), 
                achievementId: FfiConverterString.read(from), 
                taskId: FfiConverterString.read(from), 
                worldAddress: FfiConverterTypeFieldElement.read(from), 
                namespace: FfiConverterString.read(from), 
                playerId: FfiConverterTypeFieldElement.read(from), 
                count: FfiConverterUInt32.read(from), 
                completed: FfiConverterBool.read(from), 
                completedAt: FfiConverterOptionalUInt64.read(from), 
                createdAt: FfiConverterUInt64.read(from), 
                updatedAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.id, into);
            FfiConverterString.write(value.achievementId, into);
            FfiConverterString.write(value.taskId, into);
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
            FfiConverterString.write(value.namespace, into);
            FfiConverterTypeFieldElement.write(value.playerId, into);
            FfiConverterUInt32.write(value.count, into);
            FfiConverterBool.write(value.completed, into);
            FfiConverterOptionalUInt64.write(value.completedAt, into);
            FfiConverterUInt64.write(value.createdAt, into);
            FfiConverterUInt64.write(value.updatedAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.id) + 
            FfiConverterString.allocationSize(value.achievementId) + 
            FfiConverterString.allocationSize(value.taskId) + 
            FfiConverterTypeFieldElement.allocationSize(value.worldAddress) + 
            FfiConverterString.allocationSize(value.namespace) + 
            FfiConverterTypeFieldElement.allocationSize(value.playerId) + 
            FfiConverterUInt32.allocationSize(value.count) + 
            FfiConverterBool.allocationSize(value.completed) + 
            FfiConverterOptionalUInt64.allocationSize(value.completedAt) + 
            FfiConverterUInt64.allocationSize(value.createdAt) + 
            FfiConverterUInt64.allocationSize(value.updatedAt);
            
        }
    };
    return new FFIConverter();
})();


export type AchievementQuery = {
    worldAddresses: Array<FieldElement>,
    namespaces: Array<string>,
    hidden: boolean | undefined,
    pagination: Pagination
}

/**
 * Generated factory for {@link AchievementQuery} record objects.
 */
export const AchievementQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<AchievementQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AchievementQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link AchievementQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<AchievementQuery>,
    });
})();

const FfiConverterTypeAchievementQuery = (() => {
    type TypeName = AchievementQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                namespaces: FfiConverterArrayString.read(from), 
                hidden: FfiConverterOptionalBool.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.worldAddresses, into);
            FfiConverterArrayString.write(value.namespaces, into);
            FfiConverterOptionalBool.write(value.hidden, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.worldAddresses) + 
            FfiConverterArrayString.allocationSize(value.namespaces) + 
            FfiConverterOptionalBool.allocationSize(value.hidden) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type AchievementTask = {
    taskId: string,
    description: string,
    total: /*u32*/number,
    totalCompletions: /*u32*/number,
    completionRate: /*f64*/number,
    createdAt: /*u64*/bigint
}

/**
 * Generated factory for {@link AchievementTask} record objects.
 */
export const AchievementTask = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<AchievementTask, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AchievementTask}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link AchievementTask}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<AchievementTask>,
    });
})();

const FfiConverterTypeAchievementTask = (() => {
    type TypeName = AchievementTask;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                taskId: FfiConverterString.read(from), 
                description: FfiConverterString.read(from), 
                total: FfiConverterUInt32.read(from), 
                totalCompletions: FfiConverterUInt32.read(from), 
                completionRate: FfiConverterFloat64.read(from), 
                createdAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.taskId, into);
            FfiConverterString.write(value.description, into);
            FfiConverterUInt32.write(value.total, into);
            FfiConverterUInt32.write(value.totalCompletions, into);
            FfiConverterFloat64.write(value.completionRate, into);
            FfiConverterUInt64.write(value.createdAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.taskId) + 
            FfiConverterString.allocationSize(value.description) + 
            FfiConverterUInt32.allocationSize(value.total) + 
            FfiConverterUInt32.allocationSize(value.totalCompletions) + 
            FfiConverterFloat64.allocationSize(value.completionRate) + 
            FfiConverterUInt64.allocationSize(value.createdAt);
            
        }
    };
    return new FFIConverter();
})();


export type ActionCount = {
    actionName: string,
    count: /*u32*/number
}

/**
 * Generated factory for {@link ActionCount} record objects.
 */
export const ActionCount = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ActionCount, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ActionCount}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ActionCount}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ActionCount>,
    });
})();

const FfiConverterTypeActionCount = (() => {
    type TypeName = ActionCount;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                actionName: FfiConverterString.read(from), 
                count: FfiConverterUInt32.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.actionName, into);
            FfiConverterUInt32.write(value.count, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.actionName) + 
            FfiConverterUInt32.allocationSize(value.count);
            
        }
    };
    return new FFIConverter();
})();


export type Activity = {
    id: string,
    worldAddress: FieldElement,
    namespace: string,
    callerAddress: FieldElement,
    sessionStart: /*u64*/bigint,
    sessionEnd: /*u64*/bigint,
    actionCount: /*u32*/number,
    actions: Array<ActionCount>,
    updatedAt: /*u64*/bigint
}

/**
 * Generated factory for {@link Activity} record objects.
 */
export const Activity = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Activity, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Activity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Activity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Activity>,
    });
})();

const FfiConverterTypeActivity = (() => {
    type TypeName = Activity;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterString.read(from), 
                worldAddress: FfiConverterTypeFieldElement.read(from), 
                namespace: FfiConverterString.read(from), 
                callerAddress: FfiConverterTypeFieldElement.read(from), 
                sessionStart: FfiConverterUInt64.read(from), 
                sessionEnd: FfiConverterUInt64.read(from), 
                actionCount: FfiConverterUInt32.read(from), 
                actions: FfiConverterArrayTypeActionCount.read(from), 
                updatedAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.id, into);
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
            FfiConverterString.write(value.namespace, into);
            FfiConverterTypeFieldElement.write(value.callerAddress, into);
            FfiConverterUInt64.write(value.sessionStart, into);
            FfiConverterUInt64.write(value.sessionEnd, into);
            FfiConverterUInt32.write(value.actionCount, into);
            FfiConverterArrayTypeActionCount.write(value.actions, into);
            FfiConverterUInt64.write(value.updatedAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.id) + 
            FfiConverterTypeFieldElement.allocationSize(value.worldAddress) + 
            FfiConverterString.allocationSize(value.namespace) + 
            FfiConverterTypeFieldElement.allocationSize(value.callerAddress) + 
            FfiConverterUInt64.allocationSize(value.sessionStart) + 
            FfiConverterUInt64.allocationSize(value.sessionEnd) + 
            FfiConverterUInt32.allocationSize(value.actionCount) + 
            FfiConverterArrayTypeActionCount.allocationSize(value.actions) + 
            FfiConverterUInt64.allocationSize(value.updatedAt);
            
        }
    };
    return new FFIConverter();
})();


export type ActivityQuery = {
    worldAddresses: Array<FieldElement>,
    namespaces: Array<string>,
    callerAddresses: Array<FieldElement>,
    fromTime: /*u64*/bigint | undefined,
    toTime: /*u64*/bigint | undefined,
    pagination: Pagination
}

/**
 * Generated factory for {@link ActivityQuery} record objects.
 */
export const ActivityQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ActivityQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ActivityQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ActivityQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ActivityQuery>,
    });
})();

const FfiConverterTypeActivityQuery = (() => {
    type TypeName = ActivityQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                namespaces: FfiConverterArrayString.read(from), 
                callerAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                fromTime: FfiConverterOptionalUInt64.read(from), 
                toTime: FfiConverterOptionalUInt64.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.worldAddresses, into);
            FfiConverterArrayString.write(value.namespaces, into);
            FfiConverterArrayTypeFieldElement.write(value.callerAddresses, into);
            FfiConverterOptionalUInt64.write(value.fromTime, into);
            FfiConverterOptionalUInt64.write(value.toTime, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.worldAddresses) + 
            FfiConverterArrayString.allocationSize(value.namespaces) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.callerAddresses) + 
            FfiConverterOptionalUInt64.allocationSize(value.fromTime) + 
            FfiConverterOptionalUInt64.allocationSize(value.toTime) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type AggregationEntry = {
    id: string,
    aggregatorId: string,
    entityId: string,
    value: U256,
    displayValue: string,
    position: /*u64*/bigint,
    modelId: string,
    createdAt: /*u64*/bigint,
    updatedAt: /*u64*/bigint
}

/**
 * Generated factory for {@link AggregationEntry} record objects.
 */
export const AggregationEntry = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<AggregationEntry, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AggregationEntry}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link AggregationEntry}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<AggregationEntry>,
    });
})();

const FfiConverterTypeAggregationEntry = (() => {
    type TypeName = AggregationEntry;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterString.read(from), 
                aggregatorId: FfiConverterString.read(from), 
                entityId: FfiConverterString.read(from), 
                value: FfiConverterTypeU256.read(from), 
                displayValue: FfiConverterString.read(from), 
                position: FfiConverterUInt64.read(from), 
                modelId: FfiConverterString.read(from), 
                createdAt: FfiConverterUInt64.read(from), 
                updatedAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.id, into);
            FfiConverterString.write(value.aggregatorId, into);
            FfiConverterString.write(value.entityId, into);
            FfiConverterTypeU256.write(value.value, into);
            FfiConverterString.write(value.displayValue, into);
            FfiConverterUInt64.write(value.position, into);
            FfiConverterString.write(value.modelId, into);
            FfiConverterUInt64.write(value.createdAt, into);
            FfiConverterUInt64.write(value.updatedAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.id) + 
            FfiConverterString.allocationSize(value.aggregatorId) + 
            FfiConverterString.allocationSize(value.entityId) + 
            FfiConverterTypeU256.allocationSize(value.value) + 
            FfiConverterString.allocationSize(value.displayValue) + 
            FfiConverterUInt64.allocationSize(value.position) + 
            FfiConverterString.allocationSize(value.modelId) + 
            FfiConverterUInt64.allocationSize(value.createdAt) + 
            FfiConverterUInt64.allocationSize(value.updatedAt);
            
        }
    };
    return new FFIConverter();
})();


export type AggregationQuery = {
    aggregatorIds: Array<string>,
    entityIds: Array<string>,
    pagination: Pagination
}

/**
 * Generated factory for {@link AggregationQuery} record objects.
 */
export const AggregationQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<AggregationQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AggregationQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link AggregationQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<AggregationQuery>,
    });
})();

const FfiConverterTypeAggregationQuery = (() => {
    type TypeName = AggregationQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                aggregatorIds: FfiConverterArrayString.read(from), 
                entityIds: FfiConverterArrayString.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayString.write(value.aggregatorIds, into);
            FfiConverterArrayString.write(value.entityIds, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayString.allocationSize(value.aggregatorIds) + 
            FfiConverterArrayString.allocationSize(value.entityIds) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type AttributeFilter = {
    traitName: string,
    traitValue: string
}

/**
 * Generated factory for {@link AttributeFilter} record objects.
 */
export const AttributeFilter = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<AttributeFilter, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AttributeFilter}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link AttributeFilter}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<AttributeFilter>,
    });
})();

const FfiConverterTypeAttributeFilter = (() => {
    type TypeName = AttributeFilter;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                traitName: FfiConverterString.read(from), 
                traitValue: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.traitName, into);
            FfiConverterString.write(value.traitValue, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.traitName) + 
            FfiConverterString.allocationSize(value.traitValue);
            
        }
    };
    return new FFIConverter();
})();


export type CompositeClause = {
    operator: LogicalOperator,
    clauses: Array<Clause>
}

/**
 * Generated factory for {@link CompositeClause} record objects.
 */
export const CompositeClause = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<CompositeClause, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CompositeClause}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link CompositeClause}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<CompositeClause>,
    });
})();

const FfiConverterTypeCompositeClause = (() => {
    type TypeName = CompositeClause;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                operator: FfiConverterTypeLogicalOperator.read(from), 
                clauses: FfiConverterArrayTypeClause.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeLogicalOperator.write(value.operator, into);
            FfiConverterArrayTypeClause.write(value.clauses, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeLogicalOperator.allocationSize(value.operator) + 
            FfiConverterArrayTypeClause.allocationSize(value.clauses);
            
        }
    };
    return new FFIConverter();
})();


export type Contract = {
    contractAddress: FieldElement,
    contractType: ContractType,
    head: /*u64*/bigint | undefined,
    tps: /*u64*/bigint | undefined,
    lastBlockTimestamp: /*u64*/bigint | undefined,
    lastPendingBlockTx: FieldElement | undefined,
    updatedAt: /*u64*/bigint,
    createdAt: /*u64*/bigint
}

/**
 * Generated factory for {@link Contract} record objects.
 */
export const Contract = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Contract, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Contract}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Contract}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Contract>,
    });
})();

const FfiConverterTypeContract = (() => {
    type TypeName = Contract;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                contractType: FfiConverterTypeContractType.read(from), 
                head: FfiConverterOptionalUInt64.read(from), 
                tps: FfiConverterOptionalUInt64.read(from), 
                lastBlockTimestamp: FfiConverterOptionalUInt64.read(from), 
                lastPendingBlockTx: FfiConverterOptionalTypeFieldElement.read(from), 
                updatedAt: FfiConverterUInt64.read(from), 
                createdAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterTypeContractType.write(value.contractType, into);
            FfiConverterOptionalUInt64.write(value.head, into);
            FfiConverterOptionalUInt64.write(value.tps, into);
            FfiConverterOptionalUInt64.write(value.lastBlockTimestamp, into);
            FfiConverterOptionalTypeFieldElement.write(value.lastPendingBlockTx, into);
            FfiConverterUInt64.write(value.updatedAt, into);
            FfiConverterUInt64.write(value.createdAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterTypeContractType.allocationSize(value.contractType) + 
            FfiConverterOptionalUInt64.allocationSize(value.head) + 
            FfiConverterOptionalUInt64.allocationSize(value.tps) + 
            FfiConverterOptionalUInt64.allocationSize(value.lastBlockTimestamp) + 
            FfiConverterOptionalTypeFieldElement.allocationSize(value.lastPendingBlockTx) + 
            FfiConverterUInt64.allocationSize(value.updatedAt) + 
            FfiConverterUInt64.allocationSize(value.createdAt);
            
        }
    };
    return new FFIConverter();
})();


export type ContractQuery = {
    contractAddresses: Array<FieldElement>,
    contractTypes: Array<ContractType>
}

/**
 * Generated factory for {@link ContractQuery} record objects.
 */
export const ContractQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ContractQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ContractQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ContractQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ContractQuery>,
    });
})();

const FfiConverterTypeContractQuery = (() => {
    type TypeName = ContractQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                contractTypes: FfiConverterArrayTypeContractType.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayTypeContractType.write(value.contractTypes, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayTypeContractType.allocationSize(value.contractTypes);
            
        }
    };
    return new FFIConverter();
})();


export type Controller = {
    address: FieldElement,
    username: string,
    deployedAtTimestamp: /*u64*/bigint
}

/**
 * Generated factory for {@link Controller} record objects.
 */
export const Controller = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Controller, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Controller}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Controller}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Controller>,
    });
})();

const FfiConverterTypeController = (() => {
    type TypeName = Controller;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                address: FfiConverterTypeFieldElement.read(from), 
                username: FfiConverterString.read(from), 
                deployedAtTimestamp: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.address, into);
            FfiConverterString.write(value.username, into);
            FfiConverterUInt64.write(value.deployedAtTimestamp, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.address) + 
            FfiConverterString.allocationSize(value.username) + 
            FfiConverterUInt64.allocationSize(value.deployedAtTimestamp);
            
        }
    };
    return new FFIConverter();
})();


export type ControllerQuery = {
    pagination: Pagination,
    contractAddresses: Array<FieldElement>,
    usernames: Array<string>
}

/**
 * Generated factory for {@link ControllerQuery} record objects.
 */
export const ControllerQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ControllerQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ControllerQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ControllerQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ControllerQuery>,
    });
})();

const FfiConverterTypeControllerQuery = (() => {
    type TypeName = ControllerQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                pagination: FfiConverterTypePagination.read(from), 
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                usernames: FfiConverterArrayString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypePagination.write(value.pagination, into);
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayString.write(value.usernames, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypePagination.allocationSize(value.pagination) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayString.allocationSize(value.usernames);
            
        }
    };
    return new FFIConverter();
})();


export type Entity = {
    worldAddress: FieldElement,
    hashedKeys: FieldElement,
    models: Array<Struct>,
    createdAt: /*u64*/bigint,
    updatedAt: /*u64*/bigint,
    executedAt: /*u64*/bigint
}

/**
 * Generated factory for {@link Entity} record objects.
 */
export const Entity = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Entity, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Entity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Entity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Entity>,
    });
})();

const FfiConverterTypeEntity = (() => {
    type TypeName = Entity;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddress: FfiConverterTypeFieldElement.read(from), 
                hashedKeys: FfiConverterTypeFieldElement.read(from), 
                models: FfiConverterArrayTypeStruct.read(from), 
                createdAt: FfiConverterUInt64.read(from), 
                updatedAt: FfiConverterUInt64.read(from), 
                executedAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
            FfiConverterTypeFieldElement.write(value.hashedKeys, into);
            FfiConverterArrayTypeStruct.write(value.models, into);
            FfiConverterUInt64.write(value.createdAt, into);
            FfiConverterUInt64.write(value.updatedAt, into);
            FfiConverterUInt64.write(value.executedAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.worldAddress) + 
            FfiConverterTypeFieldElement.allocationSize(value.hashedKeys) + 
            FfiConverterArrayTypeStruct.allocationSize(value.models) + 
            FfiConverterUInt64.allocationSize(value.createdAt) + 
            FfiConverterUInt64.allocationSize(value.updatedAt) + 
            FfiConverterUInt64.allocationSize(value.executedAt);
            
        }
    };
    return new FFIConverter();
})();


export type EnumOption = {
    name: string,
    ty: Ty
}

/**
 * Generated factory for {@link EnumOption} record objects.
 */
export const EnumOption = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<EnumOption, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link EnumOption}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link EnumOption}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<EnumOption>,
    });
})();

const FfiConverterTypeEnumOption = (() => {
    type TypeName = EnumOption;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                name: FfiConverterString.read(from), 
                ty: FfiConverterTypeTy.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.name, into);
            FfiConverterTypeTy.write(value.ty, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.name) + 
            FfiConverterTypeTy.allocationSize(value.ty);
            
        }
    };
    return new FFIConverter();
})();


export type EnumType = {
    name: string,
    option: /*u8*/number,
    options: Array<EnumOption>
}

/**
 * Generated factory for {@link EnumType} record objects.
 */
export const EnumType = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<EnumType, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link EnumType}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link EnumType}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<EnumType>,
    });
})();

const FfiConverterTypeEnumType = (() => {
    type TypeName = EnumType;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                name: FfiConverterString.read(from), 
                option: FfiConverterUInt8.read(from), 
                options: FfiConverterArrayTypeEnumOption.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.name, into);
            FfiConverterUInt8.write(value.option, into);
            FfiConverterArrayTypeEnumOption.write(value.options, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.name) + 
            FfiConverterUInt8.allocationSize(value.option) + 
            FfiConverterArrayTypeEnumOption.allocationSize(value.options);
            
        }
    };
    return new FFIConverter();
})();


export type Event = {
    keys: Array<FieldElement>,
    data: Array<FieldElement>,
    transactionHash: FieldElement
}

/**
 * Generated factory for {@link Event} record objects.
 */
export const Event = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Event, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Event}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Event}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Event>,
    });
})();

const FfiConverterTypeEvent = (() => {
    type TypeName = Event;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                keys: FfiConverterArrayTypeFieldElement.read(from), 
                data: FfiConverterArrayTypeFieldElement.read(from), 
                transactionHash: FfiConverterTypeFieldElement.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.keys, into);
            FfiConverterArrayTypeFieldElement.write(value.data, into);
            FfiConverterTypeFieldElement.write(value.transactionHash, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.keys) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.data) + 
            FfiConverterTypeFieldElement.allocationSize(value.transactionHash);
            
        }
    };
    return new FFIConverter();
})();


export type EventQuery = {
    keys: KeysClause | undefined,
    pagination: Pagination
}

/**
 * Generated factory for {@link EventQuery} record objects.
 */
export const EventQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<EventQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link EventQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link EventQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<EventQuery>,
    });
})();

const FfiConverterTypeEventQuery = (() => {
    type TypeName = EventQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                keys: FfiConverterOptionalTypeKeysClause.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalTypeKeysClause.write(value.keys, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalTypeKeysClause.allocationSize(value.keys) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type FixedSizeArray = {
    array: Array<Ty>,
    size: /*u32*/number
}

/**
 * Generated factory for {@link FixedSizeArray} record objects.
 */
export const FixedSizeArray = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<FixedSizeArray, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link FixedSizeArray}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link FixedSizeArray}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<FixedSizeArray>,
    });
})();

const FfiConverterTypeFixedSizeArray = (() => {
    type TypeName = FixedSizeArray;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                array: FfiConverterArrayTypeTy.read(from), 
                size: FfiConverterUInt32.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeTy.write(value.array, into);
            FfiConverterUInt32.write(value.size, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeTy.allocationSize(value.array) + 
            FfiConverterUInt32.allocationSize(value.size);
            
        }
    };
    return new FFIConverter();
})();


export type KeysClause = {
    keys: Array<FieldElement | undefined>,
    patternMatching: PatternMatching,
    models: Array<string>
}

/**
 * Generated factory for {@link KeysClause} record objects.
 */
export const KeysClause = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<KeysClause, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link KeysClause}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link KeysClause}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<KeysClause>,
    });
})();

const FfiConverterTypeKeysClause = (() => {
    type TypeName = KeysClause;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                keys: FfiConverterArrayOptionalTypeFieldElement.read(from), 
                patternMatching: FfiConverterTypePatternMatching.read(from), 
                models: FfiConverterArrayString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayOptionalTypeFieldElement.write(value.keys, into);
            FfiConverterTypePatternMatching.write(value.patternMatching, into);
            FfiConverterArrayString.write(value.models, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayOptionalTypeFieldElement.allocationSize(value.keys) + 
            FfiConverterTypePatternMatching.allocationSize(value.patternMatching) + 
            FfiConverterArrayString.allocationSize(value.models);
            
        }
    };
    return new FFIConverter();
})();


export type Member = {
    name: string,
    ty: Ty,
    key: boolean
}

/**
 * Generated factory for {@link Member} record objects.
 */
export const Member = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Member, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Member}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Member}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Member>,
    });
})();

const FfiConverterTypeMember = (() => {
    type TypeName = Member;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                name: FfiConverterString.read(from), 
                ty: FfiConverterTypeTy.read(from), 
                key: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.name, into);
            FfiConverterTypeTy.write(value.ty, into);
            FfiConverterBool.write(value.key, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.name) + 
            FfiConverterTypeTy.allocationSize(value.ty) + 
            FfiConverterBool.allocationSize(value.key);
            
        }
    };
    return new FFIConverter();
})();


export type MemberClause = {
    model: string,
    member: string,
    operator: ComparisonOperator,
    value: MemberValue
}

/**
 * Generated factory for {@link MemberClause} record objects.
 */
export const MemberClause = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<MemberClause, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MemberClause}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link MemberClause}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<MemberClause>,
    });
})();

const FfiConverterTypeMemberClause = (() => {
    type TypeName = MemberClause;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                model: FfiConverterString.read(from), 
                member: FfiConverterString.read(from), 
                operator: FfiConverterTypeComparisonOperator.read(from), 
                value: FfiConverterTypeMemberValue.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.model, into);
            FfiConverterString.write(value.member, into);
            FfiConverterTypeComparisonOperator.write(value.operator, into);
            FfiConverterTypeMemberValue.write(value.value, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.model) + 
            FfiConverterString.allocationSize(value.member) + 
            FfiConverterTypeComparisonOperator.allocationSize(value.operator) + 
            FfiConverterTypeMemberValue.allocationSize(value.value);
            
        }
    };
    return new FFIConverter();
})();


export type Message = {
    message: string,
    signature: Array<FieldElement>,
    worldAddress: FieldElement
}

/**
 * Generated factory for {@link Message} record objects.
 */
export const Message = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Message, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Message}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Message}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Message>,
    });
})();

const FfiConverterTypeMessage = (() => {
    type TypeName = Message;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                message: FfiConverterString.read(from), 
                signature: FfiConverterArrayTypeFieldElement.read(from), 
                worldAddress: FfiConverterTypeFieldElement.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.message, into);
            FfiConverterArrayTypeFieldElement.write(value.signature, into);
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.message) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.signature) + 
            FfiConverterTypeFieldElement.allocationSize(value.worldAddress);
            
        }
    };
    return new FFIConverter();
})();


export type Model = {
    worldAddress: FieldElement,
    schema: Ty,
    namespace: string,
    name: string,
    selector: FieldElement,
    packedSize: /*u32*/number,
    unpackedSize: /*u32*/number,
    classHash: FieldElement,
    contractAddress: FieldElement,
    layout: string,
    useLegacyStore: boolean
}

/**
 * Generated factory for {@link Model} record objects.
 */
export const Model = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Model, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Model}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Model}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Model>,
    });
})();

const FfiConverterTypeModel = (() => {
    type TypeName = Model;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddress: FfiConverterTypeFieldElement.read(from), 
                schema: FfiConverterTypeTy.read(from), 
                namespace: FfiConverterString.read(from), 
                name: FfiConverterString.read(from), 
                selector: FfiConverterTypeFieldElement.read(from), 
                packedSize: FfiConverterUInt32.read(from), 
                unpackedSize: FfiConverterUInt32.read(from), 
                classHash: FfiConverterTypeFieldElement.read(from), 
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                layout: FfiConverterString.read(from), 
                useLegacyStore: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
            FfiConverterTypeTy.write(value.schema, into);
            FfiConverterString.write(value.namespace, into);
            FfiConverterString.write(value.name, into);
            FfiConverterTypeFieldElement.write(value.selector, into);
            FfiConverterUInt32.write(value.packedSize, into);
            FfiConverterUInt32.write(value.unpackedSize, into);
            FfiConverterTypeFieldElement.write(value.classHash, into);
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterString.write(value.layout, into);
            FfiConverterBool.write(value.useLegacyStore, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.worldAddress) + 
            FfiConverterTypeTy.allocationSize(value.schema) + 
            FfiConverterString.allocationSize(value.namespace) + 
            FfiConverterString.allocationSize(value.name) + 
            FfiConverterTypeFieldElement.allocationSize(value.selector) + 
            FfiConverterUInt32.allocationSize(value.packedSize) + 
            FfiConverterUInt32.allocationSize(value.unpackedSize) + 
            FfiConverterTypeFieldElement.allocationSize(value.classHash) + 
            FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterString.allocationSize(value.layout) + 
            FfiConverterBool.allocationSize(value.useLegacyStore);
            
        }
    };
    return new FFIConverter();
})();


export type OrderBy = {
    field: string,
    direction: OrderDirection
}

/**
 * Generated factory for {@link OrderBy} record objects.
 */
export const OrderBy = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<OrderBy, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link OrderBy}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link OrderBy}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<OrderBy>,
    });
})();

const FfiConverterTypeOrderBy = (() => {
    type TypeName = OrderBy;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                field: FfiConverterString.read(from), 
                direction: FfiConverterTypeOrderDirection.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.field, into);
            FfiConverterTypeOrderDirection.write(value.direction, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.field) + 
            FfiConverterTypeOrderDirection.allocationSize(value.direction);
            
        }
    };
    return new FFIConverter();
})();


export type PageAchievement = {
    items: Array<Achievement>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageAchievement} record objects.
 */
export const PageAchievement = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageAchievement, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageAchievement}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageAchievement}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageAchievement>,
    });
})();

const FfiConverterTypePageAchievement = (() => {
    type TypeName = PageAchievement;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeAchievement.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeAchievement.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeAchievement.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageActivity = {
    items: Array<Activity>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageActivity} record objects.
 */
export const PageActivity = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageActivity, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageActivity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageActivity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageActivity>,
    });
})();

const FfiConverterTypePageActivity = (() => {
    type TypeName = PageActivity;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeActivity.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeActivity.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeActivity.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageAggregationEntry = {
    items: Array<AggregationEntry>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageAggregationEntry} record objects.
 */
export const PageAggregationEntry = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageAggregationEntry, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageAggregationEntry}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageAggregationEntry}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageAggregationEntry>,
    });
})();

const FfiConverterTypePageAggregationEntry = (() => {
    type TypeName = PageAggregationEntry;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeAggregationEntry.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeAggregationEntry.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeAggregationEntry.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageController = {
    items: Array<Controller>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageController} record objects.
 */
export const PageController = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageController, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageController}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageController}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageController>,
    });
})();

const FfiConverterTypePageController = (() => {
    type TypeName = PageController;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeController.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeController.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeController.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageEntity = {
    items: Array<Entity>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageEntity} record objects.
 */
export const PageEntity = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageEntity, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageEntity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageEntity}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageEntity>,
    });
})();

const FfiConverterTypePageEntity = (() => {
    type TypeName = PageEntity;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeEntity.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeEntity.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeEntity.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageEvent = {
    items: Array<Event>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageEvent} record objects.
 */
export const PageEvent = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageEvent, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageEvent}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageEvent}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageEvent>,
    });
})();

const FfiConverterTypePageEvent = (() => {
    type TypeName = PageEvent;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeEvent.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeEvent.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeEvent.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PagePlayerAchievement = {
    items: Array<PlayerAchievementEntry>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PagePlayerAchievement} record objects.
 */
export const PagePlayerAchievement = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PagePlayerAchievement, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PagePlayerAchievement}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PagePlayerAchievement}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PagePlayerAchievement>,
    });
})();

const FfiConverterTypePagePlayerAchievement = (() => {
    type TypeName = PagePlayerAchievement;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypePlayerAchievementEntry.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypePlayerAchievementEntry.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypePlayerAchievementEntry.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageToken = {
    items: Array<Token>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageToken} record objects.
 */
export const PageToken = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageToken, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageToken}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageToken}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageToken>,
    });
})();

const FfiConverterTypePageToken = (() => {
    type TypeName = PageToken;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeToken.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeToken.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeToken.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageTokenBalance = {
    items: Array<TokenBalance>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageTokenBalance} record objects.
 */
export const PageTokenBalance = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageTokenBalance, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageTokenBalance}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageTokenBalance}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageTokenBalance>,
    });
})();

const FfiConverterTypePageTokenBalance = (() => {
    type TypeName = PageTokenBalance;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeTokenBalance.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeTokenBalance.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeTokenBalance.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageTokenContract = {
    items: Array<TokenContract>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageTokenContract} record objects.
 */
export const PageTokenContract = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageTokenContract, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageTokenContract}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageTokenContract}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageTokenContract>,
    });
})();

const FfiConverterTypePageTokenContract = (() => {
    type TypeName = PageTokenContract;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeTokenContract.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeTokenContract.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeTokenContract.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageTokenTransfer = {
    items: Array<TokenTransfer>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageTokenTransfer} record objects.
 */
export const PageTokenTransfer = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageTokenTransfer, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageTokenTransfer}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageTokenTransfer}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageTokenTransfer>,
    });
})();

const FfiConverterTypePageTokenTransfer = (() => {
    type TypeName = PageTokenTransfer;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeTokenTransfer.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeTokenTransfer.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeTokenTransfer.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type PageTransaction = {
    items: Array<Transaction>,
    nextCursor: string | undefined
}

/**
 * Generated factory for {@link PageTransaction} record objects.
 */
export const PageTransaction = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PageTransaction, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PageTransaction}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PageTransaction}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PageTransaction>,
    });
})();

const FfiConverterTypePageTransaction = (() => {
    type TypeName = PageTransaction;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                items: FfiConverterArrayTypeTransaction.read(from), 
                nextCursor: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeTransaction.write(value.items, into);
            FfiConverterOptionalString.write(value.nextCursor, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeTransaction.allocationSize(value.items) + 
            FfiConverterOptionalString.allocationSize(value.nextCursor);
            
        }
    };
    return new FFIConverter();
})();


export type Pagination = {
    cursor: string | undefined,
    limit: /*u32*/number | undefined,
    direction: PaginationDirection,
    orderBy: Array<OrderBy>
}

/**
 * Generated factory for {@link Pagination} record objects.
 */
export const Pagination = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Pagination, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Pagination}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Pagination}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Pagination>,
    });
})();

const FfiConverterTypePagination = (() => {
    type TypeName = Pagination;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                cursor: FfiConverterOptionalString.read(from), 
                limit: FfiConverterOptionalUInt32.read(from), 
                direction: FfiConverterTypePaginationDirection.read(from), 
                orderBy: FfiConverterArrayTypeOrderBy.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalString.write(value.cursor, into);
            FfiConverterOptionalUInt32.write(value.limit, into);
            FfiConverterTypePaginationDirection.write(value.direction, into);
            FfiConverterArrayTypeOrderBy.write(value.orderBy, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalString.allocationSize(value.cursor) + 
            FfiConverterOptionalUInt32.allocationSize(value.limit) + 
            FfiConverterTypePaginationDirection.allocationSize(value.direction) + 
            FfiConverterArrayTypeOrderBy.allocationSize(value.orderBy);
            
        }
    };
    return new FFIConverter();
})();


export type PlayerAchievementEntry = {
    playerAddress: FieldElement,
    stats: PlayerAchievementStats,
    achievements: Array<PlayerAchievementProgress>
}

/**
 * Generated factory for {@link PlayerAchievementEntry} record objects.
 */
export const PlayerAchievementEntry = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PlayerAchievementEntry, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PlayerAchievementEntry}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PlayerAchievementEntry}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PlayerAchievementEntry>,
    });
})();

const FfiConverterTypePlayerAchievementEntry = (() => {
    type TypeName = PlayerAchievementEntry;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                playerAddress: FfiConverterTypeFieldElement.read(from), 
                stats: FfiConverterTypePlayerAchievementStats.read(from), 
                achievements: FfiConverterArrayTypePlayerAchievementProgress.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.playerAddress, into);
            FfiConverterTypePlayerAchievementStats.write(value.stats, into);
            FfiConverterArrayTypePlayerAchievementProgress.write(value.achievements, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.playerAddress) + 
            FfiConverterTypePlayerAchievementStats.allocationSize(value.stats) + 
            FfiConverterArrayTypePlayerAchievementProgress.allocationSize(value.achievements);
            
        }
    };
    return new FFIConverter();
})();


export type PlayerAchievementProgress = {
    achievement: Achievement,
    taskProgress: Array<TaskProgress>,
    completed: boolean,
    progressPercentage: /*f64*/number
}

/**
 * Generated factory for {@link PlayerAchievementProgress} record objects.
 */
export const PlayerAchievementProgress = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PlayerAchievementProgress, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PlayerAchievementProgress}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PlayerAchievementProgress}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PlayerAchievementProgress>,
    });
})();

const FfiConverterTypePlayerAchievementProgress = (() => {
    type TypeName = PlayerAchievementProgress;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                achievement: FfiConverterTypeAchievement.read(from), 
                taskProgress: FfiConverterArrayTypeTaskProgress.read(from), 
                completed: FfiConverterBool.read(from), 
                progressPercentage: FfiConverterFloat64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeAchievement.write(value.achievement, into);
            FfiConverterArrayTypeTaskProgress.write(value.taskProgress, into);
            FfiConverterBool.write(value.completed, into);
            FfiConverterFloat64.write(value.progressPercentage, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeAchievement.allocationSize(value.achievement) + 
            FfiConverterArrayTypeTaskProgress.allocationSize(value.taskProgress) + 
            FfiConverterBool.allocationSize(value.completed) + 
            FfiConverterFloat64.allocationSize(value.progressPercentage);
            
        }
    };
    return new FFIConverter();
})();


export type PlayerAchievementQuery = {
    worldAddresses: Array<FieldElement>,
    namespaces: Array<string>,
    playerAddresses: Array<FieldElement>,
    pagination: Pagination
}

/**
 * Generated factory for {@link PlayerAchievementQuery} record objects.
 */
export const PlayerAchievementQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PlayerAchievementQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PlayerAchievementQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PlayerAchievementQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PlayerAchievementQuery>,
    });
})();

const FfiConverterTypePlayerAchievementQuery = (() => {
    type TypeName = PlayerAchievementQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                namespaces: FfiConverterArrayString.read(from), 
                playerAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.worldAddresses, into);
            FfiConverterArrayString.write(value.namespaces, into);
            FfiConverterArrayTypeFieldElement.write(value.playerAddresses, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.worldAddresses) + 
            FfiConverterArrayString.allocationSize(value.namespaces) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.playerAddresses) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type PlayerAchievementStats = {
    totalPoints: /*u32*/number,
    completedAchievements: /*u32*/number,
    totalAchievements: /*u32*/number,
    completionPercentage: /*f64*/number,
    lastAchievementAt: /*u64*/bigint | undefined,
    createdAt: /*u64*/bigint,
    updatedAt: /*u64*/bigint
}

/**
 * Generated factory for {@link PlayerAchievementStats} record objects.
 */
export const PlayerAchievementStats = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PlayerAchievementStats, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PlayerAchievementStats}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PlayerAchievementStats}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PlayerAchievementStats>,
    });
})();

const FfiConverterTypePlayerAchievementStats = (() => {
    type TypeName = PlayerAchievementStats;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                totalPoints: FfiConverterUInt32.read(from), 
                completedAchievements: FfiConverterUInt32.read(from), 
                totalAchievements: FfiConverterUInt32.read(from), 
                completionPercentage: FfiConverterFloat64.read(from), 
                lastAchievementAt: FfiConverterOptionalUInt64.read(from), 
                createdAt: FfiConverterUInt64.read(from), 
                updatedAt: FfiConverterUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterUInt32.write(value.totalPoints, into);
            FfiConverterUInt32.write(value.completedAchievements, into);
            FfiConverterUInt32.write(value.totalAchievements, into);
            FfiConverterFloat64.write(value.completionPercentage, into);
            FfiConverterOptionalUInt64.write(value.lastAchievementAt, into);
            FfiConverterUInt64.write(value.createdAt, into);
            FfiConverterUInt64.write(value.updatedAt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterUInt32.allocationSize(value.totalPoints) + 
            FfiConverterUInt32.allocationSize(value.completedAchievements) + 
            FfiConverterUInt32.allocationSize(value.totalAchievements) + 
            FfiConverterFloat64.allocationSize(value.completionPercentage) + 
            FfiConverterOptionalUInt64.allocationSize(value.lastAchievementAt) + 
            FfiConverterUInt64.allocationSize(value.createdAt) + 
            FfiConverterUInt64.allocationSize(value.updatedAt);
            
        }
    };
    return new FFIConverter();
})();


export type Query = {
    worldAddresses: Array<FieldElement>,
    pagination: Pagination,
    clause: Clause | undefined,
    noHashedKeys: boolean,
    models: Array<string>,
    historical: boolean
}

/**
 * Generated factory for {@link Query} record objects.
 */
export const Query = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Query, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Query}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Query}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Query>,
    });
})();

const FfiConverterTypeQuery = (() => {
    type TypeName = Query;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                pagination: FfiConverterTypePagination.read(from), 
                clause: FfiConverterOptionalTypeClause.read(from), 
                noHashedKeys: FfiConverterBool.read(from), 
                models: FfiConverterArrayString.read(from), 
                historical: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.worldAddresses, into);
            FfiConverterTypePagination.write(value.pagination, into);
            FfiConverterOptionalTypeClause.write(value.clause, into);
            FfiConverterBool.write(value.noHashedKeys, into);
            FfiConverterArrayString.write(value.models, into);
            FfiConverterBool.write(value.historical, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.worldAddresses) + 
            FfiConverterTypePagination.allocationSize(value.pagination) + 
            FfiConverterOptionalTypeClause.allocationSize(value.clause) + 
            FfiConverterBool.allocationSize(value.noHashedKeys) + 
            FfiConverterArrayString.allocationSize(value.models) + 
            FfiConverterBool.allocationSize(value.historical);
            
        }
    };
    return new FFIConverter();
})();


export type Signature = {
    r: FieldElement,
    s: FieldElement
}

/**
 * Generated factory for {@link Signature} record objects.
 */
export const Signature = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Signature, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Signature}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Signature}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Signature>,
    });
})();

const FfiConverterTypeSignature = (() => {
    type TypeName = Signature;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                r: FfiConverterTypeFieldElement.read(from), 
                s: FfiConverterTypeFieldElement.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.r, into);
            FfiConverterTypeFieldElement.write(value.s, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.r) + 
            FfiConverterTypeFieldElement.allocationSize(value.s);
            
        }
    };
    return new FFIConverter();
})();


export type SqlField = {
    name: string,
    value: SqlValue
}

/**
 * Generated factory for {@link SqlField} record objects.
 */
export const SqlField = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<SqlField, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SqlField}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link SqlField}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<SqlField>,
    });
})();

const FfiConverterTypeSqlField = (() => {
    type TypeName = SqlField;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                name: FfiConverterString.read(from), 
                value: FfiConverterTypeSqlValue.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.name, into);
            FfiConverterTypeSqlValue.write(value.value, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.name) + 
            FfiConverterTypeSqlValue.allocationSize(value.value);
            
        }
    };
    return new FFIConverter();
})();


export type SqlRow = {
    fields: Array<SqlField>
}

/**
 * Generated factory for {@link SqlRow} record objects.
 */
export const SqlRow = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<SqlRow, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SqlRow}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link SqlRow}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<SqlRow>,
    });
})();

const FfiConverterTypeSqlRow = (() => {
    type TypeName = SqlRow;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                fields: FfiConverterArrayTypeSqlField.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeSqlField.write(value.fields, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeSqlField.allocationSize(value.fields);
            
        }
    };
    return new FFIConverter();
})();


export type Struct = {
    name: string,
    children: Array<Member>
}

/**
 * Generated factory for {@link Struct} record objects.
 */
export const Struct = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Struct, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Struct}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Struct}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Struct>,
    });
})();

const FfiConverterTypeStruct = (() => {
    type TypeName = Struct;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                name: FfiConverterString.read(from), 
                children: FfiConverterArrayTypeMember.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.name, into);
            FfiConverterArrayTypeMember.write(value.children, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.name) + 
            FfiConverterArrayTypeMember.allocationSize(value.children);
            
        }
    };
    return new FFIConverter();
})();


export type TaskProgress = {
    taskId: string,
    count: /*u32*/number,
    completed: boolean
}

/**
 * Generated factory for {@link TaskProgress} record objects.
 */
export const TaskProgress = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TaskProgress, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TaskProgress}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TaskProgress}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TaskProgress>,
    });
})();

const FfiConverterTypeTaskProgress = (() => {
    type TypeName = TaskProgress;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                taskId: FfiConverterString.read(from), 
                count: FfiConverterUInt32.read(from), 
                completed: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.taskId, into);
            FfiConverterUInt32.write(value.count, into);
            FfiConverterBool.write(value.completed, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.taskId) + 
            FfiConverterUInt32.allocationSize(value.count) + 
            FfiConverterBool.allocationSize(value.completed);
            
        }
    };
    return new FFIConverter();
})();


export type Token = {
    contractAddress: FieldElement,
    tokenId: U256 | undefined,
    name: string,
    symbol: string,
    decimals: /*u8*/number,
    metadata: string,
    totalSupply: U256 | undefined
}

/**
 * Generated factory for {@link Token} record objects.
 */
export const Token = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Token, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Token}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Token}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Token>,
    });
})();

const FfiConverterTypeToken = (() => {
    type TypeName = Token;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                tokenId: FfiConverterOptionalTypeU256.read(from), 
                name: FfiConverterString.read(from), 
                symbol: FfiConverterString.read(from), 
                decimals: FfiConverterUInt8.read(from), 
                metadata: FfiConverterString.read(from), 
                totalSupply: FfiConverterOptionalTypeU256.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterOptionalTypeU256.write(value.tokenId, into);
            FfiConverterString.write(value.name, into);
            FfiConverterString.write(value.symbol, into);
            FfiConverterUInt8.write(value.decimals, into);
            FfiConverterString.write(value.metadata, into);
            FfiConverterOptionalTypeU256.write(value.totalSupply, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterOptionalTypeU256.allocationSize(value.tokenId) + 
            FfiConverterString.allocationSize(value.name) + 
            FfiConverterString.allocationSize(value.symbol) + 
            FfiConverterUInt8.allocationSize(value.decimals) + 
            FfiConverterString.allocationSize(value.metadata) + 
            FfiConverterOptionalTypeU256.allocationSize(value.totalSupply);
            
        }
    };
    return new FFIConverter();
})();


export type TokenBalance = {
    balance: U256,
    accountAddress: FieldElement,
    contractAddress: FieldElement,
    tokenId: U256 | undefined
}

/**
 * Generated factory for {@link TokenBalance} record objects.
 */
export const TokenBalance = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenBalance, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenBalance}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenBalance}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenBalance>,
    });
})();

const FfiConverterTypeTokenBalance = (() => {
    type TypeName = TokenBalance;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                balance: FfiConverterTypeU256.read(from), 
                accountAddress: FfiConverterTypeFieldElement.read(from), 
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                tokenId: FfiConverterOptionalTypeU256.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeU256.write(value.balance, into);
            FfiConverterTypeFieldElement.write(value.accountAddress, into);
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterOptionalTypeU256.write(value.tokenId, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeU256.allocationSize(value.balance) + 
            FfiConverterTypeFieldElement.allocationSize(value.accountAddress) + 
            FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterOptionalTypeU256.allocationSize(value.tokenId);
            
        }
    };
    return new FFIConverter();
})();


export type TokenBalanceQuery = {
    contractAddresses: Array<FieldElement>,
    accountAddresses: Array<FieldElement>,
    tokenIds: Array<U256>,
    pagination: Pagination
}

/**
 * Generated factory for {@link TokenBalanceQuery} record objects.
 */
export const TokenBalanceQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenBalanceQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenBalanceQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenBalanceQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenBalanceQuery>,
    });
})();

const FfiConverterTypeTokenBalanceQuery = (() => {
    type TypeName = TokenBalanceQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                accountAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                tokenIds: FfiConverterArrayTypeU256.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayTypeFieldElement.write(value.accountAddresses, into);
            FfiConverterArrayTypeU256.write(value.tokenIds, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.accountAddresses) + 
            FfiConverterArrayTypeU256.allocationSize(value.tokenIds) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type TokenContract = {
    contractAddress: FieldElement,
    name: string,
    symbol: string,
    decimals: /*u8*/number,
    metadata: string,
    tokenMetadata: string,
    totalSupply: U256 | undefined
}

/**
 * Generated factory for {@link TokenContract} record objects.
 */
export const TokenContract = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenContract, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenContract}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenContract}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenContract>,
    });
})();

const FfiConverterTypeTokenContract = (() => {
    type TypeName = TokenContract;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                name: FfiConverterString.read(from), 
                symbol: FfiConverterString.read(from), 
                decimals: FfiConverterUInt8.read(from), 
                metadata: FfiConverterString.read(from), 
                tokenMetadata: FfiConverterString.read(from), 
                totalSupply: FfiConverterOptionalTypeU256.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterString.write(value.name, into);
            FfiConverterString.write(value.symbol, into);
            FfiConverterUInt8.write(value.decimals, into);
            FfiConverterString.write(value.metadata, into);
            FfiConverterString.write(value.tokenMetadata, into);
            FfiConverterOptionalTypeU256.write(value.totalSupply, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterString.allocationSize(value.name) + 
            FfiConverterString.allocationSize(value.symbol) + 
            FfiConverterUInt8.allocationSize(value.decimals) + 
            FfiConverterString.allocationSize(value.metadata) + 
            FfiConverterString.allocationSize(value.tokenMetadata) + 
            FfiConverterOptionalTypeU256.allocationSize(value.totalSupply);
            
        }
    };
    return new FFIConverter();
})();


export type TokenContractQuery = {
    contractAddresses: Array<FieldElement>,
    contractTypes: Array<ContractType>,
    pagination: Pagination
}

/**
 * Generated factory for {@link TokenContractQuery} record objects.
 */
export const TokenContractQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenContractQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenContractQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenContractQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenContractQuery>,
    });
})();

const FfiConverterTypeTokenContractQuery = (() => {
    type TypeName = TokenContractQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                contractTypes: FfiConverterArrayTypeContractType.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayTypeContractType.write(value.contractTypes, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayTypeContractType.allocationSize(value.contractTypes) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type TokenQuery = {
    contractAddresses: Array<FieldElement>,
    tokenIds: Array<U256>,
    attributeFilters: Array<AttributeFilter>,
    pagination: Pagination
}

/**
 * Generated factory for {@link TokenQuery} record objects.
 */
export const TokenQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenQuery>,
    });
})();

const FfiConverterTypeTokenQuery = (() => {
    type TypeName = TokenQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                tokenIds: FfiConverterArrayTypeU256.read(from), 
                attributeFilters: FfiConverterArrayTypeAttributeFilter.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayTypeU256.write(value.tokenIds, into);
            FfiConverterArrayTypeAttributeFilter.write(value.attributeFilters, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayTypeU256.allocationSize(value.tokenIds) + 
            FfiConverterArrayTypeAttributeFilter.allocationSize(value.attributeFilters) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type TokenTransfer = {
    id: string,
    contractAddress: FieldElement,
    fromAddress: FieldElement,
    toAddress: FieldElement,
    amount: U256,
    tokenId: U256 | undefined,
    executedAt: /*u64*/bigint,
    eventId: string | undefined
}

/**
 * Generated factory for {@link TokenTransfer} record objects.
 */
export const TokenTransfer = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenTransfer, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenTransfer}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenTransfer}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenTransfer>,
    });
})();

const FfiConverterTypeTokenTransfer = (() => {
    type TypeName = TokenTransfer;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterString.read(from), 
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                fromAddress: FfiConverterTypeFieldElement.read(from), 
                toAddress: FfiConverterTypeFieldElement.read(from), 
                amount: FfiConverterTypeU256.read(from), 
                tokenId: FfiConverterOptionalTypeU256.read(from), 
                executedAt: FfiConverterUInt64.read(from), 
                eventId: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.id, into);
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterTypeFieldElement.write(value.fromAddress, into);
            FfiConverterTypeFieldElement.write(value.toAddress, into);
            FfiConverterTypeU256.write(value.amount, into);
            FfiConverterOptionalTypeU256.write(value.tokenId, into);
            FfiConverterUInt64.write(value.executedAt, into);
            FfiConverterOptionalString.write(value.eventId, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.id) + 
            FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterTypeFieldElement.allocationSize(value.fromAddress) + 
            FfiConverterTypeFieldElement.allocationSize(value.toAddress) + 
            FfiConverterTypeU256.allocationSize(value.amount) + 
            FfiConverterOptionalTypeU256.allocationSize(value.tokenId) + 
            FfiConverterUInt64.allocationSize(value.executedAt) + 
            FfiConverterOptionalString.allocationSize(value.eventId);
            
        }
    };
    return new FFIConverter();
})();


export type TokenTransferQuery = {
    contractAddresses: Array<FieldElement>,
    accountAddresses: Array<FieldElement>,
    tokenIds: Array<U256>,
    pagination: Pagination
}

/**
 * Generated factory for {@link TokenTransferQuery} record objects.
 */
export const TokenTransferQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TokenTransferQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TokenTransferQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TokenTransferQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TokenTransferQuery>,
    });
})();

const FfiConverterTypeTokenTransferQuery = (() => {
    type TypeName = TokenTransferQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                accountAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                tokenIds: FfiConverterArrayTypeU256.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayTypeFieldElement.write(value.accountAddresses, into);
            FfiConverterArrayTypeU256.write(value.tokenIds, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.accountAddresses) + 
            FfiConverterArrayTypeU256.allocationSize(value.tokenIds) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type Transaction = {
    transactionHash: FieldElement,
    senderAddress: FieldElement,
    calldata: Array<FieldElement>,
    maxFee: FieldElement,
    signature: Array<FieldElement>,
    nonce: FieldElement,
    blockNumber: /*u64*/bigint,
    transactionType: string,
    blockTimestamp: /*u64*/bigint,
    calls: Array<TransactionCall>,
    uniqueModels: Array<FieldElement>
}

/**
 * Generated factory for {@link Transaction} record objects.
 */
export const Transaction = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Transaction, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Transaction}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Transaction}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Transaction>,
    });
})();

const FfiConverterTypeTransaction = (() => {
    type TypeName = Transaction;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                transactionHash: FfiConverterTypeFieldElement.read(from), 
                senderAddress: FfiConverterTypeFieldElement.read(from), 
                calldata: FfiConverterArrayTypeFieldElement.read(from), 
                maxFee: FfiConverterTypeFieldElement.read(from), 
                signature: FfiConverterArrayTypeFieldElement.read(from), 
                nonce: FfiConverterTypeFieldElement.read(from), 
                blockNumber: FfiConverterUInt64.read(from), 
                transactionType: FfiConverterString.read(from), 
                blockTimestamp: FfiConverterUInt64.read(from), 
                calls: FfiConverterArrayTypeTransactionCall.read(from), 
                uniqueModels: FfiConverterArrayTypeFieldElement.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.transactionHash, into);
            FfiConverterTypeFieldElement.write(value.senderAddress, into);
            FfiConverterArrayTypeFieldElement.write(value.calldata, into);
            FfiConverterTypeFieldElement.write(value.maxFee, into);
            FfiConverterArrayTypeFieldElement.write(value.signature, into);
            FfiConverterTypeFieldElement.write(value.nonce, into);
            FfiConverterUInt64.write(value.blockNumber, into);
            FfiConverterString.write(value.transactionType, into);
            FfiConverterUInt64.write(value.blockTimestamp, into);
            FfiConverterArrayTypeTransactionCall.write(value.calls, into);
            FfiConverterArrayTypeFieldElement.write(value.uniqueModels, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.transactionHash) + 
            FfiConverterTypeFieldElement.allocationSize(value.senderAddress) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.calldata) + 
            FfiConverterTypeFieldElement.allocationSize(value.maxFee) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.signature) + 
            FfiConverterTypeFieldElement.allocationSize(value.nonce) + 
            FfiConverterUInt64.allocationSize(value.blockNumber) + 
            FfiConverterString.allocationSize(value.transactionType) + 
            FfiConverterUInt64.allocationSize(value.blockTimestamp) + 
            FfiConverterArrayTypeTransactionCall.allocationSize(value.calls) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.uniqueModels);
            
        }
    };
    return new FFIConverter();
})();


export type TransactionCall = {
    contractAddress: FieldElement,
    entrypoint: string,
    calldata: Array<FieldElement>,
    callType: CallType,
    callerAddress: FieldElement
}

/**
 * Generated factory for {@link TransactionCall} record objects.
 */
export const TransactionCall = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TransactionCall, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TransactionCall}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TransactionCall}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TransactionCall>,
    });
})();

const FfiConverterTypeTransactionCall = (() => {
    type TypeName = TransactionCall;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                contractAddress: FfiConverterTypeFieldElement.read(from), 
                entrypoint: FfiConverterString.read(from), 
                calldata: FfiConverterArrayTypeFieldElement.read(from), 
                callType: FfiConverterTypeCallType.read(from), 
                callerAddress: FfiConverterTypeFieldElement.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.contractAddress, into);
            FfiConverterString.write(value.entrypoint, into);
            FfiConverterArrayTypeFieldElement.write(value.calldata, into);
            FfiConverterTypeCallType.write(value.callType, into);
            FfiConverterTypeFieldElement.write(value.callerAddress, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.contractAddress) + 
            FfiConverterString.allocationSize(value.entrypoint) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.calldata) + 
            FfiConverterTypeCallType.allocationSize(value.callType) + 
            FfiConverterTypeFieldElement.allocationSize(value.callerAddress);
            
        }
    };
    return new FFIConverter();
})();


export type TransactionFilter = {
    transactionHashes: Array<FieldElement>,
    callerAddresses: Array<FieldElement>,
    contractAddresses: Array<FieldElement>,
    entrypoints: Array<string>,
    modelSelectors: Array<FieldElement>,
    fromBlock: /*u64*/bigint | undefined,
    toBlock: /*u64*/bigint | undefined
}

/**
 * Generated factory for {@link TransactionFilter} record objects.
 */
export const TransactionFilter = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TransactionFilter, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TransactionFilter}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TransactionFilter}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TransactionFilter>,
    });
})();

const FfiConverterTypeTransactionFilter = (() => {
    type TypeName = TransactionFilter;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                transactionHashes: FfiConverterArrayTypeFieldElement.read(from), 
                callerAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                contractAddresses: FfiConverterArrayTypeFieldElement.read(from), 
                entrypoints: FfiConverterArrayString.read(from), 
                modelSelectors: FfiConverterArrayTypeFieldElement.read(from), 
                fromBlock: FfiConverterOptionalUInt64.read(from), 
                toBlock: FfiConverterOptionalUInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayTypeFieldElement.write(value.transactionHashes, into);
            FfiConverterArrayTypeFieldElement.write(value.callerAddresses, into);
            FfiConverterArrayTypeFieldElement.write(value.contractAddresses, into);
            FfiConverterArrayString.write(value.entrypoints, into);
            FfiConverterArrayTypeFieldElement.write(value.modelSelectors, into);
            FfiConverterOptionalUInt64.write(value.fromBlock, into);
            FfiConverterOptionalUInt64.write(value.toBlock, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayTypeFieldElement.allocationSize(value.transactionHashes) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.callerAddresses) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.contractAddresses) + 
            FfiConverterArrayString.allocationSize(value.entrypoints) + 
            FfiConverterArrayTypeFieldElement.allocationSize(value.modelSelectors) + 
            FfiConverterOptionalUInt64.allocationSize(value.fromBlock) + 
            FfiConverterOptionalUInt64.allocationSize(value.toBlock);
            
        }
    };
    return new FFIConverter();
})();


export type TransactionQuery = {
    filter: TransactionFilter | undefined,
    pagination: Pagination
}

/**
 * Generated factory for {@link TransactionQuery} record objects.
 */
export const TransactionQuery = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TransactionQuery, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TransactionQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TransactionQuery}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TransactionQuery>,
    });
})();

const FfiConverterTypeTransactionQuery = (() => {
    type TypeName = TransactionQuery;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                filter: FfiConverterOptionalTypeTransactionFilter.read(from), 
                pagination: FfiConverterTypePagination.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalTypeTransactionFilter.write(value.filter, into);
            FfiConverterTypePagination.write(value.pagination, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalTypeTransactionFilter.allocationSize(value.filter) + 
            FfiConverterTypePagination.allocationSize(value.pagination);
            
        }
    };
    return new FFIConverter();
})();


export type World = {
    worldAddress: FieldElement,
    models: Array<Model>
}

/**
 * Generated factory for {@link World} record objects.
 */
export const World = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<World, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link World}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link World}, with defaults specified
         * in Rust, in the {@link dojo} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link dojo} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<World>,
    });
})();

const FfiConverterTypeWorld = (() => {
    type TypeName = World;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                worldAddress: FfiConverterTypeFieldElement.read(from), 
                models: FfiConverterArrayTypeModel.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeFieldElement.write(value.worldAddress, into);
            FfiConverterArrayTypeModel.write(value.models, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeFieldElement.allocationSize(value.worldAddress) + 
            FfiConverterArrayTypeModel.allocationSize(value.models);
            
        }
    };
    return new FFIConverter();
})();


const stringConverter = {
    stringToBytes: (s: string) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)),
    bytesToString: (ab: UniffiByteArray) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)),
    stringByteLength: (s: string) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);










/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type FieldElement = string;
// FfiConverter for FieldElement, a type alias for string.
const FfiConverterTypeFieldElement = FfiConverterString;


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type U256 = string;
// FfiConverter for U256, a type alias for string.
const FfiConverterTypeU256 = FfiConverterString;


export enum CallType {
    Execute,
    ExecuteFromOutside
}

const FfiConverterTypeCallType = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = CallType;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return CallType.Execute;
                case 2: return CallType.ExecuteFromOutside;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case CallType.Execute: return ordinalConverter.write(1, into);
                case CallType.ExecuteFromOutside: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





// Enum: Clause
export enum Clause_Tags {
    HashedKeys = "HashedKeys",
    Keys = "Keys",
    Member = "Member",
    Composite = "Composite"
}
export const Clause = (() => {
    

    type HashedKeys__interface = {
        tag: Clause_Tags.HashedKeys;
        inner: Readonly<{keys: Array<FieldElement>}>
    };

    
    class HashedKeys_ extends UniffiEnum implements HashedKeys__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Clause";
        readonly tag = Clause_Tags.HashedKeys;
        readonly inner: Readonly<{keys: Array<FieldElement>}>;
        constructor(inner: { keys: Array<FieldElement> }) {
            super("Clause", "HashedKeys");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { keys: Array<FieldElement> }): HashedKeys_ {
            return new HashedKeys_(inner);
        }

        static instanceOf(obj: any): obj is HashedKeys_ {
            return obj.tag === Clause_Tags.HashedKeys;
        }

        

    }
    

    type Keys__interface = {
        tag: Clause_Tags.Keys;
        inner: Readonly<{clause: KeysClause}>
    };

    
    class Keys_ extends UniffiEnum implements Keys__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Clause";
        readonly tag = Clause_Tags.Keys;
        readonly inner: Readonly<{clause: KeysClause}>;
        constructor(inner: { clause: KeysClause }) {
            super("Clause", "Keys");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { clause: KeysClause }): Keys_ {
            return new Keys_(inner);
        }

        static instanceOf(obj: any): obj is Keys_ {
            return obj.tag === Clause_Tags.Keys;
        }

        

    }
    

    type Member__interface = {
        tag: Clause_Tags.Member;
        inner: Readonly<{clause: MemberClause}>
    };

    
    class Member_ extends UniffiEnum implements Member__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Clause";
        readonly tag = Clause_Tags.Member;
        readonly inner: Readonly<{clause: MemberClause}>;
        constructor(inner: { clause: MemberClause }) {
            super("Clause", "Member");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { clause: MemberClause }): Member_ {
            return new Member_(inner);
        }

        static instanceOf(obj: any): obj is Member_ {
            return obj.tag === Clause_Tags.Member;
        }

        

    }
    

    type Composite__interface = {
        tag: Clause_Tags.Composite;
        inner: Readonly<{clause: CompositeClause}>
    };

    
    class Composite_ extends UniffiEnum implements Composite__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Clause";
        readonly tag = Clause_Tags.Composite;
        readonly inner: Readonly<{clause: CompositeClause}>;
        constructor(inner: { clause: CompositeClause }) {
            super("Clause", "Composite");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { clause: CompositeClause }): Composite_ {
            return new Composite_(inner);
        }

        static instanceOf(obj: any): obj is Composite_ {
            return obj.tag === Clause_Tags.Composite;
        }

        

    }

    function instanceOf(obj: any): obj is Clause {
        return obj[uniffiTypeNameSymbol] === "Clause";
    }

    return Object.freeze({
        instanceOf,
  HashedKeys: HashedKeys_, 
  Keys: Keys_, 
  Member: Member_, 
  Composite: Composite_
    });

})();



export type Clause = InstanceType<
    typeof Clause[keyof Omit<typeof Clause, 'instanceOf'>]
>;

// FfiConverter for enum Clause
const FfiConverterTypeClause = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = Clause;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new Clause.HashedKeys({keys: FfiConverterArrayTypeFieldElement.read(from) });
                case 2: return new Clause.Keys({clause: FfiConverterTypeKeysClause.read(from) });
                case 3: return new Clause.Member({clause: FfiConverterTypeMemberClause.read(from) });
                case 4: return new Clause.Composite({clause: FfiConverterTypeCompositeClause.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case Clause_Tags.HashedKeys: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeFieldElement.write(inner.keys, into);
                    return;
                }
                case Clause_Tags.Keys: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeKeysClause.write(inner.clause, into);
                    return;
                }
                case Clause_Tags.Member: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeMemberClause.write(inner.clause, into);
                    return;
                }
                case Clause_Tags.Composite: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeCompositeClause.write(inner.clause, into);
                    return;
                }
                default:
                    // Throwing from here means that Clause_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case Clause_Tags.HashedKeys: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeFieldElement.allocationSize(inner.keys);
                    return size;
                }
                case Clause_Tags.Keys: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeKeysClause.allocationSize(inner.clause);
                    return size;
                }
                case Clause_Tags.Member: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeMemberClause.allocationSize(inner.clause);
                    return size;
                }
                case Clause_Tags.Composite: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeCompositeClause.allocationSize(inner.clause);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



export enum ComparisonOperator {
    Eq,
    Neq,
    Gt,
    Gte,
    Lt,
    Lte,
    In,
    NotIn,
    Contains,
    ContainsAll,
    ContainsAny,
    ArrayLengthEq,
    ArrayLengthGt,
    ArrayLengthLt
}

const FfiConverterTypeComparisonOperator = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = ComparisonOperator;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return ComparisonOperator.Eq;
                case 2: return ComparisonOperator.Neq;
                case 3: return ComparisonOperator.Gt;
                case 4: return ComparisonOperator.Gte;
                case 5: return ComparisonOperator.Lt;
                case 6: return ComparisonOperator.Lte;
                case 7: return ComparisonOperator.In;
                case 8: return ComparisonOperator.NotIn;
                case 9: return ComparisonOperator.Contains;
                case 10: return ComparisonOperator.ContainsAll;
                case 11: return ComparisonOperator.ContainsAny;
                case 12: return ComparisonOperator.ArrayLengthEq;
                case 13: return ComparisonOperator.ArrayLengthGt;
                case 14: return ComparisonOperator.ArrayLengthLt;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case ComparisonOperator.Eq: return ordinalConverter.write(1, into);
                case ComparisonOperator.Neq: return ordinalConverter.write(2, into);
                case ComparisonOperator.Gt: return ordinalConverter.write(3, into);
                case ComparisonOperator.Gte: return ordinalConverter.write(4, into);
                case ComparisonOperator.Lt: return ordinalConverter.write(5, into);
                case ComparisonOperator.Lte: return ordinalConverter.write(6, into);
                case ComparisonOperator.In: return ordinalConverter.write(7, into);
                case ComparisonOperator.NotIn: return ordinalConverter.write(8, into);
                case ComparisonOperator.Contains: return ordinalConverter.write(9, into);
                case ComparisonOperator.ContainsAll: return ordinalConverter.write(10, into);
                case ComparisonOperator.ContainsAny: return ordinalConverter.write(11, into);
                case ComparisonOperator.ArrayLengthEq: return ordinalConverter.write(12, into);
                case ComparisonOperator.ArrayLengthGt: return ordinalConverter.write(13, into);
                case ComparisonOperator.ArrayLengthLt: return ordinalConverter.write(14, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





export enum ContractType {
    World,
    Erc20,
    Erc721,
    Erc1155,
    Udc,
    Other
}

const FfiConverterTypeContractType = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = ContractType;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return ContractType.World;
                case 2: return ContractType.Erc20;
                case 3: return ContractType.Erc721;
                case 4: return ContractType.Erc1155;
                case 5: return ContractType.Udc;
                case 6: return ContractType.Other;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case ContractType.World: return ordinalConverter.write(1, into);
                case ContractType.Erc20: return ordinalConverter.write(2, into);
                case ContractType.Erc721: return ordinalConverter.write(3, into);
                case ContractType.Erc1155: return ordinalConverter.write(4, into);
                case ContractType.Udc: return ordinalConverter.write(5, into);
                case ContractType.Other: return ordinalConverter.write(6, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();






// Flat error type: DojoError
export enum DojoError_Tags {
    ClientError = "ClientError",
    SerializationError = "SerializationError",
    NetworkError = "NetworkError",
    InvalidInput = "InvalidInput",
    ConnectionError = "ConnectionError",
    PublishError = "PublishError",
    QueryError = "QueryError",
    SubscriptionError = "SubscriptionError"
}
export const DojoError = (() => {
    class ClientError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 1;

        public readonly tag = DojoError_Tags.ClientError;

        constructor(message: string) {
            super("DojoError", "ClientError", message);
        }

        static instanceOf(e: any): e is ClientError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1
            );
        }
    }
    class SerializationError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 2;

        public readonly tag = DojoError_Tags.SerializationError;

        constructor(message: string) {
            super("DojoError", "SerializationError", message);
        }

        static instanceOf(e: any): e is SerializationError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2
            );
        }
    }
    class NetworkError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 3;

        public readonly tag = DojoError_Tags.NetworkError;

        constructor(message: string) {
            super("DojoError", "NetworkError", message);
        }

        static instanceOf(e: any): e is NetworkError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3
            );
        }
    }
    class InvalidInput extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 4;

        public readonly tag = DojoError_Tags.InvalidInput;

        constructor(message: string) {
            super("DojoError", "InvalidInput", message);
        }

        static instanceOf(e: any): e is InvalidInput {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4
            );
        }
    }
    class ConnectionError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 5;

        public readonly tag = DojoError_Tags.ConnectionError;

        constructor(message: string) {
            super("DojoError", "ConnectionError", message);
        }

        static instanceOf(e: any): e is ConnectionError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5
            );
        }
    }
    class PublishError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 6;

        public readonly tag = DojoError_Tags.PublishError;

        constructor(message: string) {
            super("DojoError", "PublishError", message);
        }

        static instanceOf(e: any): e is PublishError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6
            );
        }
    }
    class QueryError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 7;

        public readonly tag = DojoError_Tags.QueryError;

        constructor(message: string) {
            super("DojoError", "QueryError", message);
        }

        static instanceOf(e: any): e is QueryError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7
            );
        }
    }
    class SubscriptionError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "DojoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 8;

        public readonly tag = DojoError_Tags.SubscriptionError;

        constructor(message: string) {
            super("DojoError", "SubscriptionError", message);
        }

        static instanceOf(e: any): e is SubscriptionError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8
            );
        }
    }

    // Utility function which does not rely on instanceof.
    function instanceOf(e: any): e is DojoError {
        return (e as any)[uniffiTypeNameSymbol] === "DojoError";
    }
    return {
        ClientError,
        SerializationError,
        NetworkError,
        InvalidInput,
        ConnectionError,
        PublishError,
        QueryError,
        SubscriptionError,
        instanceOf,
    };
})();

// Union type for DojoError error type.


export type DojoError = InstanceType<
    typeof DojoError[keyof Omit<typeof DojoError, 'instanceOf'>]
>;

const FfiConverterTypeDojoError = (() => {
    const intConverter = FfiConverterInt32;
    type TypeName = DojoError;
    class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (intConverter.read(from)) {
                case 1: return new DojoError.ClientError(FfiConverterString.read(from)
                );
            
                case 2: return new DojoError.SerializationError(FfiConverterString.read(from)
                );
            
                case 3: return new DojoError.NetworkError(FfiConverterString.read(from)
                );
            
                case 4: return new DojoError.InvalidInput(FfiConverterString.read(from)
                );
            
                case 5: return new DojoError.ConnectionError(FfiConverterString.read(from)
                );
            
                case 6: return new DojoError.PublishError(FfiConverterString.read(from)
                );
            
                case 7: return new DojoError.QueryError(FfiConverterString.read(from)
                );
            
                case 8: return new DojoError.SubscriptionError(FfiConverterString.read(from)
                );
            
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            const obj = value as any;
            const index = obj[variantOrdinalSymbol] as number;
            intConverter.write(index, into);
        }
        allocationSize(value: TypeName): number {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();


export enum LogicalOperator {
    And,
    Or
}

const FfiConverterTypeLogicalOperator = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = LogicalOperator;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return LogicalOperator.And;
                case 2: return LogicalOperator.Or;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case LogicalOperator.And: return ordinalConverter.write(1, into);
                case LogicalOperator.Or: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





// Enum: MemberValue
export enum MemberValue_Tags {
    Primitive = "Primitive",
    String = "String",
    List = "List"
}
export const MemberValue = (() => {
    

    type Primitive__interface = {
        tag: MemberValue_Tags.Primitive;
        inner: Readonly<{value: Primitive}>
    };

    
    class Primitive_ extends UniffiEnum implements Primitive__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "MemberValue";
        readonly tag = MemberValue_Tags.Primitive;
        readonly inner: Readonly<{value: Primitive}>;
        constructor(inner: { value: Primitive }) {
            super("MemberValue", "Primitive");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Primitive }): Primitive_ {
            return new Primitive_(inner);
        }

        static instanceOf(obj: any): obj is Primitive_ {
            return obj.tag === MemberValue_Tags.Primitive;
        }

        

    }
    

    type String__interface = {
        tag: MemberValue_Tags.String;
        inner: Readonly<{value: string}>
    };

    
    class String_ extends UniffiEnum implements String__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "MemberValue";
        readonly tag = MemberValue_Tags.String;
        readonly inner: Readonly<{value: string}>;
        constructor(inner: { value: string }) {
            super("MemberValue", "String");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: string }): String_ {
            return new String_(inner);
        }

        static instanceOf(obj: any): obj is String_ {
            return obj.tag === MemberValue_Tags.String;
        }

        

    }
    

    type List__interface = {
        tag: MemberValue_Tags.List;
        inner: Readonly<{values: Array<MemberValue>}>
    };

    
    class List_ extends UniffiEnum implements List__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "MemberValue";
        readonly tag = MemberValue_Tags.List;
        readonly inner: Readonly<{values: Array<MemberValue>}>;
        constructor(inner: { values: Array<MemberValue> }) {
            super("MemberValue", "List");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { values: Array<MemberValue> }): List_ {
            return new List_(inner);
        }

        static instanceOf(obj: any): obj is List_ {
            return obj.tag === MemberValue_Tags.List;
        }

        

    }

    function instanceOf(obj: any): obj is MemberValue {
        return obj[uniffiTypeNameSymbol] === "MemberValue";
    }

    return Object.freeze({
        instanceOf,
  Primitive: Primitive_, 
  String: String_, 
  List: List_
    });

})();



export type MemberValue = InstanceType<
    typeof MemberValue[keyof Omit<typeof MemberValue, 'instanceOf'>]
>;

// FfiConverter for enum MemberValue
const FfiConverterTypeMemberValue = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = MemberValue;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new MemberValue.Primitive({value: FfiConverterTypePrimitive.read(from) });
                case 2: return new MemberValue.String({value: FfiConverterString.read(from) });
                case 3: return new MemberValue.List({values: FfiConverterArrayTypeMemberValue.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case MemberValue_Tags.Primitive: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypePrimitive.write(inner.value, into);
                    return;
                }
                case MemberValue_Tags.String: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                case MemberValue_Tags.List: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeMemberValue.write(inner.values, into);
                    return;
                }
                default:
                    // Throwing from here means that MemberValue_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case MemberValue_Tags.Primitive: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypePrimitive.allocationSize(inner.value);
                    return size;
                }
                case MemberValue_Tags.String: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                case MemberValue_Tags.List: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterArrayTypeMemberValue.allocationSize(inner.values);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



export enum OrderDirection {
    Asc,
    Desc
}

const FfiConverterTypeOrderDirection = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = OrderDirection;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return OrderDirection.Asc;
                case 2: return OrderDirection.Desc;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case OrderDirection.Asc: return ordinalConverter.write(1, into);
                case OrderDirection.Desc: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





export enum PaginationDirection {
    Forward,
    Backward
}

const FfiConverterTypePaginationDirection = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = PaginationDirection;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return PaginationDirection.Forward;
                case 2: return PaginationDirection.Backward;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case PaginationDirection.Forward: return ordinalConverter.write(1, into);
                case PaginationDirection.Backward: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





export enum PatternMatching {
    FixedLen,
    VariableLen
}

const FfiConverterTypePatternMatching = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = PatternMatching;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return PatternMatching.FixedLen;
                case 2: return PatternMatching.VariableLen;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case PatternMatching.FixedLen: return ordinalConverter.write(1, into);
                case PatternMatching.VariableLen: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





// Enum: Primitive
export enum Primitive_Tags {
    I8 = "I8",
    I16 = "I16",
    I32 = "I32",
    I64 = "I64",
    I128 = "I128",
    U8 = "U8",
    U16 = "U16",
    U32 = "U32",
    U64 = "U64",
    U128 = "U128",
    U256 = "U256",
    Bool = "Bool",
    Felt252 = "Felt252",
    ClassHash = "ClassHash",
    ContractAddress = "ContractAddress",
    EthAddress = "EthAddress"
}
export const Primitive = (() => {
    

    type I8__interface = {
        tag: Primitive_Tags.I8;
        inner: Readonly<{value: /*i8*/number}>
    };

    
    class I8_ extends UniffiEnum implements I8__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.I8;
        readonly inner: Readonly<{value: /*i8*/number}>;
        constructor(inner: { value: /*i8*/number }) {
            super("Primitive", "I8");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*i8*/number }): I8_ {
            return new I8_(inner);
        }

        static instanceOf(obj: any): obj is I8_ {
            return obj.tag === Primitive_Tags.I8;
        }

        

    }
    

    type I16__interface = {
        tag: Primitive_Tags.I16;
        inner: Readonly<{value: /*i16*/number}>
    };

    
    class I16_ extends UniffiEnum implements I16__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.I16;
        readonly inner: Readonly<{value: /*i16*/number}>;
        constructor(inner: { value: /*i16*/number }) {
            super("Primitive", "I16");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*i16*/number }): I16_ {
            return new I16_(inner);
        }

        static instanceOf(obj: any): obj is I16_ {
            return obj.tag === Primitive_Tags.I16;
        }

        

    }
    

    type I32__interface = {
        tag: Primitive_Tags.I32;
        inner: Readonly<{value: /*i32*/number}>
    };

    
    class I32_ extends UniffiEnum implements I32__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.I32;
        readonly inner: Readonly<{value: /*i32*/number}>;
        constructor(inner: { value: /*i32*/number }) {
            super("Primitive", "I32");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*i32*/number }): I32_ {
            return new I32_(inner);
        }

        static instanceOf(obj: any): obj is I32_ {
            return obj.tag === Primitive_Tags.I32;
        }

        

    }
    

    type I64__interface = {
        tag: Primitive_Tags.I64;
        inner: Readonly<{value: /*i64*/bigint}>
    };

    
    class I64_ extends UniffiEnum implements I64__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.I64;
        readonly inner: Readonly<{value: /*i64*/bigint}>;
        constructor(inner: { value: /*i64*/bigint }) {
            super("Primitive", "I64");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*i64*/bigint }): I64_ {
            return new I64_(inner);
        }

        static instanceOf(obj: any): obj is I64_ {
            return obj.tag === Primitive_Tags.I64;
        }

        

    }
    

    type I128__interface = {
        tag: Primitive_Tags.I128;
        inner: Readonly<{value: Array</*u8*/number>}>
    };

    
    class I128_ extends UniffiEnum implements I128__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.I128;
        readonly inner: Readonly<{value: Array</*u8*/number>}>;
        constructor(inner: { value: Array</*u8*/number> }) {
            super("Primitive", "I128");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Array</*u8*/number> }): I128_ {
            return new I128_(inner);
        }

        static instanceOf(obj: any): obj is I128_ {
            return obj.tag === Primitive_Tags.I128;
        }

        

    }
    

    type U8__interface = {
        tag: Primitive_Tags.U8;
        inner: Readonly<{value: /*u8*/number}>
    };

    
    class U8_ extends UniffiEnum implements U8__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.U8;
        readonly inner: Readonly<{value: /*u8*/number}>;
        constructor(inner: { value: /*u8*/number }) {
            super("Primitive", "U8");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*u8*/number }): U8_ {
            return new U8_(inner);
        }

        static instanceOf(obj: any): obj is U8_ {
            return obj.tag === Primitive_Tags.U8;
        }

        

    }
    

    type U16__interface = {
        tag: Primitive_Tags.U16;
        inner: Readonly<{value: /*u16*/number}>
    };

    
    class U16_ extends UniffiEnum implements U16__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.U16;
        readonly inner: Readonly<{value: /*u16*/number}>;
        constructor(inner: { value: /*u16*/number }) {
            super("Primitive", "U16");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*u16*/number }): U16_ {
            return new U16_(inner);
        }

        static instanceOf(obj: any): obj is U16_ {
            return obj.tag === Primitive_Tags.U16;
        }

        

    }
    

    type U32__interface = {
        tag: Primitive_Tags.U32;
        inner: Readonly<{value: /*u32*/number}>
    };

    
    class U32_ extends UniffiEnum implements U32__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.U32;
        readonly inner: Readonly<{value: /*u32*/number}>;
        constructor(inner: { value: /*u32*/number }) {
            super("Primitive", "U32");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*u32*/number }): U32_ {
            return new U32_(inner);
        }

        static instanceOf(obj: any): obj is U32_ {
            return obj.tag === Primitive_Tags.U32;
        }

        

    }
    

    type U64__interface = {
        tag: Primitive_Tags.U64;
        inner: Readonly<{value: /*u64*/bigint}>
    };

    
    class U64_ extends UniffiEnum implements U64__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.U64;
        readonly inner: Readonly<{value: /*u64*/bigint}>;
        constructor(inner: { value: /*u64*/bigint }) {
            super("Primitive", "U64");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*u64*/bigint }): U64_ {
            return new U64_(inner);
        }

        static instanceOf(obj: any): obj is U64_ {
            return obj.tag === Primitive_Tags.U64;
        }

        

    }
    

    type U128__interface = {
        tag: Primitive_Tags.U128;
        inner: Readonly<{value: Array</*u8*/number>}>
    };

    
    class U128_ extends UniffiEnum implements U128__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.U128;
        readonly inner: Readonly<{value: Array</*u8*/number>}>;
        constructor(inner: { value: Array</*u8*/number> }) {
            super("Primitive", "U128");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Array</*u8*/number> }): U128_ {
            return new U128_(inner);
        }

        static instanceOf(obj: any): obj is U128_ {
            return obj.tag === Primitive_Tags.U128;
        }

        

    }
    

    type U256__interface = {
        tag: Primitive_Tags.U256;
        inner: Readonly<{value: U256}>
    };

    
    class U256_ extends UniffiEnum implements U256__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.U256;
        readonly inner: Readonly<{value: U256}>;
        constructor(inner: { value: U256 }) {
            super("Primitive", "U256");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: U256 }): U256_ {
            return new U256_(inner);
        }

        static instanceOf(obj: any): obj is U256_ {
            return obj.tag === Primitive_Tags.U256;
        }

        

    }
    

    type Bool__interface = {
        tag: Primitive_Tags.Bool;
        inner: Readonly<{value: boolean}>
    };

    
    class Bool_ extends UniffiEnum implements Bool__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.Bool;
        readonly inner: Readonly<{value: boolean}>;
        constructor(inner: { value: boolean }) {
            super("Primitive", "Bool");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: boolean }): Bool_ {
            return new Bool_(inner);
        }

        static instanceOf(obj: any): obj is Bool_ {
            return obj.tag === Primitive_Tags.Bool;
        }

        

    }
    

    type Felt252__interface = {
        tag: Primitive_Tags.Felt252;
        inner: Readonly<{value: FieldElement}>
    };

    
    class Felt252_ extends UniffiEnum implements Felt252__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.Felt252;
        readonly inner: Readonly<{value: FieldElement}>;
        constructor(inner: { value: FieldElement }) {
            super("Primitive", "Felt252");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: FieldElement }): Felt252_ {
            return new Felt252_(inner);
        }

        static instanceOf(obj: any): obj is Felt252_ {
            return obj.tag === Primitive_Tags.Felt252;
        }

        

    }
    

    type ClassHash__interface = {
        tag: Primitive_Tags.ClassHash;
        inner: Readonly<{value: FieldElement}>
    };

    
    class ClassHash_ extends UniffiEnum implements ClassHash__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.ClassHash;
        readonly inner: Readonly<{value: FieldElement}>;
        constructor(inner: { value: FieldElement }) {
            super("Primitive", "ClassHash");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: FieldElement }): ClassHash_ {
            return new ClassHash_(inner);
        }

        static instanceOf(obj: any): obj is ClassHash_ {
            return obj.tag === Primitive_Tags.ClassHash;
        }

        

    }
    

    type ContractAddress__interface = {
        tag: Primitive_Tags.ContractAddress;
        inner: Readonly<{value: FieldElement}>
    };

    
    class ContractAddress_ extends UniffiEnum implements ContractAddress__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.ContractAddress;
        readonly inner: Readonly<{value: FieldElement}>;
        constructor(inner: { value: FieldElement }) {
            super("Primitive", "ContractAddress");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: FieldElement }): ContractAddress_ {
            return new ContractAddress_(inner);
        }

        static instanceOf(obj: any): obj is ContractAddress_ {
            return obj.tag === Primitive_Tags.ContractAddress;
        }

        

    }
    

    type EthAddress__interface = {
        tag: Primitive_Tags.EthAddress;
        inner: Readonly<{value: FieldElement}>
    };

    
    class EthAddress_ extends UniffiEnum implements EthAddress__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Primitive";
        readonly tag = Primitive_Tags.EthAddress;
        readonly inner: Readonly<{value: FieldElement}>;
        constructor(inner: { value: FieldElement }) {
            super("Primitive", "EthAddress");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: FieldElement }): EthAddress_ {
            return new EthAddress_(inner);
        }

        static instanceOf(obj: any): obj is EthAddress_ {
            return obj.tag === Primitive_Tags.EthAddress;
        }

        

    }

    function instanceOf(obj: any): obj is Primitive {
        return obj[uniffiTypeNameSymbol] === "Primitive";
    }

    return Object.freeze({
        instanceOf,
  I8: I8_, 
  I16: I16_, 
  I32: I32_, 
  I64: I64_, 
  I128: I128_, 
  U8: U8_, 
  U16: U16_, 
  U32: U32_, 
  U64: U64_, 
  U128: U128_, 
  U256: U256_, 
  Bool: Bool_, 
  Felt252: Felt252_, 
  ClassHash: ClassHash_, 
  ContractAddress: ContractAddress_, 
  EthAddress: EthAddress_
    });

})();



export type Primitive = InstanceType<
    typeof Primitive[keyof Omit<typeof Primitive, 'instanceOf'>]
>;

// FfiConverter for enum Primitive
const FfiConverterTypePrimitive = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = Primitive;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new Primitive.I8({value: FfiConverterInt8.read(from) });
                case 2: return new Primitive.I16({value: FfiConverterInt16.read(from) });
                case 3: return new Primitive.I32({value: FfiConverterInt32.read(from) });
                case 4: return new Primitive.I64({value: FfiConverterInt64.read(from) });
                case 5: return new Primitive.I128({value: FfiConverterArrayUInt8.read(from) });
                case 6: return new Primitive.U8({value: FfiConverterUInt8.read(from) });
                case 7: return new Primitive.U16({value: FfiConverterUInt16.read(from) });
                case 8: return new Primitive.U32({value: FfiConverterUInt32.read(from) });
                case 9: return new Primitive.U64({value: FfiConverterUInt64.read(from) });
                case 10: return new Primitive.U128({value: FfiConverterArrayUInt8.read(from) });
                case 11: return new Primitive.U256({value: FfiConverterTypeU256.read(from) });
                case 12: return new Primitive.Bool({value: FfiConverterBool.read(from) });
                case 13: return new Primitive.Felt252({value: FfiConverterTypeFieldElement.read(from) });
                case 14: return new Primitive.ClassHash({value: FfiConverterTypeFieldElement.read(from) });
                case 15: return new Primitive.ContractAddress({value: FfiConverterTypeFieldElement.read(from) });
                case 16: return new Primitive.EthAddress({value: FfiConverterTypeFieldElement.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case Primitive_Tags.I8: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterInt8.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.I16: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterInt16.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.I32: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterInt32.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.I64: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterInt64.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.I128: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterArrayUInt8.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.U8: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterUInt8.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.U16: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterUInt16.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.U32: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.U64: {
                    ordinalConverter.write(9, into);
                    const inner = value.inner;
                    FfiConverterUInt64.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.U128: {
                    ordinalConverter.write(10, into);
                    const inner = value.inner;
                    FfiConverterArrayUInt8.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.U256: {
                    ordinalConverter.write(11, into);
                    const inner = value.inner;
                    FfiConverterTypeU256.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.Bool: {
                    ordinalConverter.write(12, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.Felt252: {
                    ordinalConverter.write(13, into);
                    const inner = value.inner;
                    FfiConverterTypeFieldElement.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.ClassHash: {
                    ordinalConverter.write(14, into);
                    const inner = value.inner;
                    FfiConverterTypeFieldElement.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.ContractAddress: {
                    ordinalConverter.write(15, into);
                    const inner = value.inner;
                    FfiConverterTypeFieldElement.write(inner.value, into);
                    return;
                }
                case Primitive_Tags.EthAddress: {
                    ordinalConverter.write(16, into);
                    const inner = value.inner;
                    FfiConverterTypeFieldElement.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that Primitive_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case Primitive_Tags.I8: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterInt8.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.I16: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterInt16.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.I32: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterInt32.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.I64: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterInt64.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.I128: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterArrayUInt8.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.U8: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterUInt8.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.U16: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterUInt16.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.U32: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterUInt32.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.U64: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(9);
                    size += FfiConverterUInt64.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.U128: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(10);
                    size += FfiConverterArrayUInt8.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.U256: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(11);
                    size += FfiConverterTypeU256.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.Bool: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(12);
                    size += FfiConverterBool.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.Felt252: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(13);
                    size += FfiConverterTypeFieldElement.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.ClassHash: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(14);
                    size += FfiConverterTypeFieldElement.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.ContractAddress: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(15);
                    size += FfiConverterTypeFieldElement.allocationSize(inner.value);
                    return size;
                }
                case Primitive_Tags.EthAddress: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(16);
                    size += FfiConverterTypeFieldElement.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



// Enum: SqlValue
export enum SqlValue_Tags {
    Text = "Text",
    Integer = "Integer",
    Real = "Real",
    Blob = "Blob",
    Null = "Null"
}
export const SqlValue = (() => {
    

    type Text__interface = {
        tag: SqlValue_Tags.Text;
        inner: Readonly<{value: string}>
    };

    
    class Text_ extends UniffiEnum implements Text__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "SqlValue";
        readonly tag = SqlValue_Tags.Text;
        readonly inner: Readonly<{value: string}>;
        constructor(inner: { value: string }) {
            super("SqlValue", "Text");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: string }): Text_ {
            return new Text_(inner);
        }

        static instanceOf(obj: any): obj is Text_ {
            return obj.tag === SqlValue_Tags.Text;
        }

        

    }
    

    type Integer__interface = {
        tag: SqlValue_Tags.Integer;
        inner: Readonly<{value: /*i64*/bigint}>
    };

    
    class Integer_ extends UniffiEnum implements Integer__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "SqlValue";
        readonly tag = SqlValue_Tags.Integer;
        readonly inner: Readonly<{value: /*i64*/bigint}>;
        constructor(inner: { value: /*i64*/bigint }) {
            super("SqlValue", "Integer");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*i64*/bigint }): Integer_ {
            return new Integer_(inner);
        }

        static instanceOf(obj: any): obj is Integer_ {
            return obj.tag === SqlValue_Tags.Integer;
        }

        

    }
    

    type Real__interface = {
        tag: SqlValue_Tags.Real;
        inner: Readonly<{value: /*f64*/number}>
    };

    
    class Real_ extends UniffiEnum implements Real__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "SqlValue";
        readonly tag = SqlValue_Tags.Real;
        readonly inner: Readonly<{value: /*f64*/number}>;
        constructor(inner: { value: /*f64*/number }) {
            super("SqlValue", "Real");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*f64*/number }): Real_ {
            return new Real_(inner);
        }

        static instanceOf(obj: any): obj is Real_ {
            return obj.tag === SqlValue_Tags.Real;
        }

        

    }
    

    type Blob__interface = {
        tag: SqlValue_Tags.Blob;
        inner: Readonly<{value: Array</*u8*/number>}>
    };

    
    class Blob_ extends UniffiEnum implements Blob__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "SqlValue";
        readonly tag = SqlValue_Tags.Blob;
        readonly inner: Readonly<{value: Array</*u8*/number>}>;
        constructor(inner: { value: Array</*u8*/number> }) {
            super("SqlValue", "Blob");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Array</*u8*/number> }): Blob_ {
            return new Blob_(inner);
        }

        static instanceOf(obj: any): obj is Blob_ {
            return obj.tag === SqlValue_Tags.Blob;
        }

        

    }
    

    type Null__interface = {
        tag: SqlValue_Tags.Null
    };

    
    class Null_ extends UniffiEnum implements Null__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "SqlValue";
        readonly tag = SqlValue_Tags.Null;
        constructor() {
            super("SqlValue", "Null");
        }

        static new(): Null_ {
            return new Null_();
        }

        static instanceOf(obj: any): obj is Null_ {
            return obj.tag === SqlValue_Tags.Null;
        }

        

    }

    function instanceOf(obj: any): obj is SqlValue {
        return obj[uniffiTypeNameSymbol] === "SqlValue";
    }

    return Object.freeze({
        instanceOf,
  Text: Text_, 
  Integer: Integer_, 
  Real: Real_, 
  Blob: Blob_, 
  Null: Null_
    });

})();



export type SqlValue = InstanceType<
    typeof SqlValue[keyof Omit<typeof SqlValue, 'instanceOf'>]
>;

// FfiConverter for enum SqlValue
const FfiConverterTypeSqlValue = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = SqlValue;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new SqlValue.Text({value: FfiConverterString.read(from) });
                case 2: return new SqlValue.Integer({value: FfiConverterInt64.read(from) });
                case 3: return new SqlValue.Real({value: FfiConverterFloat64.read(from) });
                case 4: return new SqlValue.Blob({value: FfiConverterArrayUInt8.read(from) });
                case 5: return new SqlValue.Null();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case SqlValue_Tags.Text: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                case SqlValue_Tags.Integer: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterInt64.write(inner.value, into);
                    return;
                }
                case SqlValue_Tags.Real: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterFloat64.write(inner.value, into);
                    return;
                }
                case SqlValue_Tags.Blob: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterArrayUInt8.write(inner.value, into);
                    return;
                }
                case SqlValue_Tags.Null: {
                    ordinalConverter.write(5, into);
                    return;
                }
                default:
                    // Throwing from here means that SqlValue_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case SqlValue_Tags.Text: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                case SqlValue_Tags.Integer: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterInt64.allocationSize(inner.value);
                    return size;
                }
                case SqlValue_Tags.Real: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterFloat64.allocationSize(inner.value);
                    return size;
                }
                case SqlValue_Tags.Blob: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterArrayUInt8.allocationSize(inner.value);
                    return size;
                }
                case SqlValue_Tags.Null: {
                    return ordinalConverter.allocationSize(5);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



// Enum: Ty
export enum Ty_Tags {
    Primitive = "Primitive",
    Struct = "Struct",
    Enum = "Enum",
    Tuple = "Tuple",
    Array = "Array",
    FixedSizeArray = "FixedSizeArray",
    ByteArray = "ByteArray"
}
export const Ty = (() => {
    

    type Primitive__interface = {
        tag: Ty_Tags.Primitive;
        inner: Readonly<{value: Primitive}>
    };

    
    class Primitive_ extends UniffiEnum implements Primitive__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.Primitive;
        readonly inner: Readonly<{value: Primitive}>;
        constructor(inner: { value: Primitive }) {
            super("Ty", "Primitive");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Primitive }): Primitive_ {
            return new Primitive_(inner);
        }

        static instanceOf(obj: any): obj is Primitive_ {
            return obj.tag === Ty_Tags.Primitive;
        }

        

    }
    

    type Struct__interface = {
        tag: Ty_Tags.Struct;
        inner: Readonly<{value: Struct}>
    };

    
    class Struct_ extends UniffiEnum implements Struct__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.Struct;
        readonly inner: Readonly<{value: Struct}>;
        constructor(inner: { value: Struct }) {
            super("Ty", "Struct");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Struct }): Struct_ {
            return new Struct_(inner);
        }

        static instanceOf(obj: any): obj is Struct_ {
            return obj.tag === Ty_Tags.Struct;
        }

        

    }
    

    type Enum__interface = {
        tag: Ty_Tags.Enum;
        inner: Readonly<{value: EnumType}>
    };

    
    class Enum_ extends UniffiEnum implements Enum__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.Enum;
        readonly inner: Readonly<{value: EnumType}>;
        constructor(inner: { value: EnumType }) {
            super("Ty", "Enum");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: EnumType }): Enum_ {
            return new Enum_(inner);
        }

        static instanceOf(obj: any): obj is Enum_ {
            return obj.tag === Ty_Tags.Enum;
        }

        

    }
    

    type Tuple__interface = {
        tag: Ty_Tags.Tuple;
        inner: Readonly<{values: Array<Ty>}>
    };

    
    class Tuple_ extends UniffiEnum implements Tuple__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.Tuple;
        readonly inner: Readonly<{values: Array<Ty>}>;
        constructor(inner: { values: Array<Ty> }) {
            super("Ty", "Tuple");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { values: Array<Ty> }): Tuple_ {
            return new Tuple_(inner);
        }

        static instanceOf(obj: any): obj is Tuple_ {
            return obj.tag === Ty_Tags.Tuple;
        }

        

    }
    

    type Array__interface = {
        tag: Ty_Tags.Array;
        inner: Readonly<{values: Array<Ty>}>
    };

    
    class Array_ extends UniffiEnum implements Array__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.Array;
        readonly inner: Readonly<{values: Array<Ty>}>;
        constructor(inner: { values: Array<Ty> }) {
            super("Ty", "Array");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { values: Array<Ty> }): Array_ {
            return new Array_(inner);
        }

        static instanceOf(obj: any): obj is Array_ {
            return obj.tag === Ty_Tags.Array;
        }

        

    }
    

    type FixedSizeArray__interface = {
        tag: Ty_Tags.FixedSizeArray;
        inner: Readonly<{value: FixedSizeArray}>
    };

    
    class FixedSizeArray_ extends UniffiEnum implements FixedSizeArray__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.FixedSizeArray;
        readonly inner: Readonly<{value: FixedSizeArray}>;
        constructor(inner: { value: FixedSizeArray }) {
            super("Ty", "FixedSizeArray");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: FixedSizeArray }): FixedSizeArray_ {
            return new FixedSizeArray_(inner);
        }

        static instanceOf(obj: any): obj is FixedSizeArray_ {
            return obj.tag === Ty_Tags.FixedSizeArray;
        }

        

    }
    

    type ByteArray__interface = {
        tag: Ty_Tags.ByteArray;
        inner: Readonly<{value: string}>
    };

    
    class ByteArray_ extends UniffiEnum implements ByteArray__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "Ty";
        readonly tag = Ty_Tags.ByteArray;
        readonly inner: Readonly<{value: string}>;
        constructor(inner: { value: string }) {
            super("Ty", "ByteArray");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: string }): ByteArray_ {
            return new ByteArray_(inner);
        }

        static instanceOf(obj: any): obj is ByteArray_ {
            return obj.tag === Ty_Tags.ByteArray;
        }

        

    }

    function instanceOf(obj: any): obj is Ty {
        return obj[uniffiTypeNameSymbol] === "Ty";
    }

    return Object.freeze({
        instanceOf,
  Primitive: Primitive_, 
  Struct: Struct_, 
  Enum: Enum_, 
  Tuple: Tuple_, 
  Array: Array_, 
  FixedSizeArray: FixedSizeArray_, 
  ByteArray: ByteArray_
    });

})();



export type Ty = InstanceType<
    typeof Ty[keyof Omit<typeof Ty, 'instanceOf'>]
>;

// FfiConverter for enum Ty
const FfiConverterTypeTy = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = Ty;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new Ty.Primitive({value: FfiConverterTypePrimitive.read(from) });
                case 2: return new Ty.Struct({value: FfiConverterTypeStruct.read(from) });
                case 3: return new Ty.Enum({value: FfiConverterTypeEnumType.read(from) });
                case 4: return new Ty.Tuple({values: FfiConverterArrayTypeTy.read(from) });
                case 5: return new Ty.Array({values: FfiConverterArrayTypeTy.read(from) });
                case 6: return new Ty.FixedSizeArray({value: FfiConverterTypeFixedSizeArray.read(from) });
                case 7: return new Ty.ByteArray({value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case Ty_Tags.Primitive: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypePrimitive.write(inner.value, into);
                    return;
                }
                case Ty_Tags.Struct: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeStruct.write(inner.value, into);
                    return;
                }
                case Ty_Tags.Enum: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeEnumType.write(inner.value, into);
                    return;
                }
                case Ty_Tags.Tuple: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeTy.write(inner.values, into);
                    return;
                }
                case Ty_Tags.Array: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeTy.write(inner.values, into);
                    return;
                }
                case Ty_Tags.FixedSizeArray: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterTypeFixedSizeArray.write(inner.value, into);
                    return;
                }
                case Ty_Tags.ByteArray: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that Ty_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case Ty_Tags.Primitive: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypePrimitive.allocationSize(inner.value);
                    return size;
                }
                case Ty_Tags.Struct: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeStruct.allocationSize(inner.value);
                    return size;
                }
                case Ty_Tags.Enum: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeEnumType.allocationSize(inner.value);
                    return size;
                }
                case Ty_Tags.Tuple: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterArrayTypeTy.allocationSize(inner.values);
                    return size;
                }
                case Ty_Tags.Array: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterArrayTypeTy.allocationSize(inner.values);
                    return size;
                }
                case Ty_Tags.FixedSizeArray: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterTypeFixedSizeArray.allocationSize(inner.value);
                    return size;
                }
                case Ty_Tags.ByteArray: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



// Enum: ValueType
export enum ValueType_Tags {
    String = "String",
    Int = "Int",
    UInt = "UInt",
    Bool = "Bool",
    Bytes = "Bytes"
}
export const ValueType = (() => {
    

    type String__interface = {
        tag: ValueType_Tags.String;
        inner: Readonly<{value: string}>
    };

    
    class String_ extends UniffiEnum implements String__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ValueType";
        readonly tag = ValueType_Tags.String;
        readonly inner: Readonly<{value: string}>;
        constructor(inner: { value: string }) {
            super("ValueType", "String");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: string }): String_ {
            return new String_(inner);
        }

        static instanceOf(obj: any): obj is String_ {
            return obj.tag === ValueType_Tags.String;
        }

        

    }
    

    type Int__interface = {
        tag: ValueType_Tags.Int;
        inner: Readonly<{value: /*i64*/bigint}>
    };

    
    class Int_ extends UniffiEnum implements Int__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ValueType";
        readonly tag = ValueType_Tags.Int;
        readonly inner: Readonly<{value: /*i64*/bigint}>;
        constructor(inner: { value: /*i64*/bigint }) {
            super("ValueType", "Int");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*i64*/bigint }): Int_ {
            return new Int_(inner);
        }

        static instanceOf(obj: any): obj is Int_ {
            return obj.tag === ValueType_Tags.Int;
        }

        

    }
    

    type UInt__interface = {
        tag: ValueType_Tags.UInt;
        inner: Readonly<{value: /*u64*/bigint}>
    };

    
    class UInt_ extends UniffiEnum implements UInt__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ValueType";
        readonly tag = ValueType_Tags.UInt;
        readonly inner: Readonly<{value: /*u64*/bigint}>;
        constructor(inner: { value: /*u64*/bigint }) {
            super("ValueType", "UInt");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: /*u64*/bigint }): UInt_ {
            return new UInt_(inner);
        }

        static instanceOf(obj: any): obj is UInt_ {
            return obj.tag === ValueType_Tags.UInt;
        }

        

    }
    

    type Bool__interface = {
        tag: ValueType_Tags.Bool;
        inner: Readonly<{value: boolean}>
    };

    
    class Bool_ extends UniffiEnum implements Bool__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ValueType";
        readonly tag = ValueType_Tags.Bool;
        readonly inner: Readonly<{value: boolean}>;
        constructor(inner: { value: boolean }) {
            super("ValueType", "Bool");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: boolean }): Bool_ {
            return new Bool_(inner);
        }

        static instanceOf(obj: any): obj is Bool_ {
            return obj.tag === ValueType_Tags.Bool;
        }

        

    }
    

    type Bytes__interface = {
        tag: ValueType_Tags.Bytes;
        inner: Readonly<{value: Array</*u8*/number>}>
    };

    
    class Bytes_ extends UniffiEnum implements Bytes__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ValueType";
        readonly tag = ValueType_Tags.Bytes;
        readonly inner: Readonly<{value: Array</*u8*/number>}>;
        constructor(inner: { value: Array</*u8*/number> }) {
            super("ValueType", "Bytes");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { value: Array</*u8*/number> }): Bytes_ {
            return new Bytes_(inner);
        }

        static instanceOf(obj: any): obj is Bytes_ {
            return obj.tag === ValueType_Tags.Bytes;
        }

        

    }

    function instanceOf(obj: any): obj is ValueType {
        return obj[uniffiTypeNameSymbol] === "ValueType";
    }

    return Object.freeze({
        instanceOf,
  String: String_, 
  Int: Int_, 
  UInt: UInt_, 
  Bool: Bool_, 
  Bytes: Bytes_
    });

})();



export type ValueType = InstanceType<
    typeof ValueType[keyof Omit<typeof ValueType, 'instanceOf'>]
>;

// FfiConverter for enum ValueType
const FfiConverterTypeValueType = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = ValueType;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new ValueType.String({value: FfiConverterString.read(from) });
                case 2: return new ValueType.Int({value: FfiConverterInt64.read(from) });
                case 3: return new ValueType.UInt({value: FfiConverterUInt64.read(from) });
                case 4: return new ValueType.Bool({value: FfiConverterBool.read(from) });
                case 5: return new ValueType.Bytes({value: FfiConverterArrayUInt8.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case ValueType_Tags.String: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                case ValueType_Tags.Int: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterInt64.write(inner.value, into);
                    return;
                }
                case ValueType_Tags.UInt: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterUInt64.write(inner.value, into);
                    return;
                }
                case ValueType_Tags.Bool: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.value, into);
                    return;
                }
                case ValueType_Tags.Bytes: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterArrayUInt8.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that ValueType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case ValueType_Tags.String: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                case ValueType_Tags.Int: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterInt64.allocationSize(inner.value);
                    return size;
                }
                case ValueType_Tags.UInt: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterUInt64.allocationSize(inner.value);
                    return size;
                }
                case ValueType_Tags.Bool: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterBool.allocationSize(inner.value);
                    return size;
                }
                case ValueType_Tags.Bytes: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterArrayUInt8.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



export interface ToriiClientInterface {
    
    achievements(query: AchievementQuery)  /*throws*/: PageAchievement;
    activities(query: ActivityQuery)  /*throws*/: PageActivity;
    aggregations(query: AggregationQuery)  /*throws*/: PageAggregationEntry;
    cancelSubscription(subscriptionId: /*u64*/bigint)  /*throws*/: void;
    contracts(query: ContractQuery)  /*throws*/: Array<Contract>;
    controllers(query: ControllerQuery)  /*throws*/: PageController;
    entities(query: Query)  /*throws*/: PageEntity;
    eventMessages(query: Query)  /*throws*/: PageEntity;
    playerAchievements(query: PlayerAchievementQuery)  /*throws*/: PagePlayerAchievement;
    publishMessage(message: Message)  /*throws*/: string;
    publishMessageBatch(messages: Array<Message>)  /*throws*/: Array<string>;
    sql(query: string)  /*throws*/: Array<SqlRow>;
    starknetEvents(query: EventQuery)  /*throws*/: PageEvent;
    subscribeEntityUpdates(clause: Clause | undefined, worldAddresses: Array<FieldElement>, callback: EntityUpdateCallback)  /*throws*/: /*u64*/bigint;
    subscribeEventUpdates(keys: Array<KeysClause>, callback: EventUpdateCallback)  /*throws*/: /*u64*/bigint;
    subscribeTokenBalanceUpdates(contractAddresses: Array<FieldElement>, accountAddresses: Array<FieldElement>, tokenIds: Array<U256>, callback: TokenBalanceUpdateCallback)  /*throws*/: /*u64*/bigint;
    subscribeTokenUpdates(contractAddresses: Array<FieldElement>, tokenIds: Array<U256>, callback: TokenUpdateCallback)  /*throws*/: /*u64*/bigint;
    subscribeTransactionUpdates(filter: TransactionFilter | undefined, callback: TransactionUpdateCallback)  /*throws*/: /*u64*/bigint;
    tokenBalances(query: TokenBalanceQuery)  /*throws*/: PageTokenBalance;
    tokenContracts(query: TokenContractQuery)  /*throws*/: PageTokenContract;
    tokenTransfers(query: TokenTransferQuery)  /*throws*/: PageTokenTransfer;
    tokens(query: TokenQuery)  /*throws*/: PageToken;
    transactions(query: TransactionQuery)  /*throws*/: PageTransaction;
    worlds(worldAddresses: Array<FieldElement>)  /*throws*/: Array<World>;
}


export class ToriiClient extends UniffiAbstractObject implements ToriiClientInterface {

    readonly [uniffiTypeNameSymbol] = "ToriiClient";
    readonly [destructorGuardSymbol]: UniffiRustArcPtr;
    readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
    constructor(toriiUrl: string) /*throws*/ {
        super();
        const pointer =
            
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_constructor_toriiclient_new(
        FfiConverterString.lower(toriiUrl),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeToriiClientObjectFactory.bless(pointer);
    }

    
public static newWithConfig(toriiUrl: string, maxMessageSize: /*u64*/bigint): ToriiClientInterface /*throws*/ {
    return FfiConverterTypeToriiClient.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_constructor_toriiclient_new_with_config(
        FfiConverterString.lower(toriiUrl),
        FfiConverterUInt64.lower(maxMessageSize),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    

    
public achievements(query: AchievementQuery): PageAchievement /*throws*/ {
    return FfiConverterTypePageAchievement.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_achievements(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeAchievementQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public activities(query: ActivityQuery): PageActivity /*throws*/ {
    return FfiConverterTypePageActivity.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_activities(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeActivityQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public aggregations(query: AggregationQuery): PageAggregationEntry /*throws*/ {
    return FfiConverterTypePageAggregationEntry.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_aggregations(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeAggregationQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public cancelSubscription(subscriptionId: /*u64*/bigint): void /*throws*/ {
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => { nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_cancel_subscription(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterUInt64.lower(subscriptionId),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
    }
    
public contracts(query: ContractQuery): Array<Contract> /*throws*/ {
    return FfiConverterArrayTypeContract.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_contracts(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeContractQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public controllers(query: ControllerQuery): PageController /*throws*/ {
    return FfiConverterTypePageController.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_controllers(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeControllerQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public entities(query: Query): PageEntity /*throws*/ {
    return FfiConverterTypePageEntity.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_entities(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public eventMessages(query: Query): PageEntity /*throws*/ {
    return FfiConverterTypePageEntity.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_event_messages(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public playerAchievements(query: PlayerAchievementQuery): PagePlayerAchievement /*throws*/ {
    return FfiConverterTypePagePlayerAchievement.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_player_achievements(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypePlayerAchievementQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public publishMessage(message: Message): string /*throws*/ {
    return FfiConverterString.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_publish_message(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeMessage.lower(message),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public publishMessageBatch(messages: Array<Message>): Array<string> /*throws*/ {
    return FfiConverterArrayString.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_publish_message_batch(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterArrayTypeMessage.lower(messages),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public sql(query: string): Array<SqlRow> /*throws*/ {
    return FfiConverterArrayTypeSqlRow.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_sql(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterString.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public starknetEvents(query: EventQuery): PageEvent /*throws*/ {
    return FfiConverterTypePageEvent.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_starknet_events(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeEventQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public subscribeEntityUpdates(clause: Clause | undefined, worldAddresses: Array<FieldElement>, callback: EntityUpdateCallback): /*u64*/bigint /*throws*/ {
    return FfiConverterUInt64.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_entity_updates(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterOptionalTypeClause.lower(clause),
        FfiConverterArrayTypeFieldElement.lower(worldAddresses),
        FfiConverterTypeEntityUpdateCallback.lower(callback),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public subscribeEventUpdates(keys: Array<KeysClause>, callback: EventUpdateCallback): /*u64*/bigint /*throws*/ {
    return FfiConverterUInt64.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_event_updates(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterArrayTypeKeysClause.lower(keys),
        FfiConverterTypeEventUpdateCallback.lower(callback),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public subscribeTokenBalanceUpdates(contractAddresses: Array<FieldElement>, accountAddresses: Array<FieldElement>, tokenIds: Array<U256>, callback: TokenBalanceUpdateCallback): /*u64*/bigint /*throws*/ {
    return FfiConverterUInt64.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_balance_updates(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterArrayTypeFieldElement.lower(contractAddresses),
        FfiConverterArrayTypeFieldElement.lower(accountAddresses),
        FfiConverterArrayTypeU256.lower(tokenIds),
        FfiConverterTypeTokenBalanceUpdateCallback.lower(callback),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public subscribeTokenUpdates(contractAddresses: Array<FieldElement>, tokenIds: Array<U256>, callback: TokenUpdateCallback): /*u64*/bigint /*throws*/ {
    return FfiConverterUInt64.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_token_updates(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterArrayTypeFieldElement.lower(contractAddresses),
        FfiConverterArrayTypeU256.lower(tokenIds),
        FfiConverterTypeTokenUpdateCallback.lower(callback),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public subscribeTransactionUpdates(filter: TransactionFilter | undefined, callback: TransactionUpdateCallback): /*u64*/bigint /*throws*/ {
    return FfiConverterUInt64.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_subscribe_transaction_updates(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterOptionalTypeTransactionFilter.lower(filter),
        FfiConverterTypeTransactionUpdateCallback.lower(callback),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public tokenBalances(query: TokenBalanceQuery): PageTokenBalance /*throws*/ {
    return FfiConverterTypePageTokenBalance.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_token_balances(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeTokenBalanceQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public tokenContracts(query: TokenContractQuery): PageTokenContract /*throws*/ {
    return FfiConverterTypePageTokenContract.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_token_contracts(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeTokenContractQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public tokenTransfers(query: TokenTransferQuery): PageTokenTransfer /*throws*/ {
    return FfiConverterTypePageTokenTransfer.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_token_transfers(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeTokenTransferQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public tokens(query: TokenQuery): PageToken /*throws*/ {
    return FfiConverterTypePageToken.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_tokens(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeTokenQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public transactions(query: TransactionQuery): PageTransaction /*throws*/ {
    return FfiConverterTypePageTransaction.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_transactions(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterTypeTransactionQuery.lower(query),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public worlds(worldAddresses: Array<FieldElement>): Array<World> /*throws*/ {
    return FfiConverterArrayTypeWorld.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDojoError.lift.bind(FfiConverterTypeDojoError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_dojo_uniffi_fn_method_toriiclient_worlds(uniffiTypeToriiClientObjectFactory.clonePointer(this), 
        FfiConverterArrayTypeFieldElement.lower(worldAddresses),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    

    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy(): void {
        const ptr = (this as any)[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeToriiClientObjectFactory.pointer(this);
            uniffiTypeToriiClientObjectFactory.freePointer(pointer);
            uniffiTypeToriiClientObjectFactory.unbless(ptr);
            delete (this as any)[destructorGuardSymbol];
        }
    }

    static instanceOf(obj: any): obj is ToriiClient {
        return uniffiTypeToriiClientObjectFactory.isConcreteType(obj);
    }

    
}

const uniffiTypeToriiClientObjectFactory: UniffiObjectFactory<ToriiClientInterface> = (() => {
    
    return {
    create(pointer: UnsafeMutableRawPointer): ToriiClientInterface {
        const instance = Object.create(ToriiClient.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "ToriiClient";
        return instance;
    },

    
    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
            /*caller:*/ (status) =>
                nativeModule().ubrn_ffi_ToriiClient__bless_pointer(p, status),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
    },

    pointer(obj: ToriiClientInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
            throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ToriiClientInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_dojo_uniffi_fn_clone_toriiclient(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_dojo_uniffi_fn_free_toriiclient(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    isConcreteType(obj: any): obj is ToriiClientInterface {
        return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "ToriiClient";
    },
}})();
// FfiConverter for ToriiClientInterface
const FfiConverterTypeToriiClient =  new FfiConverterObject(uniffiTypeToriiClientObjectFactory);


// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);


// FfiConverter for KeysClause | undefined
const FfiConverterOptionalTypeKeysClause = new FfiConverterOptional(FfiConverterTypeKeysClause);


// FfiConverter for TransactionFilter | undefined
const FfiConverterOptionalTypeTransactionFilter = new FfiConverterOptional(FfiConverterTypeTransactionFilter);


// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);


// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);


// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);


// FfiConverter for Array<Achievement>
const FfiConverterArrayTypeAchievement = new FfiConverterArray(FfiConverterTypeAchievement);


// FfiConverter for Array<AchievementTask>
const FfiConverterArrayTypeAchievementTask = new FfiConverterArray(FfiConverterTypeAchievementTask);


// FfiConverter for Array<ActionCount>
const FfiConverterArrayTypeActionCount = new FfiConverterArray(FfiConverterTypeActionCount);


// FfiConverter for Array<Activity>
const FfiConverterArrayTypeActivity = new FfiConverterArray(FfiConverterTypeActivity);


// FfiConverter for Array<AggregationEntry>
const FfiConverterArrayTypeAggregationEntry = new FfiConverterArray(FfiConverterTypeAggregationEntry);


// FfiConverter for Array<AttributeFilter>
const FfiConverterArrayTypeAttributeFilter = new FfiConverterArray(FfiConverterTypeAttributeFilter);


// FfiConverter for Array<Contract>
const FfiConverterArrayTypeContract = new FfiConverterArray(FfiConverterTypeContract);


// FfiConverter for Array<Controller>
const FfiConverterArrayTypeController = new FfiConverterArray(FfiConverterTypeController);


// FfiConverter for Array<Entity>
const FfiConverterArrayTypeEntity = new FfiConverterArray(FfiConverterTypeEntity);


// FfiConverter for Array<EnumOption>
const FfiConverterArrayTypeEnumOption = new FfiConverterArray(FfiConverterTypeEnumOption);


// FfiConverter for Array<Event>
const FfiConverterArrayTypeEvent = new FfiConverterArray(FfiConverterTypeEvent);


// FfiConverter for Array<KeysClause>
const FfiConverterArrayTypeKeysClause = new FfiConverterArray(FfiConverterTypeKeysClause);


// FfiConverter for Array<Member>
const FfiConverterArrayTypeMember = new FfiConverterArray(FfiConverterTypeMember);


// FfiConverter for Array<Message>
const FfiConverterArrayTypeMessage = new FfiConverterArray(FfiConverterTypeMessage);


// FfiConverter for Array<Model>
const FfiConverterArrayTypeModel = new FfiConverterArray(FfiConverterTypeModel);


// FfiConverter for Array<OrderBy>
const FfiConverterArrayTypeOrderBy = new FfiConverterArray(FfiConverterTypeOrderBy);


// FfiConverter for Array<PlayerAchievementEntry>
const FfiConverterArrayTypePlayerAchievementEntry = new FfiConverterArray(FfiConverterTypePlayerAchievementEntry);


// FfiConverter for Array<PlayerAchievementProgress>
const FfiConverterArrayTypePlayerAchievementProgress = new FfiConverterArray(FfiConverterTypePlayerAchievementProgress);


// FfiConverter for Array<SqlField>
const FfiConverterArrayTypeSqlField = new FfiConverterArray(FfiConverterTypeSqlField);


// FfiConverter for Array<SqlRow>
const FfiConverterArrayTypeSqlRow = new FfiConverterArray(FfiConverterTypeSqlRow);


// FfiConverter for Array<Struct>
const FfiConverterArrayTypeStruct = new FfiConverterArray(FfiConverterTypeStruct);


// FfiConverter for Array<TaskProgress>
const FfiConverterArrayTypeTaskProgress = new FfiConverterArray(FfiConverterTypeTaskProgress);


// FfiConverter for Array<Token>
const FfiConverterArrayTypeToken = new FfiConverterArray(FfiConverterTypeToken);


// FfiConverter for Array<TokenBalance>
const FfiConverterArrayTypeTokenBalance = new FfiConverterArray(FfiConverterTypeTokenBalance);


// FfiConverter for Array<TokenContract>
const FfiConverterArrayTypeTokenContract = new FfiConverterArray(FfiConverterTypeTokenContract);


// FfiConverter for Array<TokenTransfer>
const FfiConverterArrayTypeTokenTransfer = new FfiConverterArray(FfiConverterTypeTokenTransfer);


// FfiConverter for Array<Transaction>
const FfiConverterArrayTypeTransaction = new FfiConverterArray(FfiConverterTypeTransaction);


// FfiConverter for Array<TransactionCall>
const FfiConverterArrayTypeTransactionCall = new FfiConverterArray(FfiConverterTypeTransactionCall);


// FfiConverter for Array<World>
const FfiConverterArrayTypeWorld = new FfiConverterArray(FfiConverterTypeWorld);


// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);


// FfiConverter for Array</*u8*/number>
const FfiConverterArrayUInt8 = new FfiConverterArray(FfiConverterUInt8);


// FfiConverter for FieldElement | undefined
const FfiConverterOptionalTypeFieldElement = new FfiConverterOptional(FfiConverterTypeFieldElement);


// FfiConverter for U256 | undefined
const FfiConverterOptionalTypeU256 = new FfiConverterOptional(FfiConverterTypeU256);


// FfiConverter for Clause | undefined
const FfiConverterOptionalTypeClause = new FfiConverterOptional(FfiConverterTypeClause);


// FfiConverter for Array<FieldElement>
const FfiConverterArrayTypeFieldElement = new FfiConverterArray(FfiConverterTypeFieldElement);


// FfiConverter for Array<U256>
const FfiConverterArrayTypeU256 = new FfiConverterArray(FfiConverterTypeU256);


// FfiConverter for Array<Clause>
const FfiConverterArrayTypeClause = new FfiConverterArray(FfiConverterTypeClause);


// FfiConverter for Array<ContractType>
const FfiConverterArrayTypeContractType = new FfiConverterArray(FfiConverterTypeContractType);


// FfiConverter for Array<MemberValue>
const FfiConverterArrayTypeMemberValue = new FfiConverterArray(FfiConverterTypeMemberValue);


// FfiConverter for Array<Ty>
const FfiConverterArrayTypeTy = new FfiConverterArray(FfiConverterTypeTy);


// FfiConverter for Array<FieldElement | undefined>
const FfiConverterArrayOptionalTypeFieldElement = new FfiConverterArray(FfiConverterOptionalTypeFieldElement);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 30;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_dojo_uniffi_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_achievements() !== 45327) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_achievements");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_activities() !== 43349) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_activities");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_aggregations() !== 12858) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_aggregations");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_cancel_subscription() !== 31182) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_cancel_subscription");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_contracts() !== 1861) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_contracts");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_controllers() !== 55573) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_controllers");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_entities() !== 50647) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_entities");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_event_messages() !== 35425) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_event_messages");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_player_achievements() !== 61773) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_player_achievements");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message() !== 30179) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message_batch() !== 2146) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_publish_message_batch");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_sql() !== 38286) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_sql");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_starknet_events() !== 44694) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_starknet_events");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_entity_updates() !== 17350) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_entity_updates");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_event_updates() !== 63983) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_event_updates");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_balance_updates() !== 26741) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_balance_updates");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_updates() !== 54836) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_token_updates");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_transaction_updates() !== 10040) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_subscribe_transaction_updates");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_token_balances() !== 1716) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_token_balances");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_token_contracts() !== 49563) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_token_contracts");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_token_transfers() !== 10363) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_token_transfers");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_tokens() !== 10630) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_tokens");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_transactions() !== 46460) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_transactions");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_toriiclient_worlds() !== 23254) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_toriiclient_worlds");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_constructor_toriiclient_new() !== 18057) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_constructor_toriiclient_new");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_constructor_toriiclient_new_with_config() !== 42232) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_constructor_toriiclient_new_with_config");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_update() !== 15850) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_update");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_error() !== 340) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_entityupdatecallback_on_error");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_update() !== 13627) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_update");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_error() !== 61050) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_eventupdatecallback_on_error");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_update() !== 10763) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_update");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_error() !== 46610) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_tokenbalanceupdatecallback_on_error");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_update() !== 40037) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_update");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_error() !== 14408) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_tokenupdatecallback_on_error");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_update() !== 11896) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_update");
    }
    if (nativeModule().ubrn_uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_error() !== 18113) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_dojo_uniffi_checksum_method_transactionupdatecallback_on_error");
    }

    uniffiCallbackInterfaceEntityUpdateCallback.register();
    uniffiCallbackInterfaceEventUpdateCallback.register();
    uniffiCallbackInterfaceTokenBalanceUpdateCallback.register();
    uniffiCallbackInterfaceTokenUpdateCallback.register();
    uniffiCallbackInterfaceTransactionUpdateCallback.register();
    }

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAchievement,
    FfiConverterTypeAchievementProgression,
    FfiConverterTypeAchievementQuery,
    FfiConverterTypeAchievementTask,
    FfiConverterTypeActionCount,
    FfiConverterTypeActivity,
    FfiConverterTypeActivityQuery,
    FfiConverterTypeAggregationEntry,
    FfiConverterTypeAggregationQuery,
    FfiConverterTypeAttributeFilter,
    FfiConverterTypeCallType,
    FfiConverterTypeClause,
    FfiConverterTypeComparisonOperator,
    FfiConverterTypeCompositeClause,
    FfiConverterTypeContract,
    FfiConverterTypeContractQuery,
    FfiConverterTypeContractType,
    FfiConverterTypeController,
    FfiConverterTypeControllerQuery,
    FfiConverterTypeDojoError,
    FfiConverterTypeEntity,
    FfiConverterTypeEnumOption,
    FfiConverterTypeEnumType,
    FfiConverterTypeEvent,
    FfiConverterTypeEventQuery,
    FfiConverterTypeFieldElement,
    FfiConverterTypeFixedSizeArray,
    FfiConverterTypeKeysClause,
    FfiConverterTypeLogicalOperator,
    FfiConverterTypeMember,
    FfiConverterTypeMemberClause,
    FfiConverterTypeMemberValue,
    FfiConverterTypeMessage,
    FfiConverterTypeModel,
    FfiConverterTypeOrderBy,
    FfiConverterTypeOrderDirection,
    FfiConverterTypePageAchievement,
    FfiConverterTypePageActivity,
    FfiConverterTypePageAggregationEntry,
    FfiConverterTypePageController,
    FfiConverterTypePageEntity,
    FfiConverterTypePageEvent,
    FfiConverterTypePagePlayerAchievement,
    FfiConverterTypePageToken,
    FfiConverterTypePageTokenBalance,
    FfiConverterTypePageTokenContract,
    FfiConverterTypePageTokenTransfer,
    FfiConverterTypePageTransaction,
    FfiConverterTypePagination,
    FfiConverterTypePaginationDirection,
    FfiConverterTypePatternMatching,
    FfiConverterTypePlayerAchievementEntry,
    FfiConverterTypePlayerAchievementProgress,
    FfiConverterTypePlayerAchievementQuery,
    FfiConverterTypePlayerAchievementStats,
    FfiConverterTypePrimitive,
    FfiConverterTypeQuery,
    FfiConverterTypeSignature,
    FfiConverterTypeSqlField,
    FfiConverterTypeSqlRow,
    FfiConverterTypeSqlValue,
    FfiConverterTypeStruct,
    FfiConverterTypeTaskProgress,
    FfiConverterTypeToken,
    FfiConverterTypeTokenBalance,
    FfiConverterTypeTokenBalanceQuery,
    FfiConverterTypeTokenContract,
    FfiConverterTypeTokenContractQuery,
    FfiConverterTypeTokenQuery,
    FfiConverterTypeTokenTransfer,
    FfiConverterTypeTokenTransferQuery,
    FfiConverterTypeToriiClient,
    FfiConverterTypeTransaction,
    FfiConverterTypeTransactionCall,
    FfiConverterTypeTransactionFilter,
    FfiConverterTypeTransactionQuery,
    FfiConverterTypeTy,
    FfiConverterTypeU256,
    FfiConverterTypeValueType,
    FfiConverterTypeWorld,
  }
});