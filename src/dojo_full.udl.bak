namespace dojo {
};

// Core types
[Custom]
typedef string FieldElement;

[Custom]
typedef string U256;

// Simple Enums (no associated data)
enum PaginationDirection {
    "Forward",
    "Backward",
};

enum OrderDirection {
    "Asc",
    "Desc",
};

enum ContractType {
    "WORLD",
    "ERC20",
    "ERC721",
    "ERC1155",
    "UDC",
    "OTHER",
};

enum CallType {
    "Execute",
    "ExecuteFromOutside",
};

// Basic structures
dictionary Signature {
    FieldElement r;
    FieldElement s;
};

dictionary OrderBy {
    string field;
    OrderDirection direction;
};

dictionary Pagination {
    string? cursor;
    u32? limit;
    PaginationDirection direction;
    sequence<OrderBy> order_by;
};

// Controller
dictionary Controller {
    FieldElement address;
    string username;
    u64 deployed_at_timestamp;
};

dictionary ControllerQuery {
    Pagination pagination;
    sequence<FieldElement> contract_addresses;
    sequence<string> usernames;
};

// Token types
dictionary Token {
    FieldElement contract_address;
    U256? token_id;
    string name;
    string symbol;
    u8 decimals;
    string metadata;
    U256? total_supply;
};

dictionary TokenBalance {
    U256 balance;
    FieldElement account_address;
    FieldElement contract_address;
    U256? token_id;
};

dictionary TokenContract {
    FieldElement contract_address;
    string name;
    string symbol;
    u8 decimals;
    string metadata;
    string token_metadata;
    U256? total_supply;
};

dictionary AttributeFilter {
    string trait_name;
    string trait_value;
};

dictionary TokenQuery {
    sequence<FieldElement> contract_addresses;
    sequence<U256> token_ids;
    sequence<AttributeFilter> attribute_filters;
    Pagination pagination;
};

dictionary TokenBalanceQuery {
    sequence<FieldElement> contract_addresses;
    sequence<FieldElement> account_addresses;
    sequence<U256> token_ids;
    Pagination pagination;
};

dictionary TokenContractQuery {
    sequence<FieldElement> contract_addresses;
    sequence<ContractType> contract_types;
    Pagination pagination;
};

dictionary TokenTransfer {
    string id;
    FieldElement contract_address;
    FieldElement from_address;
    FieldElement to_address;
    U256 amount;
    U256? token_id;
    u64 executed_at;
    string? event_id;
};

dictionary TokenTransferQuery {
    sequence<FieldElement> contract_addresses;
    sequence<FieldElement> account_addresses;
    sequence<U256> token_ids;
    Pagination pagination;
};

// Contract
dictionary Contract {
    FieldElement contract_address;
    ContractType contract_type;
    u64? head;
    u64? tps;
    u64? last_block_timestamp;
    FieldElement? last_pending_block_tx;
    u64 updated_at;
    u64 created_at;
};

dictionary ContractQuery {
    sequence<FieldElement> contract_addresses;
    sequence<ContractType> contract_types;
};

// Transaction types (simplified - no complex Call type)
dictionary TransactionCall {
    FieldElement contract_address;
    string entrypoint;
    sequence<FieldElement> calldata;
    CallType call_type;
    FieldElement caller_address;
};

dictionary Transaction {
    FieldElement transaction_hash;
    FieldElement sender_address;
    sequence<FieldElement> calldata;
    FieldElement max_fee;
    sequence<FieldElement> signature;
    FieldElement nonce;
    u64 block_number;
    string transaction_type;
    u64 block_timestamp;
    sequence<TransactionCall> calls;
    sequence<FieldElement> unique_models;
};

dictionary TransactionFilter {
    sequence<FieldElement> transaction_hashes;
    sequence<FieldElement> caller_addresses;
    sequence<FieldElement> contract_addresses;
    sequence<string> entrypoints;
    sequence<FieldElement> model_selectors;
    u64? from_block;
    u64? to_block;
};

dictionary TransactionQuery {
    TransactionFilter? filter;
    Pagination pagination;
};

// Aggregation
dictionary AggregationQuery {
    sequence<string> aggregator_ids;
    sequence<string> entity_ids;
    Pagination pagination;
};

dictionary AggregationEntry {
    string id;
    string aggregator_id;
    string entity_id;
    U256 value;
    string display_value;
    u64 position;
    string model_id;
    u64 created_at;
    u64 updated_at;
};

// Activity
dictionary ActionCount {
    string action_name;
    u32 count;
};

dictionary Activity {
    string id;
    FieldElement world_address;
    string namespace;
    FieldElement caller_address;
    u64 session_start;
    u64 session_end;
    u32 action_count;
    sequence<ActionCount> actions;
    u64 updated_at;
};

dictionary ActivityQuery {
    sequence<FieldElement> world_addresses;
    sequence<string> namespaces;
    sequence<FieldElement> caller_addresses;
    u64? from_time;
    u64? to_time;
    Pagination pagination;
};

// Achievement
dictionary AchievementTask {
    string task_id;
    string description;
    u32 total;
    u32 total_completions;
    f64 completion_rate;
    u64 created_at;
};

dictionary Achievement {
    string id;
    FieldElement world_address;
    string namespace;
    string entity_id;
    boolean hidden;
    u32 index;
    u32 points;
    string start;
    string end;
    string group;
    string icon;
    string title;
    string description;
    sequence<AchievementTask> tasks;
    string? data;
    u32 total_completions;
    f64 completion_rate;
    u64 created_at;
    u64 updated_at;
};

dictionary AchievementQuery {
    sequence<FieldElement> world_addresses;
    sequence<string> namespaces;
    boolean? hidden;
    Pagination pagination;
};

dictionary TaskProgress {
    string task_id;
    u32 count;
    boolean completed;
};

dictionary PlayerAchievementProgress {
    Achievement achievement;
    sequence<TaskProgress> task_progress;
    boolean completed;
    f64 progress_percentage;
};

dictionary PlayerAchievementStats {
    u32 total_points;
    u32 completed_achievements;
    u32 total_achievements;
    f64 completion_percentage;
    u64? last_achievement_at;
    u64 created_at;
    u64 updated_at;
};

dictionary PlayerAchievementEntry {
    FieldElement player_address;
    PlayerAchievementStats stats;
    sequence<PlayerAchievementProgress> achievements;
};

dictionary PlayerAchievementQuery {
    sequence<FieldElement> world_addresses;
    sequence<string> namespaces;
    sequence<FieldElement> player_addresses;
    Pagination pagination;
};

dictionary AchievementProgression {
    string id;
    string achievement_id;
    string task_id;
    FieldElement world_address;
    string namespace;
    FieldElement player_id;
    u32 count;
    boolean completed;
    u64? completed_at;
    u64 created_at;
    u64 updated_at;
};

// Error type
[Error]
enum DojoError {
    "ClientError",
    "SerializationError",
    "NetworkError",
    "InvalidInput",
};
