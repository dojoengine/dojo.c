// Simplified UDL - just the types that work easily with UniFFI
// Complex recursive types (Primitive, Ty, Clause, etc.) should be handled
// via procmacros in Rust rather than UDL

namespace dojo {
};

// Core types
[Custom]
typedef string FieldElement;

[Custom]
typedef string U256;

// Enums
enum PaginationDirection {
    "Forward",
    "Backward",
};

enum OrderDirection {
    "Asc",
    "Desc",
};

enum ContractType {
    "WORLD",
    "ERC20",
    "ERC721",
    "ERC1155",
    "UDC",
    "OTHER",
};

enum CallType {
    "Execute",
    "ExecuteFromOutside",
};

enum PatternMatching {
    "FixedLen",
    "VariableLen",
};

enum LogicalOperator {
    "And",
    "Or",
};

enum ComparisonOperator {
    "Eq",
    "Neq",
    "Gt",
    "Gte",
    "Lt",
    "Lte",
    "In",
    "NotIn",
    "Contains",
    "ContainsAll",
    "ContainsAny",
    "ArrayLengthEq",
    "ArrayLengthGt",
    "ArrayLengthLt",
};

// Basic structures
dictionary Signature {
    FieldElement r;
    FieldElement s;
};

dictionary OrderBy {
    string field;
    OrderDirection direction;
};

dictionary Pagination {
    string? cursor;
    u32? limit;
    PaginationDirection direction;
    sequence<OrderBy> order_by;
};

// Controller
dictionary Controller {
    FieldElement address;
    string username;
    u64 deployed_at_timestamp;
};

dictionary ControllerQuery {
    Pagination pagination;
    sequence<FieldElement> contract_addresses;
    sequence<string> usernames;
};

// Token types
dictionary Token {
    FieldElement contract_address;
    U256? token_id;
    string name;
    string symbol;
    u8 decimals;
    string metadata;
    U256? total_supply;
};

dictionary TokenBalance {
    U256 balance;
    FieldElement account_address;
    FieldElement contract_address;
    U256? token_id;
};

dictionary TokenContract {
    FieldElement contract_address;
    string name;
    string symbol;
    u8 decimals;
    string metadata;
    string token_metadata;
    U256? total_supply;
};

dictionary AttributeFilter {
    string trait_name;
    string trait_value;
};

dictionary TokenQuery {
    sequence<FieldElement> contract_addresses;
    sequence<U256> token_ids;
    sequence<AttributeFilter> attribute_filters;
    Pagination pagination;
};

dictionary TokenBalanceQuery {
    sequence<FieldElement> contract_addresses;
    sequence<FieldElement> account_addresses;
    sequence<U256> token_ids;
    Pagination pagination;
};

dictionary TokenContractQuery {
    sequence<FieldElement> contract_addresses;
    sequence<ContractType> contract_types;
    Pagination pagination;
};

dictionary TokenTransfer {
    string id;
    FieldElement contract_address;
    FieldElement from_address;
    FieldElement to_address;
    U256 amount;
    U256? token_id;
    u64 executed_at;
    string? event_id;
};

dictionary TokenTransferQuery {
    sequence<FieldElement> contract_addresses;
    sequence<FieldElement> account_addresses;
    sequence<U256> token_ids;
    Pagination pagination;
};

// Contract
dictionary Contract {
    FieldElement contract_address;
    ContractType contract_type;
    u64? head;
    u64? tps;
    u64? last_block_timestamp;
    FieldElement? last_pending_block_tx;
    u64 updated_at;
    u64 created_at;
};

dictionary ContractQuery {
    sequence<FieldElement> contract_addresses;
    sequence<ContractType> contract_types;
};

// Transaction types
dictionary TransactionCall {
    FieldElement contract_address;
    string entrypoint;
    sequence<FieldElement> calldata;
    CallType call_type;
    FieldElement caller_address;
};

dictionary Transaction {
    FieldElement transaction_hash;
    FieldElement sender_address;
    sequence<FieldElement> calldata;
    FieldElement max_fee;
    sequence<FieldElement> signature;
    FieldElement nonce;
    u64 block_number;
    string transaction_type;
    u64 block_timestamp;
    sequence<TransactionCall> calls;
    sequence<FieldElement> unique_models;
};

dictionary TransactionFilter {
    sequence<FieldElement> transaction_hashes;
    sequence<FieldElement> caller_addresses;
    sequence<FieldElement> contract_addresses;
    sequence<string> entrypoints;
    sequence<FieldElement> model_selectors;
    u64? from_block;
    u64? to_block;
};

dictionary TransactionQuery {
    TransactionFilter? filter;
    Pagination pagination;
};

// Aggregation
dictionary AggregationQuery {
    sequence<string> aggregator_ids;
    sequence<string> entity_ids;
    Pagination pagination;
};

dictionary AggregationEntry {
    string id;
    string aggregator_id;
    string entity_id;
    U256 value;
    string display_value;
    u64 position;
    string model_id;
    u64 created_at;
    u64 updated_at;
};

// Activity
dictionary ActionCount {
    string action_name;
    u32 count;
};

dictionary Activity {
    string id;
    FieldElement world_address;
    string namespace;
    FieldElement caller_address;
    u64 session_start;
    u64 session_end;
    u32 action_count;
    sequence<ActionCount> actions;
    u64 updated_at;
};

dictionary ActivityQuery {
    sequence<FieldElement> world_addresses;
    sequence<string> namespaces;
    sequence<FieldElement> caller_addresses;
    u64? from_time;
    u64? to_time;
    Pagination pagination;
};

// Achievement
dictionary AchievementTask {
    string task_id;
    string description;
    u32 total;
    u32 total_completions;
    f64 completion_rate;
    u64 created_at;
};

dictionary Achievement {
    string id;
    FieldElement world_address;
    string namespace;
    string entity_id;
    boolean hidden;
    u32 index;
    u32 points;
    string start;
    string end;
    string group;
    string icon;
    string title;
    string description;
    sequence<AchievementTask> tasks;
    string? data;
    u32 total_completions;
    f64 completion_rate;
    u64 created_at;
    u64 updated_at;
};

dictionary AchievementQuery {
    sequence<FieldElement> world_addresses;
    sequence<string> namespaces;
    boolean? hidden;
    Pagination pagination;
};

dictionary TaskProgress {
    string task_id;
    u32 count;
    boolean completed;
};

dictionary PlayerAchievementProgress {
    Achievement achievement;
    sequence<TaskProgress> task_progress;
    boolean completed;
    f64 progress_percentage;
};

dictionary PlayerAchievementStats {
    u32 total_points;
    u32 completed_achievements;
    u32 total_achievements;
    f64 completion_percentage;
    u64? last_achievement_at;
    u64 created_at;
    u64 updated_at;
};

dictionary PlayerAchievementEntry {
    FieldElement player_address;
    PlayerAchievementStats stats;
    sequence<PlayerAchievementProgress> achievements;
};

dictionary PlayerAchievementQuery {
    sequence<FieldElement> world_addresses;
    sequence<string> namespaces;
    sequence<FieldElement> player_addresses;
    Pagination pagination;
};

dictionary AchievementProgression {
    string id;
    string achievement_id;
    string task_id;
    FieldElement world_address;
    string namespace;
    FieldElement player_id;
    u32 count;
    boolean completed;
    u64? completed_at;
    u64 created_at;
    u64 updated_at;
};

// Schema types - Complex enums with associated data

[Enum]
interface Primitive {
    I8(i8 value);
    I16(i16 value);
    I32(i32 value);
    I64(i64 value);
    I128(sequence<u8> value);
    U8(u8 value);
    U16(u16 value);
    U32(u32 value);
    U64(u64 value);
    U128(sequence<u8> value);
    U256(U256 value);
    Bool(boolean value);
    Felt252(FieldElement value);
    ClassHash(FieldElement value);
    ContractAddress(FieldElement value);
    EthAddress(FieldElement value);
};

[Enum]
interface MemberValue {
    Primitive(Primitive value);
    String(string value);
    List(sequence<MemberValue> values);
};

dictionary Member {
    string name;
    Ty ty;
    boolean key;
};

dictionary Struct {
    string name;
    sequence<Member> children;
};

dictionary EnumOption {
    string name;
    Ty ty;
};

dictionary EnumType {
    string name;
    u8 option;
    sequence<EnumOption> options;
};

dictionary FixedSizeArray {
    sequence<Ty> array;
    u32 size;
};

[Enum]
interface Ty {
    Primitive(Primitive value);
    Struct(Struct value);
    Enum(EnumType value);
    Tuple(sequence<Ty> values);
    Array(sequence<Ty> values);
    FixedSizeArray(FixedSizeArray value);
    ByteArray(string value);
};

[Enum]
interface ValueType {
    String(string value);
    Int(i64 value);
    UInt(u64 value);
    Bool(boolean value);
    Bytes(sequence<u8> value);
};

// Query types - Complex enums for query building

dictionary KeysClause {
    sequence<FieldElement?> keys;
    PatternMatching pattern_matching;
    sequence<string> models;
};

dictionary MemberClause {
    string model;
    string member;
    ComparisonOperator operator;
    MemberValue value;
};

dictionary CompositeClause {
    LogicalOperator operator;
    sequence<Clause> clauses;
};

[Enum]
interface Clause {
    HashedKeys(sequence<FieldElement> keys);
    Keys(KeysClause clause);
    Member(MemberClause clause);
    Composite(CompositeClause clause);
};

// Error type
[Error]
interface DojoError {
    ClientError(string message);
    SerializationError(string message);
    NetworkError(string message);
    InvalidInput();
    ConnectionError();
    PublishError();
    QueryError(string message);
    SubscriptionError();
};
